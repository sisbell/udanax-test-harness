# Finding 0046 Analysis

## Entries

### PRE-COPY

**What happens:** The COPY operation performs NO duplicate checking before inserting V→I mappings into the target document's POOM. The `insertpm()` function in `orglinks.c:75-134` delegates to `insertnd()` in `insertnd.c:15-111`, which calls `isanextensionnd()` to check only whether the new content is contiguous with an existing crum — never whether the I-address already exists in the target. A COPY of I-addresses that already exist at some V-position in the target document is unconditionally accepted.

**Why it matters for spec:** The precondition for COPY does NOT include `iaddrs(source) ∩ iaddrs(target) = ∅`. A formal precondition should state: `pre_copy(source_doc, source_vspan, target_doc, target_vpos) = is_valid_doc(source_doc) ∧ is_valid_doc(target_doc) ∧ content_exists(source_doc, source_vspan)`. There is no uniqueness guard — the same I-address can intentionally appear at multiple V-positions via repeated COPY.

**Code references:**
- `insertpm()` — `orglinks.c:75-134` — POOM insertion wrapper, no duplicate guard
- `insertnd()` — `insertnd.c:15-111` — Main insertion logic, no duplicate guard
- `isanextensionnd()` — `insertnd.c:293-301` — Checks contiguity only, not uniqueness

**Concrete example:**
```
Source doc has "ABCDE" at I-addresses i₁..i₅.

COPY to target at V=1.1:  target POOM gets V 1.1..1.5 → i₁..i₅
COPY to target at V=1.10: target POOM gets V 1.10..1.14 → i₁..i₅  (no rejection)
COPY to target at V=1.8:  target POOM gets V 1.8..1.12 → i₁..i₅   (no rejection)

All three COPYs succeed. Same I-addresses now at three V-positions.
```

**Provenance:** Finding 0046

### ST-VCOPY

**What happens:** When COPY inserts V→I mappings into a POOM, the insertion follows an extension-or-create rule. The function `isanextensionnd()` at `insertnd.c:293-301` checks two conditions: (1) the new mapping has the same `homedoc` (I-address origin document) as an existing crum, and (2) the new mapping starts exactly where the existing crum ends (contiguous in both V and I dimensions). If both hold, the existing crum's width is extended in place (`insertnd.c:243`). Otherwise, a new crum is created (`insertnd.c:252-260`). This means repeated COPYs of the same I-addresses produce either extended crums or separate crums depending on contiguity, never duplicated entries within a single crum.

**Why it matters for spec:** The COPY postcondition should account for POOM compaction: `post_copy(target, vpos, ispan) = forall offset in 0..|ispan| :: poom(target, vpos + offset) = ispan.start + offset`. The implementation may merge this mapping with adjacent crums, but the logical mapping is the same regardless. For spec purposes, the crum structure is an implementation detail — the observable effect is the V→I mapping. However, the extension check's `homedoc` condition means crums from different source documents are never merged, which constrains how the POOM partitions its internal structure.

**Code references:**
- `isanextensionnd()` — `insertnd.c:293-301` — Extension check: same homedoc AND contiguous
- `insertnd.c:243` — Extends existing crum width
- `insertnd.c:252-260` — Creates new crum when not an extension
- `docopy()` — `do1.c:45-65` — COPY operation entry point

**Concrete example:**
```
Before: target POOM has crum [V 1.1..1.5 → i₁..i₅] (from first COPY)

COPY same source at V=1.6 (contiguous, same homedoc):
  isanextensionnd() → TRUE
  Result: crum extended to [V 1.1..1.10 → i₁..i₁₀]

COPY same source at V=1.20 (non-contiguous):
  isanextensionnd() → FALSE
  Result: new crum created [V 1.20..1.24 → i₁..i₅]
```

**Provenance:** Finding 0046

### ST-VERSION-CREATE

**What happens:** `CREATENEWVERSION` copies ONLY the text subspace (V-dimension 1.x) from the source document's POOM, not the link subspace (2.x). The function `docreatenewversion()` at `do1.c:264-303` calls `doretrievedocvspanfoo()` which delegates to `retrievedocumentpartofvspanpm()` at `orglinks.c:155-162`. That function extracts only the V-dimension width from the root crum, which covers the 1.x text subspace. Links stored at 2.x V-positions are excluded because they fall outside this V-dimension width. The version's POOM therefore contains only text V→I mappings.

**Why it matters for spec:** The postcondition for CREATENEWVERSION is: `poom(new_doc) = { (v, i) ∈ poom(source) | v.subspace = 1 }`. The version shares I-addresses with the source for text content but has NO link entries in its own POOM. Despite this, links ARE discoverable from the version because `find_links` operates in I-space via the spanf index — shared I-addresses cause the version to "inherit" links. This separates the document-level model (POOM contains text only) from the system-level model (links discoverable via shared I-addresses).

**Code references:**
- `docreatenewversion()` — `do1.c:264-303` — Version creation, text-only copy
- `doretrievedocvspanfoo()` — `do1.c:305-313` — Extracts text V-span
- `retrievedocumentpartofvspanpm()` — `orglinks.c:155-162` — V-dimension extraction (self-described as "a kluge")
- `docopyinternal()` — called from `docreatenewversion()` to copy text content

**Concrete example:**
```
Original document:
  vspanset = [{start: "0", width: "0.1"}, {start: "1", width: "1"}]
  (links at 0.x, text at 1.x)

After CREATENEWVERSION:
  Version vspanset = [{start: "1.1", width: "0.34"}]
  (text only, no link subspace)

  find_links FROM version → ["1.1.0.1.0.1.0.2.1"]
  (link discovered via shared I-addresses, not via version's POOM)
```

**Provenance:** Finding 0046

### INV-IADDR-PROVENANCE

**What happens:** Every I-address has exactly one native document — the document where INSERT first allocated it. COPY does not allocate new I-addresses; it creates V→I mappings that reference existing ones. The `homedoc` field in each POOM crum records the I-address origin document, not the document from which content was most recently copied. This means provenance (which document originally created the content) is permanently encoded in the I-address itself and is not affected by subsequent COPY operations.

**Why it matters for spec:** This is a system-wide invariant: `forall i : IAddress :: |{ d : Doc | is_native(d, i) }| = 1`. Each I-address has a unique native document. The compensation function (mapping any I-address to its origin) is total. INSERT allocates fresh I-addresses under the target document; COPY references existing ones. Provenance tracking requires I-address inspection — from V-addresses alone, INSERT and COPY produce indistinguishable POOM structures.

**Code references:**
- `insertnd.c:293-301` — `isanextensionnd()` checks `homedoc` to verify I-address origin
- `do1.c:45-65` — `docopy()` references existing I-addresses
- INSERT allocates fresh I-addresses under target document's address space

**Concrete example:**
```
doc_A: INSERT "hello" → allocates I-addresses i₁..i₅ (native to doc_A)
doc_B: COPY from doc_A → maps V-positions to i₁..i₅ (native to doc_A, not doc_B)
doc_C: COPY from doc_B → maps V-positions to i₁..i₅ (still native to doc_A)

is_native(doc_A, i₁) = true
is_native(doc_B, i₁) = false  (doc_B only references i₁)
is_native(doc_C, i₁) = false  (doc_C only references i₁)
```

**Provenance:** Finding 0046

### INT-LINK-VERSION

**What happens:** A version created by CREATENEWVERSION discovers links from the original document even though the version's POOM contains no link entries. This works because: (1) the version shares text I-addresses with the original, (2) links are stored in the spanf (span enfilade) index keyed by I-address, and (3) `find_links` converts V-spans to I-spans then searches the spanf. Since the version's text maps to the same I-addresses as the original, the same spanf entries match. The link "inheritance" is not an explicit mechanism — it is an emergent consequence of identity-based link indexing.

**Why it matters for spec:** The version-link relationship can be derived from more primitive facts: `findlinks(version, vspan) = findlinks_by_iaddr(vspan2ispan(version, vspan))`, and `vspan2ispan(version, v) ⊆ vspan2ispan(original, v')` for corresponding positions. No special version-link rule is needed in the spec — the general link discovery mechanism (INT-LINK-TRANSCLUSION) covers this case because versioning IS transclusion of the text subspace.

**Code references:**
- Test result: version with `find_links FROM version → ["1.1.0.1.0.1.0.2.1"]`
- `docreatenewversion()` — `do1.c:264-303` — copies text I-addresses
- Link discovery via spanf operates in I-space, not document POOM

**Provenance:** Finding 0046
