# Finding 0030 Analysis

## Entries

### ST-INSERT

**What happens**: INSERT at V-position `p` of text with length `n` produces the following state transition on the document's V-to-I mapping:

1. **Before insertion point** (V-addr < p): V-to-I mappings are unchanged — same V-address, same I-address.
2. **At insertion point** (V-addr p through p+n-1): Fresh I-addresses are allocated for the new content. These I-addresses have no prior identity relationship with any existing content.
3. **After insertion point** (V-addr >= p, pre-insert): Each character's V-address shifts by +n. Its I-address is unchanged.

Formally, for a document state `D : VAddr -> IAddr`:
```
D'(v) =
  D(v)           if v < p
  fresh_iaddr(v) if p <= v < p + n
  D(v - n)       if v >= p + n
```

The `compare_versions` operation confirms this: it returns spans pairing old V-ranges to new V-ranges where I-addresses match. Content before the insertion point maps 1:1 at the same positions. Content after maps with a +n offset. Inserted content has no corresponding span in the prior version.

**Why it matters for spec**: This is the complete postcondition for INSERT on the V-to-I mapping. The key formal properties are: (1) the I-address set of existing content is invariant under INSERT — no existing I-address is destroyed or reassigned; (2) V-address shift is exactly the length of the inserted text; (3) fresh I-addresses are disjoint from all previously allocated I-addresses. This distinguishes INSERT from a mutable-buffer model: it extends the identity space rather than modifying it.

**Code references**: Test scenario `insert_vspace_mapping.py` — verifies V-to-I mapping before and after insertion

**Concrete example**:

Before INSERT at V-position 1.3:
```
V-addr: 1.1  1.2  1.3  1.4  1.5
Content: A    B    C    D    E
I-addr: I.1  I.2  I.3  I.4  I.5
```

After INSERT "XY" at 1.3:
```
V-addr: 1.1  1.2  1.3  1.4  1.5  1.6  1.7
Content: A    B    X    Y    C    D    E
I-addr: I.1  I.2  I.6  I.7  I.3  I.4  I.5
```

`compare_versions` returns:
```
[{version_before: 1.1 for 0.2, current: 1.1 for 0.2},   // "AB" same position
 {version_before: 1.3 for 0.3, current: 1.5 for 0.3}]   // "CDE" shifted +2
```

No span for positions 1.3-1.4 in current — "XY" has no shared I-addresses with any prior version.

**Provenance**: Finding 0030

### INV-IADDR-IMMUTABILITY

**What happens**: I-addresses, once assigned to content, never change. INSERT shifts V-addresses but preserves every existing I-address assignment. Content "C" that had I-address I.3 before insertion still has I-address I.3 after insertion, even though its V-address moved from 1.3 to 1.5. This holds for all content in the document, regardless of position relative to the insertion point.

**Why it matters for spec**: This is the core immutability invariant for the identity layer: `forall content c, operation op :: iaddr(c, before(op)) == iaddr(c, after(op))`. No operation in the system reassigns or destroys an I-address. This is what makes cross-document identity (transclusion) and version comparison possible — both depend on I-addresses being stable reference points. This invariant should be asserted universally across all state transitions, not just INSERT.

**Code references**: `insert_vspace_mapping.py` — `compare_versions` output confirms I-address stability by showing before/after V-span pairs that share identity

**Provenance**: Finding 0030

### FC-INSERT-IADDR

**What happens**: INSERT does not modify the I-address of any pre-existing content, in the target document or in any other document. The operation's effect on the identity layer is purely additive: it allocates fresh I-addresses for inserted material. All existing V-to-I mappings outside the target document are completely untouched. Within the target document, existing I-addresses are preserved — only V-addresses change.

**Why it matters for spec**: Frame condition for INSERT on the identity layer: `forall doc d != target, forall v in d :: d.mapping(v) is unchanged`. And within the target: `forall v in target where v mapped to I before INSERT :: exists v' in target' where target'.mapping(v') == I`. No I-address is lost; they may appear at different V-positions but the I-address itself is invariant.

**Provenance**: Finding 0030

### INT-LINK-INSERT

**What happens**: Links attached to content via I-addresses survive insertion because I-addresses are immutable. A link targeting "CDE" (I-addresses I.3-I.5) remains valid after inserting "XY" at position 1.3. The link's I-address endpoints are unchanged. Link discovery via `find_links` still works. The V-address interpretation of the link shifts (the linked content now appears at 1.5-1.7 instead of 1.3-1.5), but the link itself references I-addresses and needs no update.

**Why it matters for spec**: Links are specified in I-space, not V-space. This means INSERT never invalidates any link. The formal property is: `forall link L :: INSERT does not modify L.from_iaddr or L.to_iaddr`. The V-space rendering of a link's endpoints changes (it must be recomputed from the current V-to-I mapping), but the link object is a frame-condition invariant of INSERT.

**Provenance**: Finding 0030

### INT-TRANSCLUSION

**What happens**: Transclusions (cross-document content sharing via `vcopy`) maintain identity across insertions because they reference I-addresses. If document B transcluded "CDE" from document A (sharing I-addresses I.3-I.5), and then text is inserted into document A shifting "CDE" from V-positions 1.3-1.5 to 1.5-1.7, the transclusion is unaffected. Document B still references I.3-I.5, and `compare_versions` between the documents still reveals shared identity.

**Why it matters for spec**: Transclusion is an I-space relationship, invariant under V-space mutations. The formal property: `forall doc A, doc B, iaddr set S :: if B.references(S) before INSERT into A, then B.references(S) after INSERT into A`. INSERT into one document has zero effect on other documents' I-address reference sets.

**Provenance**: Finding 0030
