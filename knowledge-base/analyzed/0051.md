# Finding 0051 Analysis

## Entries

### PRE-REARRANGE

**What happens:** REARRANGE (pivot/swap) does not validate whether the computed offsets would move content across subspace boundaries. The `rearrangend()` function in `edit.c:78-160` calls `makeoffsetsfor3or4cuts()` to compute displacement vectors from the cut points, then applies `tumbleradd` to shift each orgl's V-position by the computed offset. There is no check that the resulting V-position shares the same leading digit (subspace) as the original. With cuts at 1.1, 1.4, and 2.5, `diff[1] = 2.5 - 1.4 = 1.1`, so content at V:1.1–1.3 is displaced to V:2.2–2.4, crossing from text subspace (1.x) to link subspace (2.x).

**Why it matters for spec:** REARRANGE has a missing precondition: all cut points must lie within the same subspace, OR the resulting displacements must preserve subspace membership for every affected orgl. Formally: `requires ∀ orgl ∈ affected(cuts): subspace(vpos(orgl) + diff[section(orgl)]) == subspace(vpos(orgl))`. Without this, REARRANGE provides a second path (after INSERT, per finding 0049) to violate the content discipline. The spec's `pre(REARRANGE)` must include a subspace-preservation clause even though the implementation does not enforce it.

**Code references:**
- `backend/edit.c:78-160` — `rearrangend()` applies `tumbleradd` without subspace check
- `backend/edit.c:125` — `tumbleradd(&ptr->cdsp.dsas[index], &diff[i], &ptr->cdsp.dsas[index])` — the displacement add
- `backend/edit.c:164-183` — `makeoffsetsfor3or4cuts()` computes offsets purely from cut-point differences

**Concrete example:**
```
Pre-state:
  Document with text "ABC" at V:1.1–1.3 and "DEF" at V:1.5–1.7

REARRANGE pivot with cuts at [1.1, 1.4, 2.5]

Offset computation:
  diff[1] = 2.5 - 1.4 = 1.1   (section 1: content between cut[0] and cut[1])
  diff[2] = -(1.4 - 1.1) = -0.3  (section 2: content between cut[1] and cut[2])

Post-state:
  "ABC" (originally at V:1.1–1.3) now at V:2.2–2.4  ← crossed to link subspace
  "DEF" (at V:1.5–1.7) remains at V:1.5–1.7          ← outside cut range, unchanged
  vspanset: {at 0 for 0.2, at 1 for 1}
  retrieve at 2.x returns "ABC" — text bytes in link subspace
```

**Provenance:** Finding 0051

### ST-REARRANGE

**What happens:** When REARRANGE pivot is given cut points that span subspace boundaries, the displacement arithmetic works without error. The `tumbleradd` operation treats tumblers as pure arithmetic values — adding offset 1.1 to V-position 1.1 yields 2.2 regardless of subspace semantics. The rearrangement loop in `rearrangend()` iterates over all orgls in the affected range, classifies each into a cut section (1, 2, or 3) via `rearrangecutsectionnd()`, and applies the corresponding displacement. No section is skipped or rejected based on the resulting position.

**Why it matters for spec:** The state transition for REARRANGE must specify either (a) the postcondition `∀ orgl: subspace(vpos'(orgl)) == subspace(vpos(orgl))` as a maintained invariant, or (b) acknowledge that subspace can change and update the content discipline accordingly. Currently the implementation follows (b) silently — it permits cross-subspace movement. The formal spec must choose one and enforce it.

**Code references:**
- `backend/edit.c:78-160` — `rearrangend()` main loop applying displacements
- `backend/edit.c:164-183` — `makeoffsetsfor3or4cuts()` offset computation

**Concrete example:**
```
Pivot with cuts [1.1, 1.4, 2.5]:
  Section 1 (V:1.1 ≤ v < V:1.4): displaced by +1.1 → moved to 2.x
  Section 2 (V:1.4 ≤ v < V:2.5): displaced by -0.3 → stays in 1.x (or moves within)
  Section 3 (v ≥ 2.5): no displacement

Result: content crosses from subspace 1 to subspace 2
  No error returned, modification flagged via ivemodified()
```

**Provenance:** Finding 0051

### INV-SUBSPACE-CONVENTION

**What happens:** Finding 0051 demonstrates a second violation path for the subspace convention. While finding 0049 showed INSERT can place text at link-subspace positions, finding 0051 shows REARRANGE can *move* previously correctly-placed text into the wrong subspace. After a pivot with cross-subspace cuts, `retrieve_contents` at 2.x returns text bytes ("ABC") — identical behavior to a direct misplacement via INSERT. The back end draws no distinction between content that was placed at 2.x directly vs. content that was moved there by rearrangement.

**Why it matters for spec:** The subspace invariant `∀ v ∈ doc.vspan_set: type(content_at(v)) == TEXT ⟹ v.head == 1` can be violated by at least two operations: INSERT (finding 0049) and REARRANGE (this finding). For Dafny verification, the proof that this invariant is preserved must cover every V-position-mutating operation, not just content-placing ones. REARRANGE is particularly insidious because content may be correctly placed initially and only later displaced across the boundary. The preservation proof must show that the displacement arithmetic for every affected orgl stays within the original subspace.

**Code references:**
- `backend/edit.c:125` — `tumbleradd` displaces V-position without subspace guard
- `backend/do2.c:110-113` — `acceptablevsa()` (from finding 0049) — even if this were fixed, REARRANGE would bypass it since it modifies V-positions in-place rather than going through `acceptablevsa()`

**Concrete example:**
```
Initial state: "ABC" correctly at V:1.1–1.3 (text subspace) — invariant holds
After pivot [1.1, 1.4, 2.5]: "ABC" at V:2.2–2.4 (link subspace) — invariant violated

Two violation paths now known:
  1. INSERT at V:2.1 with text  (finding 0049) — direct misplacement
  2. REARRANGE pivot across subspace boundary (finding 0051) — displacement into wrong subspace
```

**Provenance:** Finding 0051, also Finding 0049
