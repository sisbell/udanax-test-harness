# Finding 0038 Analysis

## Entries

### SS-DUAL-ENFILADE

**What happens**: The POOM enfilade partitions V-space into three subspaces distinguished by the first mantissa digit: `1.x` for text, `2.x` for links, and `3.x` for link type endpoints. Internally, `setlinkvsas()` constructs link V-addresses by incrementing digit 0 to 2 (yielding `2.1`, `2.2`, etc.) and type endpoints by incrementing digit 0 to 3 (yielding `3.1`, etc.). However, the output representation differs from internal storage: `retrievedocvspanset` normalizes the link subspace to `0.x` when the document also contains text, but reports the actual `2.x` position when the document contains only links.

**Why it matters for spec**: The formal model must distinguish between internal V-addresses (always `2.x` for links) and the normalized output representation (sometimes `0.x`). Finding 0009 originally described the link subspace as `0.x`; this finding corrects that: `0.x` is an output convention of `retrievevspansetpm`, while `2.x` is the actual stored position. The spec should model internal state with `2.x` and treat normalization as a presentation function.

**Code references**:
- `do2.c:169-183` — `setlinkvsas()` constructs link endpoints at `2.1` and type at `3.1`
- `orglinks.c:173-221` — `retrievevspansetpm()` normalizes output: zeroes mantissa[1] for links, uses `maxtextwid()` for text

**Concrete example**:
```
Internal state after link creation:
  V-position 2.1 → link orgl ISA (stored internally)
  V-positions 1.1..1.10 → permascroll addresses (text)

retrievedocvspanset output (document has text + links):
  [{"start": "0", "width": "0.1"}, {"start": "1", "width": "1"}]
  Links normalized from 2.x → 0.x

retrievedocvspanset output (document has links only, no text):
  [{"start": "2.1", "width": "0.1"}]
  Links reported at actual internal position 2.x
```

**Provenance**: Finding 0038

### FC-SUBSPACE

**What happens**: Text insertions at V-positions `1.x` do not affect link positions at `2.x` (internally) or `0.x` (in output). This independence was verified through concrete scenarios: inserting 5 characters at V-position 1.5 in a document with a link changed the text vspan width but left the link span unchanged. Multiple rounds of text insertion and link creation were tested — link spans remained stable throughout. The `insertpm()` function operates only on crums in the target V-range, so inserting at `1.x` structurally cannot reach `2.x` crums in the enfilade tree.

**Why it matters for spec**: This strengthens the frame condition from finding 0009 with concrete verified examples. The frame condition is not just a design intent but a structural property of the tree: text crums and link crums occupy disjoint branches. For Dafny verification, this can be stated as: for all operations `op` on subspace `s`, the projection of the document state onto subspace `s' != s` is unchanged.

**Code references**:
- `insertpm()` — operates only on crums matching the target V-range
- `orglinks.c:173-221` — `retrievevspansetpm()` extracts subspaces independently

**Concrete example**:
```
Pre-state:
  Text at 1.1..1.10 ("HelloWorld"), link at 0.x
  Vspanset: [{"start": "0", "width": "0.1"}, {"start": "1", "width": "1"}]

doinsert("XXXXX", at V-position 1.5)

Post-state:
  Text at 1.1..1.15 ("HellXXXXXoWorld")
  Vspanset: [{"start": "0", "width": "0.10"}, {"start": "1", "width": "1"}]
  Link span UNCHANGED — still "0" with width "0.10"
```

**Provenance**: Finding 0038

### INV-SUBSPACE-CONVENTION

**What happens**: The three-subspace convention uses mantissa[0] to encode content type: `1` = text, `2` = link, `3` = link type endpoint. This is constructed in `setlinkvsas()` which hardcodes digit-0 values of 1, 2, and 3 for the FROM, TO, and THREE endpoints respectively. The convention extends beyond the two-subspace model (text vs. links) documented in finding 0009 to include a third subspace for type endpoints. Each subspace maintains its own contiguous numbering independently (links at 2.1, 2.2, ...; text at 1.1, 1.2, ...).

**Why it matters for spec**: The formal model of V-address space needs three partitions, not two. The invariant is: `mantissa[0] in {1, 2, 3}` for all valid V-addresses, with each value mapping to a distinct content type. Contiguity within each subspace is maintained independently — inserting at 1.5 shifts 1.6+ but does not affect 2.x numbering.

**Code references**:
- `do2.c:169-183` — `setlinkvsas()` constructs all three subspace positions

**Provenance**: Finding 0038

### EC-VSPAN-NORMALIZATION

**What happens**: `retrievedocvspanset` output representation depends on document content: when both text and links exist, links are reported with normalized start `"0"` and text with start `"1"`; when only links exist (no text), links are reported at their actual internal V-position `"2.1"`. This means the same link at internal V-position `2.1` appears as either `"0"` or `"2.1"` in query output depending on whether the document has text content. The normalization is performed by `retrievevspansetpm()` which zeroes mantissa[1] for the link span and uses `maxtextwid()` to compute the text span.

**Why it matters for spec**: Any spec of vspanset retrieval must model this context-dependent normalization as a distinct presentation function. Callers must handle both representations. This creates a potential source of confusion where `"0"` and `"2.1"` both refer to the link subspace — the spec should define a canonical form and document the normalization rule.

**Code references**:
- `orglinks.c:173-221` — `retrievevspansetpm()` normalization logic

**Concrete example**:
```
Document with text + 1 link:
  Output: [{"start": "0", "width": "0.1"}, {"start": "1", "width": "1"}]

Same document after deleting all text:
  Output: [{"start": "2.1", "width": "0.1"}]
```

**Provenance**: Finding 0038
