# Finding 0009 Analysis

## Entries

### SS-DUAL-ENFILADE

**What happens**: A document's virtual address space is partitioned into two subspaces distinguished by the first tumbler digit. V-position `0.x` is the **link subspace** (stores references to link orgls). V-position `1.x` is the **text subspace** (stores actual document content mapped to permascroll I-addresses). The enfilade itself is uniform — it stores V-to-I mappings without type metadata. The subspace identity is encoded purely by V-position convention.

**Why it matters for spec**: This is the fundamental state structure that all document operations act on. A document is not simply a sequence of characters; it is a two-subspace mapping. Any specification of document state must model these subspaces explicitly. The type of the I-address (permascroll address vs. link orgl ISA) is determined by which V-subspace it falls in — this is an implicit invariant that the storage layer does not enforce.

**Code references**:
- `do2.c:151-167` — `findnextlinkvsa()` constructs first link position at `0.1`
- `do1.c:199-225` — `docreatelink()` stores link references via `docopy()` into `0.x`

**Concrete example**:

Before link creation:
```
Document vspanset: <VSpec in 1.1.0.1.0.1, at 1.1 for 0.16>
  V-range 1.1..1.16 → permascroll I-addresses (text content only)
```

After link creation:
```
Document vspanset: <VSpec in 1.1.0.1.0.1, at 0 for 0.1, at 1 for 1>
  V-range 0.x → link orgl ISA (link reference)
  V-range 1.x → permascroll I-addresses (text content)
```

**Provenance**: Finding 0009

### SS-CONTENT-IDENTITY

**What happens**: There are two fundamentally different types of I-addresses in the system. **Permascroll I-addresses** (e.g., `2.1.0.5.0.123`) dereference to character bytes in the global immutable permascroll and represent content identity — two documents sharing the same permascroll I-address share the same content. **Link orgl ISAs** (e.g., `1.1.0.1.0.2`) dereference to link orgl structures and represent object identity — they are unique references, not shareable content.

**Why it matters for spec**: The I-address space must be modeled with at least two sorts (permascroll addresses and document ISAs). Operations like `compare_versions` that compute I-span intersections are only meaningful over permascroll addresses. A formal spec must capture that I-address comparability is type-dependent.

**Code references**:
- `orglinks.c:389-422` — `permute()` generalizes V↔I conversion without type distinction
- `retrie.c:56-85` — `retrieverestricted()` looks up content by address range, type-agnostic

**Provenance**: Finding 0009

### INV-SUBSPACE-CONVENTION

**What happens**: The system enforces by convention (not by runtime check) that V-positions `0.x` contain only link orgl ISAs as I-addresses, and V-positions `1.x` contain only permascroll I-addresses. No code in the enfilade storage path validates this invariant — it is maintained by callers (`docreatelink` writes to `0.x`, `doinsert`/`docopy` for text writes to `1.x`). The `permute()`, `retrieverestricted()`, and `docopy()` functions are all type-agnostic.

**Why it matters for spec**: This is a convention-over-enforcement invariant. The spec should state it as a property that holds across all well-formed operations, but note that the storage layer does not enforce it. This is the kind of invariant that Dafny can verify as a postcondition of each operation rather than as a storage-layer check.

**Code references**:
- `do1.c:215-216` — `findnextlinkvsa` + `docopy` for link storage (caller ensures `0.x`)
- `do2.c:151-167` — `findnextlinkvsa` hardcodes first link at `0.1`

**Provenance**: Finding 0009

### ST-INSERT

**What happens**: When a link is created via `docreatelink`, the operation: (1) creates a new link orgl via `createorglingranf()`, yielding a fresh ISA; (2) converts that ISA to an ispanset via `tumbler2spanset()`; (3) finds the next available V-position in the `0.x` subspace via `findnextlinkvsa()`; (4) copies the link's ISA into the document at that position via `docopy()`. This means link creation is a state transition that modifies **both** the link orgl space (new orgl) and the document's V-space (new entry in `0.x` subspace).

**Why it matters for spec**: Link creation is a compound state transition — it creates a new object AND modifies an existing document. The postcondition must specify both effects. Notably, `docopy()` is the same function used for text transclusion, so the spec for `docopy` must be parameterized over both text and link-reference use cases.

**Code references**:
- `do1.c:199-225` — `docreatelink()` full sequence
- `do2.c:48-61` — `tumbler2spanset()` ISA-to-ispan conversion
- `do2.c:151-167` — `findnextlinkvsa()` next available link position

**Concrete example**:
```
Pre-state:
  Document 1.1.0.1.0.1 has text at V-positions 1.1..1.16
  No links exist

docreatelink(doc=1.1.0.1.0.1, ...)

Post-state:
  New link orgl created at ISA 1.1.0.1.0.2
  Document 1.1.0.1.0.1 now has:
    V-position 0.1 → I-address 1.1.0.1.0.2 (link reference)
    V-positions 1.x → permascroll I-addresses (text, unchanged)
```

**Provenance**: Finding 0009

### EC-COMPARE-VERSIONS-LINK-CRASH

**What happens**: The `compare_versions` operation assumes a uniform content model: convert V-spans to I-spans for both documents, intersect I-spans to find shared content, map back to V-spans. When the document contains links, the `0.x` V-subspace produces link orgl ISAs as I-addresses. These are in a completely different address space from permascroll I-addresses and will never intersect with text I-addresses. The code paths in `correspond.c` do not handle the case where some V-spans produce no common I-spans, leading to crashes. The nested loop structure in `correspond.c` assumes each ispan matches at most one vspec, which the link subspace violates.

**Why it matters for spec**: This is a precondition violation — `compare_versions` requires that its input V-spans come only from the text subspace (`1.x`). Alternatively, the spec could require `compare_versions` to filter to text subspace before comparison. Either way, the formal spec must make explicit that I-span intersection is only meaningful within the same I-address type.

**Code references**:
- `correspond.c` — nested loop assumes 1:1 ispan-to-vspec correspondence
- `orglinks.c:404-422` — `permute()` performs type-agnostic conversion

**Concrete example**:
```
Document A vspanset after link: at 0 for 0.1, at 1 for 1
Document B vspanset (text only): at 1.1 for 0.16

compare_versions(A, B):
  A's 0.x → I-addresses are link ISAs (e.g., 1.1.0.1.0.2)
  B's 1.x → I-addresses are permascroll (e.g., 2.1.0.5.0.1)
  Intersection of link ISAs ∩ permascroll = empty
  → correspond.c loop encounters empty match → crash
```

**Provenance**: Finding 0009, Bug 0009

### PRE-COMPARE-VERSIONS

**What happens**: For `compare_versions` to operate correctly, the input V-span sets must be restricted to the text subspace (`V >= 1.0`). The operation's logic — I-span intersection to find shared content — is only semantically valid for permascroll I-addresses. Including the link subspace (`V < 1.0`) introduces link orgl ISAs that are identity-bearing (unique, non-comparable) rather than content-bearing (shared via transclusion).

**Why it matters for spec**: This is a missing precondition. The implementation does not validate that input V-spans exclude the link subspace. A formal spec should either: (a) state `compare_versions` requires text-subspace-only input, or (b) specify that the implementation filters to text subspace as its first step.

**Code references**:
- `correspond.c` — no filtering of V-spans before I-span conversion

**Provenance**: Finding 0009

### FC-SUBSPACE

**What happens**: The link subspace (`0.x`) and text subspace (`1.x`) are independent partitions of the document's V-space. Operations on one subspace should not affect the other. Evidence: after link creation, text content at `1.x` is preserved while a new entry appears at `0.x`. The `findnextlinkvsa()` function only considers positions in the `0.x` range, and text insertion only considers positions in the `1.x` range.

**Why it matters for spec**: This is a frame condition — link creation does not modify text content, and text insertion does not modify link references. The spec should state that operations on one subspace preserve the other subspace unchanged.

**Code references**:
- `do2.c:151-167` — `findnextlinkvsa()` scoped to `0.x`
- `do1.c:199-225` — `docreatelink()` writes only to `0.x`

**Concrete example**:
```
Before: V-range 1.1..1.16 → permascroll addresses (text)
After docreatelink:
  V-range 0.1 → link ISA (new)
  V-range 1.x → permascroll addresses (unchanged)
```

**Provenance**: Finding 0009
