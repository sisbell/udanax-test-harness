# Finding 0075 Analysis

## Entries

### PRE-DELETE

**What happens:** The DELETE Phase 1 cutting mechanism (`slicecbcpm`) has an enforced precondition: it is only invoked when the cut point falls strictly in the interior of a bottom crum. The `makecutsbackuptohere()` function in `ndcuts.c:77-90` checks `whereoncrum() == THRUME` before calling `slicecbcpm`. The `whereoncrum()` function (`retrie.c:345-372`) classifies cut positions into five categories: `TOMYLEFT` (-2), `ONMYLEFTBORDER` (-1), `THRUME` (0), `ONMYRIGHTBORDER` (1), `TOMYRIGHT` (2). Only `THRUME` — meaning `grasp < cut < reach` with both strict inequalities — triggers a call to `slicecbcpm`.

When a DELETE boundary aligns exactly with a crum's grasp, `whereoncrum` returns `ONMYLEFTBORDER`; when it aligns with a crum's reach, it returns `ONMYRIGHTBORDER`. In both cases, `slicecbcpm` is skipped. The crum is instead handled whole in Phase 2 (classify and remove/shift).

**Why it matters for spec:** This establishes a precondition on the `slicecbcpm` operation: `pre_slicecbcpm(cut, crum) ≡ crum.grasp < cut < crum.reach`. The precondition is enforced by the caller (`makecutsbackuptohere`), not by `slicecbcpm` itself. For a formal DELETE model, the cutting step can be specified as: `∀ blade ∈ knives, ∀ crum ∈ bottom_crums : whereoncrum(blade, crum) = THRUME ⟹ split(crum, blade)`. Boundary-aligned blades do not trigger splits.

**Code references:**
- `ndcuts.c:77-90` — `makecutsbackuptohere()`: guard `whereoncrum() == THRUME` before `slicecbcpm`
- `retrie.c:345-372` — `whereoncrum()`: five-valued classification of cut position relative to crum
- `common.h:86-90` — Constants: `TOMYLEFT=-2, ONMYLEFTBORDER=-1, THRUME=0, ONMYRIGHTBORDER=1, TOMYRIGHT=2`

**Concrete example:**
```
Crum: [1.1, 1.4)  (grasp=1.1, reach=1.4, content="ABC")

DELETE [1.1, 1.4):   (exact alignment on both sides)
  whereoncrum(1.1, crum) → ONMYLEFTBORDER  → no cut
  whereoncrum(1.4, crum) → ONMYRIGHTBORDER → no cut
  slicecbcpm NOT called; crum handled whole in Phase 2

DELETE [1.1, 1.3):   (start aligned, end interior)
  whereoncrum(1.1, crum) → ONMYLEFTBORDER  → no cut
  whereoncrum(1.3, crum) → THRUME          → slicecbcpm called
  localcut = 1.3 - 1.1 = 0.2 (strictly positive, strictly < cwid 0.3)

DELETE [1.2, 1.4):   (start interior, end aligned)
  whereoncrum(1.2, crum) → THRUME          → slicecbcpm called
  whereoncrum(1.4, crum) → ONMYRIGHTBORDER → no cut
  localcut = 1.2 - 1.1 = 0.1 (strictly positive, strictly < cwid 0.3)
```

**Provenance:** Finding 0075

### INV-NO-ZERO-WIDTH-CRUM

**What happens:** The DELETE Phase 1 cutting mechanism cannot produce zero-width bottom crums. Because `slicecbcpm` is only called when the cut is strictly interior to a crum (`grasp < cut < reach`), the local cut offset satisfies `0 < localcut.mantissa[0] < cwid.mantissa[0]` — both strict inequalities. When `slicecbcpm` splits a crum at `ndcuts.c:396-444`, it creates two pieces: the original crum retains width `localcut` (positive) and the new crum receives width `cwid - localcut` (also positive, via `locksubtract` at `ndcuts.c:444`). Both resulting crums have strictly positive width.

This invariant is enforced structurally by the `whereoncrum` guard, not by explicit assertions in `slicecbcpm`. However, assertions at `ndcuts.c:398` and `ndcuts.c:410` would fail if a zero-width cut were somehow passed in.

**Why it matters for spec:** This is a structural invariant of the enfilade after any DELETE Phase 1: `∀ crum ∈ bottom_crums(enf) : crum.width > 0`. No cutting operation can produce a degenerate zero-width crum. This invariant supports leaf linearity enforcement (DN-0011) and can be assumed in all postconditions for DELETE. For bounded model checking, the width of every bottom crum is in `{w : Tumbler | w > 0}` after any sequence of operations.

**Code references:**
- `ndcuts.c:396` — `tumblersub(cut, &grasp, &localcut)`: computes local offset, guaranteed positive
- `ndcuts.c:444` — `locksubtract`: computes remaining width, guaranteed positive
- `ndcuts.c:398, 410` — assertions that would catch zero-width violations
- `retrie.c:345-372` — `whereoncrum()`: structural guard ensuring strict interiority

**Concrete example:**
```
Crum: grasp=1.1, cwid=0.6  (reach=1.7)
Cut at 1.4 (interior, THRUME):
  localcut = 1.4 - 1.1 = 0.3
  Original crum: width = 0.3  (> 0 ✓)
  New crum:      width = 0.6 - 0.3 = 0.3  (> 0 ✓)

Cross-crum DELETE [1.2, 1.6) across two crums:
  Crum1 [1.1, 1.4): cut at 1.2 → localcut=0.1, remaining=0.2  (both > 0 ✓)
  Crum2 [1.4, 1.7): cut at 1.6 → localcut=0.2, remaining=0.1  (both > 0 ✓)
```

**Provenance:** Finding 0075

### ST-DELETE

**What happens:** When DELETE boundaries align exactly with existing bottom crum boundaries, the cutting phase (Phase 1) is bypassed entirely for those boundaries. The crum is instead processed whole in Phase 2, where it is classified and either removed entirely (Case 1: crum falls within the deletion range) or left intact (Case 0: crum is outside the deletion range). This is an optimization: boundary-aligned deletions require no splitting, only classification.

For a deletion that spans exactly one crum from grasp to reach, neither boundary triggers `slicecbcpm`. The crum is classified as type 1 (fully within deletion range) and removed as a unit. No new crums are created.

**Why it matters for spec:** The DELETE state transition has two sub-paths depending on boundary alignment. For a formal model: `delete(doc, start, end)` produces cutting only at boundaries where `∃ crum : crum.grasp < boundary < crum.reach`. At boundaries coinciding with crum edges, no structural modification occurs in Phase 1 — the tree topology is unchanged until Phase 2 classification. This simplifies reasoning about DELETE: boundary-aligned deletions can be modeled as pure removal without intermediate split states.

**Code references:**
- `ndcuts.c:77-90` — `makecutsbackuptohere()`: only calls `slicecbcpm` for `THRUME`
- `edit.c:31-76` — `deletend()`: Phase 2 classification after Phase 1 cutting

**Provenance:** Finding 0075
