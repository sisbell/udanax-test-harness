# Finding 0047 Analysis

## Entries

### SS-DOCISPAN

**What happens:** DOCISPAN entries in the spanfilade have per-span granularity, not per-byte. When `insertspanf` is called, it iterates over the `ispanset` linked list and makes one `insertnd` call per `typeispan` struct. Each `typeispan` represents a contiguous range of I-addresses (with a `stream` start and `width` size), so inserting 10 contiguous bytes creates 1 DOCISPAN entry, not 10. The granularity is determined by how `vspanset2ispanset` consolidates V-spans into I-spans before they reach `insertspanf`.

**Why it matters for spec:** The DOCISPAN sub-index should be modeled as `Map<ISpan, DocISA>` where `ISpan = (start: IAddress, width: Nat)`, not as `Map<IAddress, DocISA>` with per-byte entries. This affects the storage complexity model: the number of DOCISPAN entries is proportional to the number of distinct content placements (INSERT/COPY operations), not total byte count. Formally: `|DOCISPAN_entries(doc)| = O(num_operations)`, not `O(total_bytes)`.

**Code references:**
- `spanf1.c:15-53` — `insertspanf` loops over `ispanset`, one `insertnd` call per `typeispan`
- `xanadu.h:65-76` — `typeispan` struct: `stream` (start I-address) + `width` (contiguous byte count)

**Concrete example:**
```
INSERT "ABCDEFGHIJ" (10 bytes) into document D:
  inserttextingranf → allocates I-addresses α₁..α₁₀ as one contiguous range
  docopy → specset2ispanset returns 1 I-span: {stream: α₁, width: 10}
  insertspanf → 1 insertnd call → 1 DOCISPAN entry: (α₁, width 10) → D

NOT:
  10 insertnd calls → 10 DOCISPAN entries: α₁→D, α₂→D, ..., α₁₀→D
```

**Provenance:** Finding 0047

### ST-INSERT

**What happens:** INSERT of k contiguous bytes creates exactly 1 DOCISPAN entry in the spanfilade. The call chain `doinsert` → `inserttextingranf` → `docopy` → `insertspanf(..., DOCISPAN)` passes a single I-span (the freshly allocated contiguous I-address range) to `insertspanf`, which makes 1 `insertnd` call. Combined with Finding 0033 (sequential single-character inserts get contiguous I-addresses that consolidate), even k sequential single-character inserts produce a single I-span when later queried, because the I-addresses are contiguous.

**Why it matters for spec:** Refines the INSERT postcondition's effect on spanf. For a single INSERT of k bytes: `|new_DOCISPAN_entries| = 1`. For k sequential single-character inserts: the individual operations each create 1 DOCISPAN entry, but the entries are on contiguous I-address ranges. The storage cost of INSERT is O(1) per operation with respect to DOCISPAN, regardless of byte count.

**Code references:**
- `do1.c:91-127` — `doinsert()` → `inserttextingranf` returns one contiguous ispanset → `docopy`
- `do1.c:45-65` — `docopy()` → `insertspanf(taskptr, spanf, docisaptr, ispanset, DOCISPAN)`
- `spanf1.c:48` — `insertnd(taskptr, spanfptr, &crumorigin, &crumwidth, &linfo, SPANRANGE)` — one call per I-span

**Provenance:** Finding 0047

### ST-COPY

**What happens:** COPY creates DOCISPAN entries proportional to the number of contiguous I-spans in the source content, not the number of bytes. COPY of contiguous source content (1 I-span) creates 1 DOCISPAN entry. COPY of fragmented source content (e.g., 3 non-contiguous regions) creates 3 DOCISPAN entries. The `specset2ispanset` conversion determines how many I-spans the source content maps to, and `insertspanf` makes one `insertnd` call per I-span.

**Why it matters for spec:** COPY postcondition for DOCISPAN: `|new_DOCISPAN_entries| = |ispanset(source_content)|`. The number of new index entries depends on the I-space fragmentation of the copied content, not its V-space extent. This means copying heavily-edited content (many small I-spans) is more expensive in spanfilade entries than copying pristine content (one large I-span).

**Concrete example:**
```
COPY of contiguous content (1 I-span in source):
  insertspanf receives 1 I-span → 1 insertnd → 1 DOCISPAN entry

COPY of fragmented content (3 I-spans in source):
  insertspanf receives 3 I-spans → 3 insertnd calls → 3 DOCISPAN entries
```

**Code references:**
- `do1.c:45-65` — `docopy()` calls `specset2ispanset` then `insertspanf`
- `spanf1.c:38-48` — loop in `insertspanf`: `for (; sporglset; sporglset = next) { ... insertnd(...); }`

**Provenance:** Finding 0047

### INV-SPANF-GROWTH

**What happens:** The spanfilade (DOCISPAN portion) grows with the number of distinct content placements, not total byte count. The storage model is `S(t) = Σ |ispanset placed into doc d|` across all INSERT and COPY operations up to time t. This is because each operation creates entries proportional to the number of I-spans, not the number of bytes per I-span.

**Why it matters for spec:** This is a complexity invariant on the spanfilade data structure. It bounds the growth rate: `|DOCISPAN| ≤ Σ_{all INSERT/COPY ops} |ispanset(op)|`. For a system with N insert/copy operations each on contiguous content, `|DOCISPAN| ≤ N`. This rules out pathological O(total_bytes) growth and means the spanfilade size tracks editorial activity, not content volume.

**Code references:**
- `spanf1.c:38-48` — one `insertnd` per I-span, not per byte
- Finding references EWD-031 (The Storage Problem) as confirming this storage model

**Provenance:** Finding 0047
