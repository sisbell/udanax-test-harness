# Finding 0040 Analysis

## Entries

### SS-THREE-LAYER-MODEL

**What happens:** Links exist across three independent storage layers with distinct persistence and mutability characteristics:

1. **I-space (link orgl):** The link object at a permanent I-address (e.g., `1.1.0.1.0.1.0.2.1`). Contains the link's endset references (FROM, TO, TYPE). Cannot be deleted (permanence axiom P0).
2. **Spanfilade (DOCISPAN entries):** Type 4 enfilade entries mapping I-addresses to documents. Enables `find_links()` and `finddocscontaining()` queries. Append-only (monotonicity P0').
3. **POOM (document V-stream):** V-position 2.x entries in the document's orgl enfilade. Determines whether the link "appears" in the document's visible structure. Mutable via DELETEVSPAN.

`CREATELINK` writes to all three layers. `DELETEVSPAN(2.x)` removes only the POOM entry. No operation removes from I-space or spanfilade.

**Why it matters for spec:** The formal state model must represent links as distributed across three layers: `State = (ispace, pooms, spanfilade)`. Each layer has a distinct persistence property. The key formalization is that link "existence" (I-space), link "discoverability" (spanfilade), and link "containment in document" (POOM) are three independent predicates. A link can be discoverable and followable even when removed from its home document's POOM.

**Code references:**
- `orglinks.c:145-152` — `deletevspanpm()` operates only on the document's orgl enfilade (POOM layer)
- `edit.c:31-76` — `deletend()` removes crums in V-dimension without affecting I-space or spanfilade

**Concrete example:**
```
Before DELETEVSPAN(2.1):
  I-space:     link orgl at 1.1.0.1.0.1.0.2.1 (permanent)
  Spanfilade:  DOCISPAN entry mapping link to doc (append-only)
  POOM:        V-position 2.1 → link orgl (present)
  vspanset:    [{"start": "0", "width": "0.1"}, {"start": "1", "width": "1"}]

After DELETEVSPAN(2.1):
  I-space:     link orgl at 1.1.0.1.0.1.0.2.1 (unchanged)
  Spanfilade:  DOCISPAN entry still present (unchanged)
  POOM:        V-position 2.1 removed
  vspanset:    [{"start": "1.1", "width": "0.11"}]
  find_links(source_specs) → still finds the link
  follow_link(link_id, SOURCE) → still works
```

**Provenance:** Finding 0040, Semantic Model and Architectural Implications sections.

### ST-DELETE

**What happens:** `DELETEVSPAN` targeting the link subspace (V-position 2.x) removes the link's V-to-I mapping from the document's POOM. The operation succeeds when the width is non-zero. After deletion, the document's vspanset no longer includes the link span. The `deletevspanpm()` function calls `deletend()` on the document's orgl enfilade in the V-dimension, then logs the document as modified.

This extends the known DELETE behavior: just as deleting text at 1.x removes text from the V-stream but preserves I-space content, deleting links at 2.x removes the link's POOM presence but preserves the link orgl in I-space and DOCISPAN entries in the spanfilade.

**Why it matters for spec:** The postcondition for DELETE must cover all subspaces uniformly. For any subspace `s` and V-range `r`: `delete(D, s, r) ⟹ vspanset(D)_after ∩ (s, r) = ∅`. The frame conditions differ by what persists: text deletion preserves I-space content bytes; link deletion preserves I-space link orgl AND spanfilade entries. Formally: `delete(D, 2.x, r) ⟹ link_orgl(link) unchanged ∧ spanfilade_entries(link) unchanged`.

**Code references:**
- `orglinks.c:145-152` — `deletevspanpm()` checks for zero-width, calls `deletend()`, logs modification
- `edit.c:31-76` — `deletend()` removes crums covering the specified V-range

**Concrete example:**
```
Pre-state:
  doc vspanset: [{"start": "0", "width": "0.1"}, {"start": "1", "width": "1"}]

Operation: session.delete(doc, Address(2, 1), Offset(0, 1))
Result: SUCCESS

Post-state:
  doc vspanset: [{"start": "1.1", "width": "0.11"}]
  Link subspace gone from vspanset; text subspace unchanged.
```

**Provenance:** Finding 0040, Test Results and Code Evidence sections.

### INV-LINK-PERMANENCE

**What happens:** Removing a link from a document's POOM via `DELETEVSPAN(2.x)` does NOT delete the link object. The link orgl persists at its I-address, remains discoverable via `find_links()` (because spanfilade DOCISPAN entries persist), and remains followable via `follow_link(link_id)` (because the link orgl is directly accessible by I-address). The permanence invariant holds at the I-space and spanfilade levels even though the POOM association is severed.

This qualifies the permanence invariant: link permanence means permanent existence and discoverability, not permanent association with a particular document's V-stream. A front end CAN call `DELETEVSPAN` to remove a link from a document — the backend does not prevent this — but the link itself survives.

**Why it matters for spec:** Refines the permanence invariant to distinguish layers: `∀ link ∈ created_links : link ∈ ispace(system) ∧ link ∈ spanfilade(system)` holds unconditionally across all operations. But `link ∈ poom(doc)` is mutable — DELETEVSPAN can remove it. The invariant `once_created(link) ⟹ link ∈ links(system_future)` holds for I-space and spanfilade but NOT for POOM containment.

**Code references:**
- Test `find_links_after` — confirms link discovery survives POOM removal
- Test `follow_link_after` — confirms direct access survives POOM removal

**Provenance:** Finding 0040, Link Persistence section and Architectural Implications section 1.

### PRE-DELETE

**What happens:** `DELETEVSPAN` accepts link subspace addresses (V-position 2.x) as valid targets. The only precondition enforced by `deletevspanpm()` is that the width is non-zero — `iszerotumbler(&vspanptr->width)` returns FALSE. There is no check preventing deletion of the link subspace. The backend treats link positions identically to text positions for deletion purposes.

This means link "permanence" within a document's POOM is a front-end convention, not a backend enforcement. The backend will execute `DELETEVSPAN(2.1)` just as readily as `DELETEVSPAN(1.5)`.

**Why it matters for spec:** The precondition for DELETE does not distinguish subspaces: `pre_delete(D, addr, width) ≡ width ≠ 0`. There is no predicate `addr.subspace ≠ LINK_SUBSPACE` guarding the operation. If the spec wants to preserve link-in-POOM permanence, it must be modeled as a front-end-enforced policy, not a backend invariant.

**Code references:**
- `orglinks.c:145-152` — `deletevspanpm()` only checks for zero-width, no subspace guard

**Provenance:** Finding 0040, Code Evidence section and EWD Specifications section.

### FC-LINK-DELETE-ISOLATION

**What happens:** `DELETEVSPAN(2.x)` on a document's link subspace affects ONLY the POOM layer. It does not modify the link orgl in I-space, the DOCISPAN entries in the spanfilade, or the link's endset references. After removing a link from a document's POOM:
- `find_links()` searching by source content still finds the link (spanfilade intact)
- `follow_link(link_id, LINK_SOURCE)` returns the correct source endpoint (link orgl intact)
- Direct link ID access bypasses POOM entirely

This is the converse of the text-delete frame condition: where text deletion preserves link objects in the 0.2.x subspace (Finding 0024), link-subspace deletion preserves link objects in I-space and spanfilade.

**Why it matters for spec:** Frame condition: `delete(D, 2.x, r) ⟹ ispace' = ispace ∧ spanfilade' = spanfilade`. The POOM is the only mutable layer for links. This is the critical frame condition distinguishing POOM removal from link destruction — the two are not equivalent.

**Code references:**
- `edit.c:31-76` — `deletend()` operates on the document's orgl only; no code path touches the link orgl or spanfilade entries

**Concrete example:**
```
After DELETEVSPAN(2.1) on document:
  find_links(source_specs) → [link_id]    (spanfilade intact)
  follow_link(link_id, LINK_SOURCE) → works  (link orgl intact)
  retrieve_vspanset(doc) → no link span     (POOM entry removed)
```

**Provenance:** Finding 0040, Link Persistence section and Comparison with Text Deletion.

### EC-REVERSE-ORPHAN

**What happens:** Removing a link from POOM via DELETEVSPAN creates a state that is the mirror image of an orphaned link (Finding 0024). In a standard orphan, the link exists in the POOM but its endpoints resolve to empty content. In a "reverse orphan," the link does NOT exist in the POOM but is fully intact — link orgl exists, endsets resolve correctly, and discovery via `find_links` works.

| Scenario | POOM | Link orgl | Endpoints | Discovery |
|----------|------|-----------|-----------|-----------|
| Normal link | Present | Exists | Resolve | Works |
| Orphaned link (0024) | Present | Exists | Empty | Fails (content gone) |
| Reverse orphan (0040) | Absent | Exists | Resolve | Works (spanfilade intact) |

**Why it matters for spec:** The spec must account for this asymmetric state. A link can be discoverable without being "contained" in any document's POOM. The predicate `link_in_poom(link, doc)` is independent of `link_discoverable(link)` and `link_followable(link)`. This also means the set of links visible via `retrieve_vspanset(doc)` can be a strict subset of the set of links discoverable via `find_links(doc_content)`.

**Concrete example:**
```
Orphaned link (Finding 0024):
  retrieve_vspanset(doc) → shows link at 2.1
  follow_link(link_id, SOURCE) → empty
  find_links(source_specs) → []

Reverse orphan (Finding 0040):
  retrieve_vspanset(doc) → no link span
  follow_link(link_id, SOURCE) → works, returns content
  find_links(source_specs) → [link_id]
```

**Provenance:** Finding 0040, Discovery vs Direct Access Asymmetry and Comparison with Finding 0024.
