# Finding 0067 Analysis

## Entries

### FC-DOC-ISOLATION

**What happens:** Document operations (INSERT, DELETE, COPY) have no cross-document side effects. Each document's orgl is an independent enfilade tree stored in granf. All mutation functions (`insertnd`, `deletend`, `rearrangend`) receive `typecuc *fullcrumptr` — a pointer to the target document's orgl root crum — and all tree traversal uses local pointers (`findleftson`, `findrightbro`, `findfather`). No code path in any mutation function accesses another document's orgl. This was confirmed both by code inspection and by 6 empirical test scenarios covering INSERT, DELETE, and COPY across multiple documents with transclusions.

COPY (`docopy`) reads the source document's I-addresses via `specset2ispanset` (a read-only operation) and writes only to the target document's orgl via `insertpm`. The source document's orgl is never modified.

**Why it matters for spec:** This is the central frame axiom F0: `∀d ∈ D, ∀op ∈ {INSERT, DELETE, COPY}, ∀d' ∈ D where d ≠ d': op(d, ...) ⟹ D_seq'(d') = D_seq(d')`. The implementation guarantees this structurally — cross-document mutation is physically impossible because mutation functions only receive and traverse a single orgl tree. For Dafny verification, this can be expressed as: `forall d' :: d' != d ==> poom(d') == old(poom(d'))` as a postcondition on all document operations. No global mutable state is shared between documents (crum allocation is append-only and semantics-free).

**Code references:**
- `insertnd.c:15-111` — `insertnd` takes single `fullcrumptr`, all mutations local to that tree
- `edit.c:30-75` — `deletend` takes single `fullcrumptr`, traversal via `findleftson`/`findrightbro`
- `do1.c:45-65` — `docopy` reads source (via `specset2ispanset`), writes target only (via `insertpm` + `insertspanf`)
- `orglinks.c:144-151` — `deletevspanpm` calls `deletend` on single orgl, no spanf call

**Concrete example:**
```
Pre-state:
  Doc A: text "Hello" at 1.1-1.5
  Doc B: text "World" at 1.1-1.5

Operation: INSERT "XYZ" into Doc A at 1.3

Post-state:
  Doc A: text "HeXYZllo" at 1.1-1.8 (modified)
  Doc B: text "World" at 1.1-1.5 (UNCHANGED — identical content and vspanset)

Operation: COPY from Doc A to Doc C
Post-state:
  Doc A: UNCHANGED (read-only access to source)
  Doc C: contains transcluded content from A
```

**Provenance:** Finding 0067

### FC-SUBSPACE

**What happens:** Finding 0067 synthesizes the subspace isolation evidence from Findings 0054 and 0055, confirming that operations within the text subspace (1.x) do not affect the link subspace (2.x) within the same document. Two distinct mechanisms enforce this:

1. **INSERT** uses a deliberate two-blade knife with `blade[1]` at the next subspace boundary (`findaddressofsecondcutforinsert` computes `(N+1).1`). Crums at or beyond this boundary are classified as case 2 (no shift).

2. **DELETE** relies on an incidental arithmetic guard: `strongsub`'s exponent check returns the minuend unchanged when `width.exp < entry.vpos.exp`, which holds for cross-subspace entries.

Empirical tests confirm: after INSERT at 1.x, links at 2.1 remain discoverable via FIND_LINKS and FOLLOW_LINK. After DELETE at 1.x (including deletion of all text), links at 2.1 remain at their original V-position.

**Why it matters for spec:** Strengthens the frame condition to cover intra-document subspace isolation: `∀ op on subspace s, ∀ entry ∈ poom(doc) : entry.vpos.mantissa[0] ≠ s ⟹ entry.vpos' = entry.vpos`. This is enforced by two different mechanisms (structural for INSERT, arithmetic for DELETE), requiring different proof strategies in formal verification.

**Code references:**
- `insertnd.c:144-146` — two-blade knife construction for INSERT
- `insertnd.c:174-183` — `findaddressofsecondcutforinsert` computes subspace boundary
- `tumble.c:534-547` — `strongsub` exponent guard protects DELETE
- `edit.c:207-233` — `insertcutsectionnd` three-case classification

**Provenance:** Finding 0067 (synthesizing Findings 0054, 0055)

### INV-SPANF-WRITE-ONLY

**What happens:** Finding 0067 confirms that neither `insertnd` nor `deletend` calls any spanfilade update function. The DELETE path (`dodeletevspan` → `deletevspanpm` → `deletend`) modifies only the document's POOM in granf. No `deletespanf` function exists. Stale spanfilade entries accumulate after DELETE but do not corrupt queries — FIND_DOCUMENTS returns a superset, and I→V conversion filters stale entries at query time.

**Why it matters for spec:** Reinforces the monotonicity invariant `∀ t₁ < t₂ : spanf_entries(t₁) ⊆ spanf_entries(t₂)` from Finding 0057. Critically, stale spanfilade entries do NOT violate F0 because: (1) they do not modify other documents, (2) they do not corrupt query correctness (filtering at I→V conversion), (3) the target document's POOM is correctly updated. The spec should model spanf staleness as an acceptable weakening: `actual_docs(i) ⊆ find_documents(i)`.

**Code references:**
- `do1.c:162-171` — `dodeletevspan` has no spanf call
- `orglinks.c:144-151` — `deletevspanpm` calls only `deletend` + `logbertmodified`

**Provenance:** Finding 0067 (confirming Finding 0057)

### EC-GHOST-LINK-ENDPOINT

**What happens:** When a document DELETEs content that serves as a link endpoint in another document, the link in the other document becomes a "ghost link." The other document's link POOM entry remains unchanged at its V-position (e.g., 2.x). The link's I-addresses are immutable. What changes is that the source document's POOM no longer maps those I-addresses to V-positions, so endpoint resolution fails — producing empty endset spans.

This is NOT a violation of F0: the other document's structure is unchanged, the target document's POOM is correctly updated (I-address mappings removed), and the link subspace in the other document is unaffected. The ghost link is a consequence of content identity semantics, not a side effect.

**Why it matters for spec:** Link endpoint validity is not guaranteed as a postcondition of DELETE on source content. The formal model should track that link endpoints reference I-addresses, and I-address resolvability depends on the POOM state of the home document. DELETE on document D can make I-addresses unresolvable in D, which affects links in other documents that reference those I-addresses — but this is an indirect semantic consequence, not a structural mutation of other documents.

**Code references:**
- `edit.c:53-57` — Case 1 in `deletend`: `disown` + `subtreefree` removes I-address mappings
- `do1.c:162-171` — `dodeletevspan` modifies only target document's orgl

**Concrete example:**
```
Pre-state:
  Doc A has content at I-addresses α₁..α₅
  Doc B has link with endset referencing α₁..α₃ in Doc A

Operation: DELETE α₁..α₃ content from Doc A

Post-state:
  Doc A: POOM no longer maps α₁..α₃ to V-positions
  Doc B: link POOM entry UNCHANGED at V-position 2.x
  Doc B: link I-addresses UNCHANGED (still reference α₁..α₃)
  FOLLOWLINK from Doc B: empty endset spans (α₁..α₃ unresolvable in Doc A)
  F0 NOT violated: Doc B's structure is identical before and after
```

**Provenance:** Finding 0067 (referencing Finding 0048)
