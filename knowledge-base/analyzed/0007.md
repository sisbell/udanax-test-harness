# Finding 0007 Analysis

## Entries

### SS-VERSION-ADDRESS

**What happens:** A version's address extends the original document's address by appending a child component. For example, if the original document is at `1.1.0.1.0.1`, a version of it is at `1.1.0.1.0.1.1`. The version is a child in the address space of the original, but operationally it is an independent document — modifications to either do not affect the other.

**Why it matters for spec:** The formal spec needs: `version_address(doc) = doc.address ++ child_component`. This defines the address-space structure for versioning. Importantly, the parent-child address relationship is purely structural — it does NOT imply operational coupling. The spec must distinguish address ancestry from content dependency.

**Code references:** Address structure documented in Finding 0007 "Address Structure" section

**Provenance:** Finding 0007

### ST-VERSION-CREATE

**What happens:** Creating a version produces a new, independent document whose content references share identity with the original's content references. This is copy-on-write at the content-identity level: the version starts with references to the same `ContentId` values as the original, but subsequent edits to either document create new content identities without affecting the other. The version operation is equivalent to a full-document vcopy into a new document in the original's address subspace.

**Why it matters for spec:** The postcondition for version creation is: `references(version) = references(original)` at creation time, where equality means the same set of `ContentId` values. Combined with FC-DOC-ISOLATION, all subsequent operations on either document are independent. The precondition is minimal — even empty documents can be versioned (the resulting version has an empty reference set). The formal spec should model version-create as: allocate new document at child address, copy the reference set, done.

**Concrete example:**
- Before: Original references content identities for "Shared base content"
- After `create_version(original)`: Version references the SAME content identities for "Shared base content"
- After insert to version: Version references new identities for "version-only " + same identities for "Shared base content"
- Original: still references only identities for "Shared base content" (unchanged)

**Code references:** Tests `create_version`, `version_of_empty_document`

**Provenance:** Finding 0007

### FC-DOC-ISOLATION

**What happens:** Once a version is created, modifications to either the original or the version do not affect the other. This holds for all mutation operations: insertion into the version leaves the original unchanged, deletion from the version leaves the original unchanged, insertion into the original leaves the version unchanged, deletion from the original leaves the version unchanged. Both documents can be modified independently and concurrently. This extends the FC-DOC-ISOLATION frame condition from Finding 0002 to cover versioning specifically.

**Why it matters for spec:** The frame condition is: `forall op on doc_A where doc_B = version_of(doc_A) or doc_A = version_of(doc_B) :: references(doc_B) is unchanged`. This is not a new axiom — it follows from FC-DOC-ISOLATION and the fact that version-create produces a document with its own independent reference set. But the finding confirms it holds for the full matrix of scenarios (insert/delete on original/version, both modified).

**Concrete example:**
- Original: "Shared base content", Version: "Shared base content" (same identities)
- Delete from version: Original still reads "Shared base content"
- Delete from original: Version still reads "Shared base content"
- Modify both independently: each has its own state, neither affected by the other

**Code references:** Tests `version_delete_preserves_original`, `delete_from_original_check_version`, `modify_original_after_version`, `both_versions_modified`

**Provenance:** Finding 0007

### INV-TRANSITIVE-IDENTITY

**What happens:** Content identity is preserved transitively through version chains. If v2 is a version of v1, and v3 is a version of v2, then v1 and v3 share content identity for the text that originated in v1 — even though v3 was never directly versioned from v1. The `compare_versions` operation between v1 and v3 correctly reports shared content. This extends the INV-TRANSITIVE-IDENTITY invariant from Finding 0002 (which covered transclusion chains) to version chains.

**Why it matters for spec:** The invariant `shares_identity(A, B) && shares_identity(B, C) ==> shares_identity(A, C)` holds for version chains just as it does for vcopy chains. This follows from the version-create postcondition: since version-create copies content identity references (not content), chained versions naturally inherit all ancestral identities. No special transitivity rule is needed for versions — it falls out of ST-VERSION-CREATE.

**Concrete example:**
- v1: "Original from v1"
- v2: version of v1, then append " plus v2" → "Original from v1 plus v2"
- v3: version of v2, then append " plus v3" → "Original from v1 plus v2 plus v3"
- `compare_versions(v1, v3)` reports "Original from v1" as shared content

**Code references:** Test `compare_across_version_chain`

**Provenance:** Finding 0007

### INT-LINK-TRANSCLUSION

**What happens:** Links follow content identity through versioning. When a document with linked content is versioned, the version inherits the ability to discover those links — because the version shares the same content identities as the original, and links are indexed by content identity. Calling `find_links` on the version returns the same link objects as calling `find_links` on the original. This extends INT-LINK-TRANSCLUSION from Finding 0004 to cover version-created documents in addition to vcopy-created references.

**Why it matters for spec:** The existing specification for link discovery — `find_links(specset)` returns links whose endpoint content identities intersect the specset — already covers this case. Since ST-VERSION-CREATE copies content identity references, versioned documents automatically satisfy the content-identity intersection condition for any links attached to the original's content. No new rule is needed; the finding confirms that the link discovery mechanism generalizes to versions.

**Concrete example:**
- Source: "Click here for info" — link on "here" (content identity C₁)
- Version: version of Source → "Click here for info" (same C₁)
- `find_links(Source)` → [link_id]
- `find_links(Version)` → [link_id] (same link, because Version references C₁)

**Code references:** Test `version_with_links`

**Provenance:** Finding 0007

### INT-VERSION-TRANSCLUSION

**What happens:** Transclusion relationships are inherited through versioning. If document A transcludes content from document B (via vcopy), and a version of A is created, the version also shares content identity with B. The `compare_versions` operation between the version and B correctly reports shared content. This means versioning preserves not just direct content identity but also transclusive content identity.

**Why it matters for spec:** This is an interaction property: `vcopy(B, A) && version_of(A, V) ==> shares_identity(V, B)`. It follows from the transitivity of content identity: A shares identity with B (via vcopy), V shares identity with A (via version-create), therefore V shares identity with B. The formal spec does not need a special version-transclusion rule — it is a consequence of ST-VERSION-CREATE and ST-VCOPY operating on the same content identity system.

**Concrete example:**
- Source: "Shared transcluded content"
- Doc: "Prefix: " + vcopy("Shared" from Source) → Doc shares identity with Source for "Shared"
- Version: version of Doc → Version shares identity with Doc (and transitively with Source)
- `compare_versions(Version, Source)` finds "Shared" as shared content

**Code references:** Test `version_preserves_transclusion`

**Provenance:** Finding 0007

### ST-INSERT

**What happens:** Inserting text in the middle of content that has shared identity (from versioning or vcopy) splits the shared identity into two regions. The original content identities are preserved on both sides of the insertion point; only the inserted material has new content identities. After insertion, `compare_versions` reports two separate shared regions instead of one contiguous region. This confirms and extends the ST-INSERT entry from Finding 0002 with a concrete split-identity example.

**Why it matters for spec:** The postcondition for mid-span insert on shared content is: if content identities [C₁..Cₙ] are at positions [p..p+n] and an insert of width w occurs at position p+k (where 0 < k < n), then after the insert: [C₁..Cₖ] are at positions [p..p+k] and [Cₖ₊₁..Cₙ] are at positions [p+k+w..p+n+w]. The content identities are unchanged; only their positions in the document shift. The formal spec should model positions as derived from content identity ordering, not as fixed offsets.

**Concrete example:**
- Original: "FirstSecond" (single shared region with version)
- Version: insert " MIDDLE " at position 6 → "First MIDDLE Second"
- `compare_versions()` reports two shared regions:
  - "First" (width 5) at original:1.1, version:1.1
  - "Second" (width 6) at original:1.6, version:1.14

**Code references:** Test `version_insert_in_middle`

**Provenance:** Finding 0007

### EC-EMPTY-DOC

**What happens:** Empty documents can be versioned. The resulting version is also empty and can have content added independently. Adding content to the version does not affect the empty original. This is a boundary case confirming that version-create has no precondition on document size — the operation is valid even when the document's reference set is empty.

**Why it matters for spec:** The precondition for version-create is: `doc exists` (no minimum content requirement). The postcondition when the original is empty: `references(version) = ∅`. This edge case confirms that ST-VERSION-CREATE and FC-DOC-ISOLATION hold at the empty-set boundary.

**Concrete example:**
- Empty document: (no content, reference set = ∅)
- Version: (no content initially, reference set = ∅)
- After insert to version: Version has "Content in version only"
- Original: still empty

**Code references:** Test `version_of_empty_document`

**Provenance:** Finding 0007
