# Finding 0006 Analysis

## Entries

### ST-REARRANGE

**What happens:** The REARRANGE operation (FEBE command 3) restructures content within a document without deleting it. It has two modes based on the number of cut positions provided:

1. **Pivot (3 cuts):** `pivot(doc, start, pivot, end)` — rotates the content around a pivot point within the range `[start, end)`.
2. **Swap (4 cuts):** `swap(doc, starta, enda, startb, endb)` — exchanges two subranges within the document.

The backend enforces the cut count strictly: providing 2 cuts aborts with "Wrong number of cuts". This is a content-preserving operation — no content identities are created or destroyed.

**Why it matters for spec:** REARRANGE is a distinct state transition from INSERT and DELETE. Its postcondition preserves the set of content identities: `content_ids(doc_after) = content_ids(doc_before)`. Only the v-ordering changes. The spec must model pivot and swap as permutations of the document's content sequence, not as delete-then-insert pairs. The strict cut-count validation is a precondition: `|cuts| ∈ {3, 4}`.

**Code references:** FEBE command 3 (backend); `session.pivot()`, `session.swap()` (febe/client.py)

**Provenance:** Finding 0006

### PRE-REARRANGE

**What happens:** The REARRANGE operation rejects invalid cut counts. Providing 2 cuts (which would be ambiguous — not enough to define either a pivot or a swap) causes the backend to abort with the error message "Wrong number of cuts". The valid cut counts are exactly 3 (pivot) and 4 (swap).

**Why it matters for spec:** Precondition for REARRANGE: `pre_rearrange(doc, cuts) ≡ |cuts| = 3 ∨ |cuts| = 4`. Violations produce an error rather than undefined behavior. This is explicit input validation at the backend level.

**Provenance:** Finding 0006

### ST-REMOVE

**What happens:** Deletion uses the DELETEVSPAN operation (FEBE command 12), which takes a vspan (start address + width offset). This is the correct and only mechanism for removing content from a document. REARRANGE (command 3) cannot be used for deletion despite its name suggesting content restructuring.

**Why it matters for spec:** Confirms that content removal is a single atomic operation taking a contiguous vspan. The postcondition removes exactly the content identities within the specified span: `content_ids(doc_after) = content_ids(doc_before) \ content_ids(vspan)`. The spec should not model deletion as a special case of rearrangement — they are distinct operations with different postconditions (REARRANGE preserves content identity count, REMOVE reduces it).

**Code references:** FEBE command 12 (backend); `session.remove()`, `session.delete()` (febe/client.py)

**Provenance:** Finding 0006

### PRE-OPEN-DOC

**What happens:** The backend rejects attempts to open a document that is already open in the current session, even if the requested access mode differs (e.g., opening as READ_WRITE then attempting READ_ONLY). Only one handle per document is permitted at a time. To change access mode, the document must be closed and reopened.

**Why it matters for spec:** Precondition for open: `pre_open(session, docid, mode) ≡ docid ∉ open_docs(session)`. This is a session-level constraint, not a document-level one — multiple sessions could each have the same document open (not tested here, but the constraint is per-session). The spec must model an open-document set per session: `session.open_docs : set<DocId>`, with open adding to and close removing from this set.

**Code references:** Backend error on duplicate open; `addtoopen` in backend stderr

**Provenance:** Finding 0006

### EC-COMPARE-VERSIONS-LINK-CRASH

**What happens:** The `compare_versions()` operation crashes the backend (abort) when comparing documents that contain links. This is a known bug — the comparison logic does not handle the link enfilade correctly, causing a fatal error rather than returning a result or a clean error.

**Why it matters for spec:** This is a known defect, not intended behavior, but it constrains what the spec can assume about compare_versions: the operation's domain currently excludes documents with links. A defensive precondition would be `pre_compare_versions(doc1, doc2) ≡ links(doc1) = ∅ ∧ links(doc2) = ∅`, though this is a bug to be fixed rather than a design constraint. The spec should note this as a known implementation limitation.

**Concrete example:**
- Document A contains text with a link attached
- `compare_versions(A, B)` → backend aborts (crash)

**Code references:** `compare_versions()` (backend)

**Provenance:** Finding 0006

## Omit

The following sections of Finding 0006 are omitted from analysis:

- **API Type Requirements (SpecSet vs VSpec):** Client-side type wrapper details for the FEBE protocol. The distinction between VSpec and SpecSet is a protocol serialization concern, not a semantic property of the data model.
- **Debug Output:** Backend stderr logging details (xgrabmorecore, levelpush, etc.) are implementation internals for debugging, not behavioral properties.
- **Testing Notes:** Test infrastructure details (how to run golden tests, debug scripts) are not spec-relevant.
