# Finding 0072 Analysis

## Entries

### ST-DELETE

**What happens**: DELETE is a destructive mutation of the POOM enfilade tree. The `deletend` function performs tree surgery: nodes falling entirely within the deletion range are `disown`ed (removed from parent/sibling pointers) and then `subtreefree`d (recursively freed). Nodes partially overlapping the deletion boundary have their V-displacement shifted backward. After pruning, `setwispupwards` recalculates widths up the tree and `recombine` rebalances. No copy of the pre-deletion tree state is preserved anywhere — there is no undo log, edit history, shadow copy, or transaction journal.

**Why it matters for spec**: Strengthens ST-DELETE with an explicit non-recoverability postcondition. The pre-mutation POOM tree `T` cannot be reconstructed from the post-mutation tree `T'`:

```
delete(D, vspan) ⟹
  (1) T' = mutate(T, vspan)          -- tree is structurally modified
  (2) ¬∃ f : T' → T                  -- no recovery function from T' alone
  (3) recovery(D, t) requires ∃ V : created_before(V, t) ∧ V = snapshot(D, t)
```

**Code references**:
- `backend/edit.c:31-76` — `deletend`: `disown` + `subtreefree` on nodes within deletion range, displacement shift on partial overlaps
- `backend/credel.c:413-436` — `subtreefree`: recursive memory deallocation
- `backend/genf.c:349-380` — `disown`: removes crum from tree structure

**Concrete example**:
```
Before: doc contains "First Second Third"
  POOM maps V(1.1)-V(1.18) → I-addresses

After DELETE " Third" then DELETE " Second":
  POOM maps V(1.1)-V(1.5) → I-addresses for "First"
  The intermediate state (containing " Second") is gone — the POOM nodes
  were freed by subtreefree. No mechanism exists to recover "First Second"
  or "First Second Third" from the current POOM state alone.
```

**Provenance**: Finding 0072

### ST-VERSION-CREATE

**What happens**: `CREATENEWVERSION` is the sole mechanism for preserving a document's state before editing. It creates a new POOM tree that shares I-addresses with the original for text content. The original and version are separate tree structures — editing one does not affect the other. Critically, there is no automatic invocation of this operation; it must be called explicitly before any edit whose prior state might need recovery.

The mechanism: `docreatenewversion` calls `doretrievedocvspanfoo` to obtain the source document's text vspan, creates a new orgl in the granfilade via `createorglingranf`, then copies text content via `docopyinternal`. The copy shares I-addresses (identity-preserving), so version comparison and provenance chains work across the original and its version.

**Why it matters for spec**: The precondition for historical recovery is the prior existence of a version:

```
recoverable(D, state_at_t) ⟺ ∃ V : CREATENEWVERSION(D) executed at time t, producing V
```

Without an explicit version, no prior state is recoverable. This is a hard constraint — not a soft degradation. The spec must not assume automatic history.

**Code references**:
- `backend/do1.c:264-303` — `docreatenewversion`: retrieves vspan, creates new orgl, copies text via `docopyinternal`
- `backend/do1.c:305-313` — `doretrievedocvspanfoo`: returns text subspace vspan

**Provenance**: Finding 0072

### INV-DELETE-NOT-INVERSE

**What happens**: DELETE followed by re-INSERT of identical text does not restore document identity. V-space content matches the original, but I-addresses are entirely new allocations. This means all I-address-indexed relationships are severed: transclusion links pointing to the original I-addresses no longer intersect the document's content, `compare_versions` reports no shared content between the original state and the re-inserted state, and `find_documents` provenance queries return different results.

The only identity-preserving restoration is VCOPY from a document (typically a version) that still references the original I-addresses. VCOPY shares existing I-addresses rather than allocating new ones.

**Why it matters for spec**: Reinforces the non-invertibility property with concrete relationship consequences:

```
State A: "Original text" at I(5.1)-I(5.13)
DELETE → INSERT same text:
State B: "Original text" at I(5.14)-I(5.26)

Broken: transclusions referencing I(5.1)-I(5.13)
Broken: compare_versions(A, B) finds no shared I-addresses
Broken: find_documents queries for I(5.1)-I(5.13) no longer find this document

Preserved: VCOPY from version sharing I(5.1)-I(5.13) restores identity
```

**Code references**:
- `backend/do1.c:27-43` — `doinsert`: always calls `inserttextingranf` for fresh I-addresses
- `backend/do1.c:45-65` — `docopy`/VCOPY: calls `insertpm` sharing existing I-addresses
- `febe/tests/debug/test_edit_history.py` — demonstrates identical V-space content with different I-addresses

**Provenance**: Finding 0072

### FC-VERSION-ISOLATION

**What happens**: Once a version is created via `CREATENEWVERSION`, it is a fully independent document with its own POOM tree. Edits to the original document (INSERT, DELETE, REARRANGE) modify only the original's POOM. Edits to the version modify only the version's POOM. Neither affects the other. The shared I-addresses in the granfilade are immutable and unaffected by either document's mutations.

**Why it matters for spec**: Frame condition for edits on versioned documents:

```
Let V = CREATENEWVERSION(D)
∀ op applied to D : poom(V) unchanged
∀ op applied to V : poom(D) unchanged
∀ op applied to D or V : granfilade unchanged (I-addresses immutable)
```

This is what makes versions useful as recovery snapshots — the version's state is frozen with respect to edits on the original.

**Code references**:
- `backend/do1.c:264-303` — `docreatenewversion`: creates a new, separate orgl
- `backend/edit.c:31-76` — `deletend`: operates on a single document's orgl only

**Provenance**: Finding 0072

### SS-POOM-MUTABILITY

**What happens**: The POOM (Permutation of the Original Material) enfilade for each document is a mutable tree structure. It is the only mutable layer in the data model — the granfilade is append-only and the spanfilade is write-only. The POOM maps V-addresses to I-addresses and is modified in-place by INSERT (adds new leaf nodes), DELETE (removes and frees leaf nodes), and REARRANGE (restructures mappings). There are no copy-on-write semantics, no shadow copies, and no journaling at the POOM level.

**Why it matters for spec**: The state model must distinguish mutable from immutable components:

```
State = {
  granfilade: I-addr → byte          -- immutable, append-only
  spanfilade: I-addr → {doc-ISA}     -- immutable, write-only (no delete)
  pooms: doc-ISA → (V-addr → I-addr) -- MUTABLE, modified in-place
}
```

The POOM is the sole locus of destructive mutation. All state transitions (ST-INSERT, ST-DELETE, ST-REARRANGE) operate on POOMs. Invariants about content permanence (INV-IADDR-IMMUTABILITY) hold because they apply to the granfilade, not the POOM.

**Code references**:
- `backend/orglinks.c:145-152` — `deletevspanpm`: calls `deletend` on the document's POOM orgl directly
- `backend/edit.c:31-76` — `deletend`: mutates the POOM tree in-place

**Provenance**: Finding 0072
