# Finding 0063 Analysis

## Entries

### INT-LINK-INSERT

**What happens:** CREATELINK breaks I-address contiguity for subsequent text INSERTs. After INSERT "ABC" (I-addresses 1.1–1.3) followed by CREATELINK, the next INSERT "DEF" receives I-addresses starting at 2 (not 1.4). This is because CREATELINK allocates an orgl in the granfilade via `createorglingranf`, which calls `findisatoinsertnonmolecule` to obtain an I-address. This allocation advances the granfilade's maximum I-address. When the next INSERT calls `findpreviousisagr` to determine the allocation point, it finds the link orgl's I-address as the highest and allocates above it — creating a gap in the text I-address sequence.

The gap is observable through `compare_versions`: a document with INSERT "ABC" + INSERT "DEF" (no link) yields 1 shared span pair, while INSERT "ABC" + CREATELINK + INSERT "DEF" yields 2 shared span pairs. The two text regions have non-contiguous I-address ranges because the link orgl's I-address sits between them.

**Why it matters for spec:** This is a cross-subsystem interaction: `create_link` modifies the I-address allocation sequence for subsequent `insert` operations, even though link orgls and text content occupy different V-space subspaces (2.x vs 1.x). The formal model must account for a shared I-address allocator across all granfilade entities. The allocation function is `next_iaddr(granf) = max_iaddr(granf) + 1` regardless of entity type — text characters and link orgls compete for the same monotonic sequence. The interaction predicate: `post(create_link) ⟹ next_text_iaddr > pre(create_link).next_text_iaddr + link_width`.

**Code references:**
- `do1.c:199-225` — `docreatelink` calls `createorglingranf`, which allocates an I-address for the link orgl
- `granf2.c:130-181` — `findisatoinsertgr` / `findisatoinsertmolecule` — shared allocation used by both text INSERT and link orgl creation
- `granf2.c:255-278` — `findpreviousisagr` — tree traversal returns the highest I-address regardless of entity type

**Concrete example:**
```
INSERT "ABC" → I-addresses 1.1, 1.2, 1.3 allocated in granfilade
CREATELINK   → link orgl gets I-address in higher range (consumes space up to ~2)
INSERT "DEF" → findpreviousisagr returns link orgl's I-address as max
               allocates at 2.1, 2.2, 2.3 (gap from text "ABC" at 1.1–1.3)

compare_versions reports 2 shared span pairs:
  span 1: source 1.1 width 0.3 (ABC)
  span 2: source 2   width 0.4 (DEF — note different I-address range)
```

**Provenance:** Finding 0063

### INV-MONOTONIC

**What happens:** The monotonic I-address invariant holds across CREATELINK: all allocations (text and non-text) draw from the same monotonically increasing sequence. CREATELINK does not violate monotonicity — it consumes I-address space in the same forward-only manner as INSERT. However, because link orgls and text characters share the same allocation sequence, CREATELINK introduces non-contiguity in the *text-only* I-address subsequence. The overall sequence remains monotonic: text I.1–I.3, link orgl at ~I.2.0, text at I.2.1+.

This refines the invariant from Finding 0061: `∀ op ∈ {DELETE, REARRANGE} : granf_state_after(op) = granf_state_before(op)` holds, but CREATELINK is NOT in this set. CREATELINK, like INSERT, adds entries to the granfilade. The granfilade growth set is `{INSERT, COPY, CREATELINK}`, not just `{INSERT, COPY}`.

**Why it matters for spec:** The monotonic invariant `∀ alloc_a, alloc_b : time(a) < time(b) ⟹ iaddr(b) > iaddr(a)` remains valid but must be understood as spanning ALL entity types. The spec should distinguish: (1) the global monotonic invariant (holds for all allocations), (2) text-contiguity (holds only when no non-text allocation intervenes). Formally: `text_contiguous(insert_a, insert_b) ⟺ ¬∃ alloc_c : time(a) < time(c) < time(b) ∧ type(c) ≠ TEXT`.

**Code references:**
- `granf2.c:158-181` — `findisatoinsertmolecule` for text (molecules)
- `granf2.c:130-157` — `findisatoinsertnonmolecule` for non-text entities (link orgls) — same tree, same allocation logic

**Provenance:** Finding 0063

### INV-CRUM-BOUND

**What happens:** CREATELINK breaks `isanextensionnd` coalescing for subsequent text INSERTs. After CREATELINK consumes I-address space, the next INSERT's text I-addresses are non-contiguous with the previous INSERT's text I-addresses. When `isanextensionnd` checks whether the new content's origin equals the existing crum's reach, the check fails — the new text I-addresses start in a different range from the link orgl allocation. This forces creation of new crums, equivalent to a cursor repositioning.

Each CREATELINK followed by text INSERT incurs the same +2 crum cost as a cursor repositioning. The crum bound `c ≤ 1 + 2C + 3R + 3P` from Finding 0062 should account for link creation events either in the C term (treating CREATELINK as an implicit repositioning) or via a separate L term: `c ≤ 1 + 2C + 2L + 3R + 3P`, where L is the number of CREATELINK operations interleaved with text INSERTs.

**Why it matters for spec:** The crum bound invariant needs refinement. CREATELINK is an "invisible cursor repositioning" from the I-address perspective — it does not change the V-space insertion point, but it disrupts I-space contiguity required for coalescing. The Dafny lemma for crum bound must include CREATELINK in the set of coalescing-breaking operations: `coalesce_breakers = cursor_repositions ∪ createlink_events`.

**Code references:**
- `insertnd.c:293-301` — `isanextensionnd()` checks reach == origin; fails after CREATELINK because origin jumps past link orgl's I-address range

**Concrete example:**
```
INSERT "ABC" at v:    crum₁ [v, v+0.3), I-addr 1.1–1.3. crums = 1
CREATELINK:           link orgl allocated at I-addr ~2. No V-space text effect.
INSERT "DEF" at v+0.3:
  isanextensionnd checks: crum₁.reach (I-addr 1.4) == new origin (I-addr 2.1)?
  FALSE — link orgl consumed I-space between 1.3 and 2.1
  New crum₂ created: +2 crums → 3 crums
  (Same cost as if user had repositioned cursor)
```

**Provenance:** Finding 0063

### FC-GRANF-ON-DELETE

**What happens:** This finding confirms and contrasts the frame condition from Finding 0061: DELETE is a pure V-space (spanfilade) operation with no I-space (granfilade) effect, while CREATELINK modifies the granfilade. The experimental evidence is direct:
- INSERT "ABC" → DELETE "B" → INSERT "DEF": 1 shared span pair (no I-address gap). DELETE's frame condition preserves granfilade state.
- INSERT "ABC" → CREATELINK → INSERT "DEF": 2 shared span pairs (I-address gap). CREATELINK violates the granfilade frame condition.

This establishes the operation classification: `{DELETE, REARRANGE}` are granfilade-preserving (weak operations); `{INSERT, COPY, CREATELINK}` are granfilade-modifying (strong operations).

**Why it matters for spec:** Strengthens the frame condition: `∀ op ∈ {DELETE} : granf_after(op) = granf_before(op)`. Explicitly excludes CREATELINK from the frame-preserving set. The Xanadu principle "bytes never die" applies to DELETE (V-space only, I-space untouched) but CREATELINK has permanent I-space effects — the link orgl's I-address is allocated forever and influences all future text I-address allocation.

**Code references:**
- `edit.c` — `deletevspanpm` modifies spanfilade only (no granfilade calls)
- `do1.c:199-225` — `docreatelink` calls `createorglingranf` (granfilade modification)

**Concrete example:**
```
DELETE path:      INSERT "ABC" → DELETE "B" → INSERT "DEF"
  Granfilade: I.1, I.2, I.3 (DELETE leaves all three), then I.4, I.5, I.6
  compare_versions: 1 span pair (contiguous I-addresses for remaining text)

CREATELINK path:  INSERT "ABC" → CREATELINK → INSERT "DEF"
  Granfilade: I.1, I.2, I.3, then link orgl at ~I.2.0, then I.2.1+
  compare_versions: 2 span pairs (gap between ABC and DEF I-addresses)
```

**Provenance:** Finding 0063
