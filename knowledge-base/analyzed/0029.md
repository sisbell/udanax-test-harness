# Finding 0029 Analysis

## Entries

### PRE-FIND-LINKS
**What happens:** `find_links()` requires that the searched endpoint content exists in the V-stream (visible view) to discover a link. The operation performs an intersection between the search specset and the link's endpoint specset; if the linked content has been deleted from the V-stream, the intersection is empty and the link is not found. Partial deletion is tolerated — as long as any portion of the original linked span remains, the link is discoverable.

**Why it matters for spec:** Defines the precondition for link discoverability. A link exists permanently but is only discoverable via `find_links()` when its endpoint content is present in the V-stream. This is not a precondition for validity (the call succeeds either way), but a precondition for non-empty results. Formalizable as: `find_links(spec) ≠ ∅ → ∃ overlap(spec ∩ V-stream, link.endpoint ∩ V-stream)`.

**Code references:** Test scenarios in `febe/scenarios/links/search_endpoint_removal.py`. Golden files in `golden/links/search_*.json`.

**Concrete example:**
- Before delete: `find_links(source_spec)` → `[link_id]`
- After deleting source content: `find_links(source_spec)` → `[]`
- Partial delete ("hyper" from "hyperlink"): remaining "link" still in V-stream → `[link_id]` still returned

**Provenance:** Finding 0029, sections 1, 3, 8

### ST-FIND-LINKS
**What happens:** `find_links()` uses AND semantics when called with multiple criteria. When both source and target specs are provided, both endpoints must have V-stream presence for the link to be found. Single-endpoint search (passing NOSPECS for the other) requires only that endpoint's presence.

Cross-endpoint search matrix:

| Source State | Target State | Search by Source | Search by Target |
|--------------|--------------|------------------|------------------|
| Intact       | Intact       | Found            | Found            |
| Deleted      | Intact       | Not found        | Found            |
| Intact       | Deleted      | Found            | Not found        |
| Deleted      | Deleted      | Not found        | Not found        |

When multiple links share a target, deleting one source removes only that link from source-based search; target-based search still finds all links (the link objects themselves are unaffected).

**Why it matters for spec:** Defines the state-transition semantics of `find_links()` — specifically how delete operations on document content transitively affect link discoverability without modifying the links themselves. The AND semantics for multi-criteria search is a key behavioral property: `find_links(source_spec, target_spec)` ≡ `find_links(source_spec) ∩ find_links(target_spec)`.

**Code references:** Tests `search_by_both_endpoints_one_removed`, `search_multiple_links_selective_removal` in `febe/scenarios/links/search_endpoint_removal.py`.

**Concrete example:**
- `find_links(source, target)` before delete → `[link_id]`
- Delete source content
- `find_links(source, target)` → `[]` (AND fails)
- `find_links(NOSPECS, target)` → `[link_id]` (target-only still works)

**Provenance:** Finding 0029, sections 2, 5, 7

### INV-LINK-PERMANENCE
**What happens:** Links are permanent objects. Even when a link cannot be discovered via `find_links()` because its endpoint content has been deleted, the link still exists and is directly accessible via its link ID. `follow_link(link_id, endpoint)` works for source, target, and type regardless of V-stream state.

**Why it matters for spec:** Core invariant of the Xanadu model — links cannot be deleted, only orphaned. This separates link existence (permanent, in the link's home document) from link discoverability (contingent on V-stream content). Formalizable as: `∀ link_id ∈ created_links : follow_link(link_id, LINK_SOURCE) succeeds ∧ follow_link(link_id, LINK_TARGET) succeeds ∧ follow_link(link_id, LINK_TYPE) succeeds`, regardless of any delete operations on endpoint documents.

**Code references:** Test `search_by_source_after_source_removed` in `febe/scenarios/links/search_endpoint_removal.py`.

**Concrete example:**
- `link_id = create_link(...)`
- Delete source content
- `find_links(source)` → `[]` (not discoverable)
- `follow_link(link_id, LINK_SOURCE)` → works
- `follow_link(link_id, LINK_TARGET)` → works
- `follow_link(link_id, LINK_TYPE)` → works

**Provenance:** Finding 0029, section 6

### FC-LINK-DELETE-ISOLATION
**What happens:** Deleting content from a document's V-stream does not modify any link objects. Links are stored in their home document, separate from the endpoint documents. Delete affects discoverability (find_links results change) but not link state (follow_link results unchanged). Deleting one source in a multi-link scenario affects only that source's findability — other links to the same target are unaffected.

**Why it matters for spec:** Frame condition for delete operations: delete modifies only the target document's V-stream; it preserves all link objects, their endpoint specifications, and their I-stream addresses. Formalizable as: `∀ delete(doc, span) : ∀ link ∈ links : link.source_spec' = link.source_spec ∧ link.target_spec' = link.target_spec`.

**Code references:** Tests `search_multiple_links_selective_removal`, `search_by_source_after_source_removed` in `febe/scenarios/links/search_endpoint_removal.py`.

**Provenance:** Finding 0029, sections 5, 6

### INT-TRANSCLUSION-LINK-SEARCH
**What happens:** When content is transcluded (vcopy'd) to another document, the copy retains the original content identity (I-stream addresses). If the original content is deleted, links referencing that content become undiscoverable from the original document but remain discoverable from the copy, because the copy's V-stream still contains content at those I-stream addresses.

**Why it matters for spec:** Key interaction between transclusion and link search. Transclusion creates redundant discoverability paths — content identity is preserved across copies, so link search works from any document containing that content. Formalizable as: `vcopy(doc_a, span, doc_b) → (∀ link on span : find_links(doc_b, span) includes link)` and this survives `delete(doc_a, span)`.

**Code references:** Test `search_after_vcopy_source_deleted` in `febe/scenarios/links/search_endpoint_removal.py`.

**Concrete example:**
- Original document contains "linked", link created on it
- `vcopy("linked")` from Original to Copy
- Delete "linked" from Original
- `find_links(Original)` → `[]`
- `find_links(Copy)` → `[link_id]` (still found via the copy)

**Provenance:** Finding 0029, section 4

### EC-SEARCH-SPEC-BEYOND-BOUNDS
**What happens:** When a search spec references positions that no longer exist in the V-stream (e.g., after deletion shrinks the document), `find_links()` does not error. It gracefully intersects with whatever content remains, still finding links on surviving content.

**Why it matters for spec:** Edge case for find_links — stale or oversized specs are tolerated. The backend clips the spec to the current V-stream extent rather than rejecting it. This means callers need not track document size changes before searching.

**Code references:** Test `search_spanning_deleted_boundary` in `febe/scenarios/links/search_endpoint_removal.py`.

**Concrete example:**
- Document: "Start MIDDLE End link text" (26 chars), link on "link"
- Search spec: positions 1–26
- Delete "MIDDLE " (7 chars) → document now 19 chars
- `find_links(original 1-26 spec)` → `[link_id]` (still works despite spec exceeding bounds)

**Provenance:** Finding 0029, section 8

### EC-TYPE-FILTER-NONFUNCTIONAL
**What happens:** Type filtering with `find_links(source, NOSPECS, type_spec)` returns empty results even when unfiltered search finds links of those types. This is a pre-existing issue, not specific to endpoint removal.

**Why it matters for spec:** Signals that type-based link search may require a different specset format, have undocumented semantics, or be a backend limitation. Any formal spec of find_links should note that the type parameter's behavior is unverified/possibly broken.

**Code references:** Test `search_type_filter_with_removed_endpoints` in `febe/scenarios/links/search_endpoint_removal.py`. See also `golden/links/find_links_by_type.json`.

**Concrete example:**
- `find_links(source)` → `[jump, quote, footnote]` (3 links found)
- `find_links(source, NOSPECS, JUMP_TYPE)` → `[]` (empty)
- `find_links(source, NOSPECS, QUOTE_TYPE)` → `[]` (empty)

**Provenance:** Finding 0029, section 9
