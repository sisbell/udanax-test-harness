# Finding 0049 Analysis

## Entries

### PRE-INSERT

**What happens:** INSERT does not validate that the caller-specified V-position falls within the text subspace (1.x). The `acceptablevsa()` function in `do2.c:110-113` unconditionally returns `TRUE`. The only V-position checks in `insertpm()` are: (1) reject zero tumbler (lines 86-90), (2) reject negative tumbler (lines 93-98). Text content can be placed at V-position 2.1 (link subspace) via INSERT and it succeeds silently. The text is stored and retrievable at that position.

**Why it matters for spec:** INSERT has a missing precondition: `vsa ∈ text_subspace(1.x)`. The formal spec must add `requires vsa.head == 1` for text insertion. This is the placement-side gap — ENF0 prevents modification of existing link orgls but does not prevent placing new text content at arbitrary V-positions. The spec's `pre(INSERT)` must include subspace membership even though the implementation does not enforce it.

**Code references:**
- `backend/do2.c:110-113` — `acceptablevsa()` always returns TRUE
- `backend/orglinks.c:86-98` — `insertpm()` checks only zero and negative, not subspace
- `backend/do1.c:91-127` — `doinsert()` sets TEXTATOM hint but does not validate V-position subspace

**Concrete example:**
```
Pre-state:
  Document 1.1.0.1.0.1 with text at V:1.1..1.10

INSERT(doc=1.1.0.1.0.1, vsa=2.1, text="TextAtLinkPosition")

Post-state:
  INSERT succeeds (no error)
  vspanset now has TWO spans: {start:0, width:0.1} and {start:1, width:1}
  retrieve_contents(from=2.1, width=0.19) returns ["TextAtLinkPosition"]
  Text bytes are stored in link subspace — subspace convention violated
```

**Provenance:** Finding 0049

### INV-SUBSPACE-CONVENTION

**What happens:** Finding 0049 provides direct experimental confirmation that the subspace partition (text at 1.x, links at 2.x) is not enforced. INSERT at V-position 2.1 with text content succeeds, and the content is stored and retrievable. The vspanset after insertion shows two disjoint spans crossing subspace boundaries. This demonstrates the convention is purely caller-enforced — the back end treats all V-positions uniformly.

**Why it matters for spec:** The subspace convention must be modeled as a precondition on every V-position-accepting operation, not as a storage-layer invariant. The spec invariant `INV-SUBSPACE: ∀ v ∈ doc.vspan_set: (type(content_at(v)) == TEXT) ⟹ v.head == 1` holds only if all callers cooperate. A well-formed system state requires this invariant, but the implementation provides no enforcement. For Dafny, this means the invariant must appear as a `requires` clause on every public operation, with a proof obligation that each operation preserves it.

**Code references:**
- `backend/do2.c:110-113` — `acceptablevsa()` stub that was presumably intended for validation
- `backend/do1.c:121-124` — `doinsert()` sets `TEXTATOM` element type but V-position is independent

**Concrete example:**
```
INSERT text at V:2.1 → succeeds
retrieve_contents(V:2.1, width:0.19) → "TextAtLinkPosition"
  → text bytes occupying link subspace
  → no error, no warning, no distinction from normal text insertion
```

**Provenance:** Finding 0049

### PRE-ENF0-PLACEMENT-GAP

**What happens:** ENF0 (`may-modify(orgl) ≡ element-type(orgl) ≠ LINKATOM`) prevents modification of existing link orgls but does not constrain where new content is placed. INSERT allocates fresh I-addresses via `inserttextingranf()` and places them at the caller-specified V-position via `docopy()`. Since the fresh orgl has no prior state, ENF0's target-type discipline does not apply. The element type (TEXTATOM) is set by `doinsert()` at `do1.c:121` via `makehint(DOCUMENT, ATOM, TEXTATOM, ...)`, but there is no validation that TEXTATOM content targets a 1.x V-position.

**Why it matters for spec:** ENF0 is a necessary but insufficient guard for I2/I4 preservation. The spec must distinguish two predicates: (1) `may-modify(orgl)` — existing ENF0, prevents mutation of link orgls; (2) `may-place-at(vpos, element_type)` — missing predicate, would enforce `element_type == TEXTATOM ⟹ vpos.head == 1` and `element_type == LINKATOM ⟹ vpos.head == 2`. Without the placement predicate, a misbehaving front end can violate I4 by inserting non-link data in the link subspace.

**Code references:**
- `backend/do1.c:91-127` — `doinsert()` sets TEXTATOM, calls `docopy()` with unchecked V-position
- `backend/do1.c:199-225` — CREATELINK uses LINKATOM with 2.x positions (correct pairing, but also unenforced)
- `backend/xanadu.h:145-146` — `TEXTATOM=1`, `LINKATOM=2` element type constants

**Concrete example:**
```
ENF0 predicate: may-modify(orgl) ≡ element-type(orgl) ≠ LINKATOM

INSERT at V:2.1 with text "Hello":
  1. inserttextingranf → fresh I-addresses α (element-type = TEXTATOM)
  2. docopy(doc, vsa=2.1, {α}) → acceptablevsa returns TRUE
  3. insertpm places α at V:2.1
  4. ENF0 not triggered — α is new, has no prior element-type to check

Result: TEXTATOM content at V:2.1 (link subspace)
  → I4 violation: link subspace contains non-link data
  → ENF0 did not prevent this because ENF0 is a modification guard, not a placement guard
```

**Provenance:** Finding 0049, also Finding 0033
