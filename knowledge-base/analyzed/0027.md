# Finding 0027 Analysis

## Entries

### SS-ADDRESS-SPACE
**What happens**: V-stream positions identify points **between** characters, not the characters themselves. Position 1 is before the first character, position 2 is between the first and second characters, and so on. Insert at position N means "insert before the character currently at position N." This is a cursor-gap model: positions are inter-character gaps.

**Why it matters for spec**: The V-address model must be defined as an interleaving of gaps and characters, not as character indices. This distinction is critical for formalizing insert: the precondition references a gap position, and the postcondition shifts all subsequent character positions. Formalizing V-addresses as character indices (off-by-one) would misspecify every insert operation.

**Code references**: Observed via `edgecases/multiple_inserts_same_position` test scenario using `session.insert(opened, Address(1, 1), ...)`.

**Concrete example**:
```
V-stream state: "ABC"
  Position 1 = gap before 'A'
  Position 2 = gap before 'B'
  Position 3 = gap before 'C'
  Position 4 = gap after 'C'

Insert("X", position=2) → "AXBC"
  'X' inserted before 'B', pushing 'B' and 'C' to positions 3 and 4.
```

**Provenance**: Finding 0027a

### ST-INSERT
**What happens**: When multiple inserts target the same V-position, each new insertion appears **before** existing content at that position. This produces LIFO (last-in-first-out) ordering: the most recently inserted text appears first. Specifically:

1. Insert "First" at position 1.1 → document contains "First"
2. Insert "Second" at position 1.1 → document contains "SecondFirst"
3. Insert "Third" at position 1.1 → document contains "ThirdSecondFirst"

Each insert at position P places new content at P and shifts all existing content (including previously inserted content at P) to higher positions.

**Why it matters for spec**: The insert postcondition must specify that new content occupies the target position and all content previously at or after that position is shifted forward by the length of the inserted content. For repeated inserts at the same position, this implies a prepend-at-position semantic. This is the standard text-editor cursor model (typing at a fixed cursor position builds text left-to-right only if the cursor advances; re-inserting at the same position prepends). The formal spec for insert must capture: `forall i >= P: V'[i + len(new)] = V[i]` and `V'[P..P+len(new)] = new`.

**Code references**: Observed via `edgecases/multiple_inserts_same_position` test scenario; insert implemented through the FEBE `insert` operation targeting `Address(1, 1)`.

**Concrete example**:
```
Pre-state:  V-stream = "First" (positions 1.1..1.5)
Operation:  insert(doc, Address(1, 1), ["Second"])
Post-state: V-stream = "SecondFirst" (positions 1.1..1.11)
  "Second" occupies positions 1.1..1.6
  "First" shifted to positions 1.7..1.11

Pre-state:  V-stream = "SecondFirst"
Operation:  insert(doc, Address(1, 1), ["Third"])
Post-state: V-stream = "ThirdSecondFirst"
  "Third" occupies positions 1.1..1.5
  "SecondFirst" shifted to 1.6..1.16
```

**Provenance**: Finding 0027a

### INT-TRANSCLUSION-INSERT-ORDER
**What happens**: The LIFO insertion semantics apply equally to transclusion: when transcluding content to a position, the transcluded material appears before any existing content at that position. Sequential transclusions to the same position therefore appear in reverse chronological order in the resulting document.

**Why it matters for spec**: Transclusion and insert share the same position-insertion semantics. The spec for transclusion (copy) at a target position P must have the same shift postcondition as insert at position P. This means the ordering invariant for transclusion is: if `copy(src, target_pos=P)` is called twice, the second transclusion's content precedes the first's at P. Any formal model of document assembly via repeated transclusion must account for this reversal.

**Code references**: Implied by the shared insert-at-position mechanism; finding 0002 (transclusion content identity) confirms transclusion uses the same V-stream insertion path.

**Provenance**: Finding 0027a

### SS-DOCUMENT-LIFECYCLE
**What happens**: Documents in the backend have an explicit open/closed lifecycle state. A document must be in the "open list" (maintained by the backend) before operations that access its content can succeed. Operations that work through I-address lookup (e.g., `find_links` via span-f) do not require the referenced document to be open. Operations that resolve V→I mappings within a specific document orgl (e.g., `retrieve_contents` via `findorgl`) do require it to be open. `follow_link` returns SpecSets containing document references without requiring those documents to be open — the SpecSet is a deferred reference, not a content retrieval.

**Why it matters for spec**: The formal state model must include a set of currently-open document handles as part of the session state. Operations partition into two classes: (a) those that consult the open list (content retrieval, specset resolution) and (b) those that operate on global indices (link discovery). This open-set membership becomes a precondition for class (a) operations.

**Code references**:
- `findorgl` — checks if document orgl is in the open list; returns FALSE if not, causing the calling operation to fail
- `do1.c` — `doretrievev` calls `specset2ispanset` which calls `findorgl`
- Backend log: `orgl for 0.1.1.0.1.0.1~ not open in findorgl temp = 0`

**Concrete example**:
```
Session state: open_docs = {doc_B}
  doc_A exists but is closed
  doc_B transcludes content from doc_A

find_links(doc_B, span) → succeeds (uses span-f I-address index, no findorgl)
follow_link(link_id, LINK_SOURCE) → succeeds, returns SpecSet referencing doc_A
retrieve_contents(specset_referencing_A) → FAILS ("error response from back-end")
  because findorgl(doc_A) returns FALSE — doc_A not in open list

After: open_document(doc_A)
  open_docs = {doc_A, doc_B}
retrieve_contents(specset_referencing_A) → succeeds
```

**Provenance**: Finding 0027b

### PRE-RETRIEVE-CONTENTS
**What happens**: `retrieve_contents` (FEBE opcode 5) requires that every document referenced by the input SpecSet is currently open. The operation calls `doretrievev`, which calls `specset2ispanset`, which calls `findorgl` for each document orgl referenced in the specset. If `findorgl` finds the orgl is not in the open list, the operation fails with a backend error. This is distinct from the subspace precondition (Finding 0010): even with correct text-subspace V-addresses, the operation fails if the target document is closed.

**Why it matters for spec**: The precondition for `retrieve_contents` must include: `forall doc in specset.referenced_documents: doc in open_docs`. This is a session-state precondition (depends on which documents the caller has opened), not a structural precondition (the specset itself is well-formed). Combined with Finding 0010's subspace precondition, the full precondition is: all referenced documents open AND all V-addresses in text subspace.

**Code references**:
- `do1.c` — `doretrievev` → `specset2ispanset` → `findorgl`
- `findorgl` — checks open document list, returns FALSE if not found
- Backend log: `orgl for 0.1.1.0.1.0.1~ not open in findorgl temp = 0`

**Concrete example**:
```
Pre-state:
  open_docs = {doc_B}
  doc_A is closed
  follow_link returned SpecSet S referencing spans in doc_A

retrieve_contents(S):
  specset2ispanset(S) calls findorgl(doc_A_orgl)
  findorgl checks open list → doc_A not found → returns FALSE
  Operation fails with "error response from back-end"

After open_document(doc_A):
  open_docs = {doc_A, doc_B}
  retrieve_contents(S) → succeeds, returns content bytes
```

**Provenance**: Finding 0027b

### INT-LINK-FOLLOW-LIFECYCLE
**What happens**: The link discovery and traversal pipeline has a lifecycle gap: `find_links` and `follow_link` can succeed and return references to documents that are not open, but the final step (`retrieve_contents` on the result) fails unless those documents are opened first. Specifically: (1) `find_links` searches the span-f index by I-address — no document handle needed; (2) `follow_link` reads link orgl endpoints and returns a SpecSet — no target document handle needed; (3) `retrieve_contents` resolves the SpecSet's V→I mappings within the target document — requires the target document to be open. This means a caller can discover and follow a link successfully, then fail to read the content it points to.

**Why it matters for spec**: The formal model of link traversal must specify that `follow_link` produces a deferred reference (SpecSet) whose resolution has a precondition. The spec should document the three-phase traversal pattern: discover (index-only) → follow (metadata-only) → resolve (content, requires open document). Any verification of link traversal completeness must include the open-document precondition on the resolve step. This is protocol-correct behavior — the FEBE protocol assumes the caller manages document lifecycle.

**Code references**:
- `find_links` — searches span-f by I-address, no `findorgl` call
- `follow_link` — reads link orgl endpoint spans, returns SpecSet
- `retrieve_contents` → `doretrievev` → `specset2ispanset` → `findorgl` — requires open document

**Concrete example**:
```
Setup:
  doc_A has text content and a link L
  doc_B transcludes content from doc_A
  doc_A is closed, doc_B is open

Step 1: find_links(doc_B, text_span) → finds link L (via I-address in span-f) ✓
Step 2: follow_link(L, LINK_SOURCE) → returns SpecSet S referencing doc_A ✓
Step 3: retrieve_contents(S) → FAILS (doc_A not open) ✗

Workaround:
  open_document(doc_A)
  retrieve_contents(S) → succeeds ✓
```

**Provenance**: Finding 0027b
