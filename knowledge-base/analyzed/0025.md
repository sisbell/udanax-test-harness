# Finding 0025 Analysis

## Entries

### SS-LINK-HOME-DOCUMENT
**What happens**: Every link has a "home document" — the first parameter to `create_link(home_doc, source_specs, target_specs, type_specs)`. The home document determines where the link's address is allocated. A link created with home document `1.1.0.1.0.1` receives an ID like `1.1.0.1.0.1.0.2.1`, where the link address is a child of the home document address. Multiple links created in the same home document get sequential suffixes under that document's address space.

The home document is distinct from the source document — a link's home document need not be the document containing the link's source endpoint.

Address structure:
```
1.1.0.1.0.1.0.2.1
└─────┬────┘ └┬┘
  home doc   link suffix
```

**Why it matters for spec**: The link state structure should be extended: `Link = (home: DocId, source: set<ContentId>, target: set<ContentId>, type: Tumbler)` where `address(link)` is allocated under `home`. This is a structural property: `forall link : Link :: contains(link.home, address(link))`. The home document is the owner/container of the link for allocation purposes, independent of where the link's endpoints point.

**Code references**: Test `links/find_links_filter_by_homedocid`; `do1.c:199-225` — `docreatelink()` takes home document as first parameter.

**Concrete example**:
| Link | Home Doc | Source Doc | Link ID |
|------|----------|------------|---------|
| Link1 | `1.1.0.1.0.1` | `1.1.0.1.0.1` | `1.1.0.1.0.1.0.2.1` |
| Link2 | `1.1.0.1.0.2` | `1.1.0.1.0.2` | `1.1.0.1.0.2.0.2.1` |
| Link3 | `1.1.0.1.0.1` | `1.1.0.1.0.1` | `1.1.0.1.0.1.0.2.2` |

Links 1 and 3 share home doc `1.1.0.1.0.1` and get sequential suffixes `.0.2.1` and `.0.2.2` under it. Link2 has a different home doc and gets `.0.2.1` under that document's space.

**Provenance**: Finding 0025

### ST-ADDRESS-ALLOC
**What happens**: Link address allocation follows the same hierarchical allocation pattern as document addresses. When a link is created with a given home document, its address is allocated as the next available child under that home document's address. The first link under a home document gets suffix `.0.2.1`, subsequent links get `.0.2.2`, `.0.2.3`, etc. This confirms that the general address allocation mechanism (documented for documents under accounts) also governs link allocation under documents.

**Why it matters for spec**: The postcondition for `create_link` includes an address allocation step: `address(new_link) = next_child(home_doc, link_subspace)`. This unifies link and document allocation under the same allocation model — the allocator is agnostic to what kind of entity is being allocated; it only cares about the parent address and the allocation depth.

**Code references**: Test `links/find_links_filter_by_homedocid`; `granf2.c:findisatoinsertnonmolecule` for the general allocation mechanism.

**Provenance**: Finding 0025

### PRE-FIND-LINKS
**What happens**: The `find_links` operation accepts a `homedocids` filter parameter. This parameter must be passed as I-spans (identity spans with start address + width), not as plain addresses. Passing a plain address causes a protocol hang. This is consistent with other query mechanisms in Xanadu — all filtering uses span-based specifications.

Correct usage:
```python
home_span = Span(doc_address, Offset(0, 1))
results = session.find_links(source_specs, NOSPECS, NOSPECS, [home_span])
```

**Why it matters for spec**: The precondition for `find_links` with home document filtering requires: `forall spec ∈ homedocids :: spec is ISpan`. This is a type constraint on the query interface. The spec should model query filters uniformly as span-based specifications rather than bare addresses.

**Code references**: Test `links/find_links_filter_by_homedocid`; `do1.c:386-391` — `dofindlinksfromtothree()`.

**Provenance**: Finding 0025

### EC-HOMEDOCIDS-FILTER-BROKEN
**What happens**: The `homedocids` filter parameter in `find_links` has no observable effect. When filtering by a specific home document, all links are returned regardless of their home document, producing the same results as an unfiltered query. The filter is accepted without error but does not constrain the result set.

**Why it matters for spec**: This is a known deviation between intended and actual behavior (Bug 0015). The spec should define the intended semantics: `find_links(homedocids=H) = {link ∈ all_links | link.home ∈ H ∧ matches(link, other_filters)}`. The current implementation violates this — it returns all matching links regardless of home document. This distinction matters for verification: the spec captures intended behavior, and this bug is a known non-conformance.

**Code references**: Bug 0015; tests `links/find_links_filter_by_homedocid`, `links/find_links_homedocids_multiple`, `links/find_links_homedocids_no_match`.

**Provenance**: Finding 0025
