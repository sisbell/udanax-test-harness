# Finding 0035 Analysis

## Entries

### SS-VSPAN-VS-VSPANSET
**What happens:** Two distinct operations retrieve document extent in V-space. RETRIEVEDOCVSPAN (opcode 14) reads the raw root node's V-dimension displacement and width directly via `retrievevspanpm()` — no processing, no subspace awareness. RETRIEVEDOCVSPANSET (opcode 1) uses `retrievevspansetpm()` which tests `is1story()` to detect whether content spans multiple subspaces. For text-only documents both return the same single span. For documents containing links, RETRIEVEDOCVSPAN returns a meaningless bounding-box width spanning both 0.x and 1.x subspaces, while RETRIEVEDOCVSPANSET correctly decomposes into separate link-subspace and text-subspace spans.

**Why it matters for spec:** The state model must distinguish between raw root extent (an internal structural value) and semantic document extent (a set of per-subspace spans). Specs should use RETRIEVEDOCVSPANSET semantics for document extent queries. RETRIEVEDOCVSPAN's output is not a valid V-span for documents containing links — it violates the subspace convention.

**Code references:**
- `retrievevspanpm()`: `backend/orglinks.c:165-172` — raw root copy
- `retrievevspansetpm()`: `backend/orglinks.c:173-221` — subspace-aware extraction
- `is1story()`: `backend/tumble.c:237-247` — checks single-subspace width
- `maxtextwid()`: `backend/orglinks.c:224-245` — recursive text-extent traversal

**Concrete example:**
- Document with 10 chars of text and 1 link:
  - RETRIEVEDOCVSPAN returns: `1.1 for 1.2` (meaningless bounding box, Bug 0011)
  - RETRIEVEDOCVSPANSET returns: `[{0, 0.1}, {1, 1}]` (correct: link subspace + text subspace)
- Text-only "Hello World": both return `1.1 for 0.11`
- Empty document: RETRIEVEDOCVSPAN returns zeros; RETRIEVEDOCVSPANSET returns NULL (empty set)

**Provenance:** Finding 0035 (sections 1-2)

### ST-RETRIEVE-ENDSETS
**What happens:** RETRIEVEENDSETS (opcode 28) takes a specset (V-spec of a content region) and returns three specsets simultaneously: from-endset, to-endset, and three-endset. It works through the spanfilade, not the link orgl. The call chain: `retrieveendsetsfromspanf()` converts the input specset to a sporglset (V-to-I translation), defines three search spaces using ORGLRANGE prefixes (LINKFROMSPAN=1, LINKTOSPAN=2, LINKTHREESPAN=3), then for each endset type calls `retrievesporglsetinrange()` which searches the spanfilade with SPANRANGE and ORGLRANGE restrictions.

**Why it matters for spec:** RETRIEVEENDSETS is fundamentally different from FOLLOWLINK. FOLLOWLINK takes a known link ID and reads one endset from the link's orgl. RETRIEVEENDSETS searches by content identity through the spanfilade, discovering all link endpoints that intersect a content region. This is the content-identity-based link discovery mechanism — links are discoverable from any document sharing content identity (transclusion, versioning). The three-endset is conditionally retrieved (only if requested).

**Code references:**
- `retrieveendsetsfromspanf()`: `backend/spanf1.c:190-235`
- `specset2sporglset()`: converts V-addresses to I-addresses
- `linksporglset2specset()`: converts I-addresses back to V-specs using querying document's docid

**Concrete example:**
- Input: specset describing a text region in document D1
- Output: three specsets — from-endset (links whose from-end intersects the region), to-endset (links whose to-end intersects), three-endset (links whose three-end intersects)
- Key: endsets are resolved in terms of the querying document's V-space, not the link's home document

| Aspect | FOLLOWLINK | RETRIEVEENDSETS |
|--------|-----------|-----------------|
| Input | link ISA + which-end | specset (content region) |
| Lookup | link orgl direct | spanfilade search |
| Returns | one endset | all three endsets |
| Resolution | link's perspective | querying document's perspective |

**Provenance:** Finding 0035 (section 3)

### ST-FIND-LINKS
**What happens:** FINDNUMOFLINKSFROMTOTHREE (opcode 29) is a trivial wrapper around FINDLINKSFROMTOTHREE. It calls `findlinksfromtothreesp()` to materialize the complete linked list of matching links, then walks the list counting elements. There is no count-only optimization — the full search executes (V-to-I translation, spanfilade search per endset, intersection of result sets), then the list is linearly counted.

**Why it matters for spec:** For formal specification, FINDNUMOFLINKSFROMTOTHREE has identical preconditions and search semantics to FINDLINKSFROMTOTHREE. Its postcondition is simply `|result| = count` where `result` is the set FINDLINKSFROMTOTHREE would return. No additional state transitions or side effects. Both operations are disabled in safe mode (`init.c:75`).

**Code references:**
- `findnumoflinksfromtothreesp()`: `backend/spanf1.c:105-115` — calls full search then counts
- `findlinksfromtothreesp()`: shared search implementation
- `intersectlinksets()`: `backend/spanf2.c:46-120` — O(n*m) or O(n*m*p) intersection
- Safe mode disable: `backend/init.c:75`

**Provenance:** Finding 0035 (section 4)

### ST-PAGINATE-LINKS
**What happens:** FINDNEXTNLINKSFROMTOTHREE (opcode 31) implements stateless cursor-based pagination over link search results. On each call it: (1) re-executes the full `findlinksfromtothreesp()` search, (2) if cursor is zero-tumbler, starts from beginning; otherwise linearly scans the result list for an exact tumbler match, (3) if cursor not found, returns empty set with count=0, (4) destructively truncates the list at N items by setting `linkset->next = NULL`.

**Why it matters for spec:** The pagination cursor is a link ISA tumbler, not a positional offset. This means: if the cursor link is deleted between calls, the cursor becomes invalid and an empty result is returned (not an error). The operation is stateless — no server-side cursor state persists between calls. The page size parameter is input/output: input is requested size, output is actual count returned. For specification, the postcondition is: `result = take(N, dropUntilAfter(cursor, fullSearchResult))` where `fullSearchResult` is identical to what FINDLINKSFROMTOTHREE would return. Disabled in safe mode (`init.c:76`).

**Code references:**
- `findnextnlinksfromtothreesp()`: `backend/spanf1.c:117-149`
- Cursor check: `iszerotumbler()` at line 126
- Cursor walk: linear scan with `tumblereq()` match
- Destructive truncation: `linkset->next = NULL` at the N-th item
- Safe mode disable: `backend/init.c:76`

**Concrete example:**
- Full search returns links [L1, L2, L3, L4, L5], cursor=L2, N=2
- Result: [L3, L4], actual count=2
- If cursor=L_deleted (not in result set): returns [], count=0
- If cursor=zero: returns [L1, L2], count=2

**Provenance:** Finding 0035 (section 5)

### EC-VSPAN-MISLEADING-SIZE
**What happens:** RETRIEVEDOCVSPAN returns a raw bounding-box width for documents containing links. For a document with 10 chars of text and 1 link, it returns `1.1 for 1.2` — a width that spans both the link subspace (0.x) and text subspace (1.x). This value is neither the text extent nor the link extent; it is the root node's V-dimension width, an internal structural artifact.

**Why it matters for spec:** A precondition for any spec relying on document extent must specify which operation was used. RETRIEVEDOCVSPAN's output violates the subspace convention for mixed-content documents. The spec should mark this operation as producing a raw structural value, not a semantically meaningful V-span.

**Code references:**
- `retrievevspanpm()`: `backend/orglinks.c:165-172`
- `retrievedocumentpartofvspanpm()`: `backend/orglinks.c:155-162` — identical "kluge" twin

**Provenance:** Finding 0035 (section 1), Bug 0011

### EC-CURSOR-INVALIDATION
**What happens:** In FINDNEXTNLINKSFROMTOTHREE, if the cursor link ISA no longer appears in the search results (e.g., because the link was deleted between paginated calls), the cursor walk falls off the end of the list and returns an empty set with count=0. This is not an error condition — it returns TRUE with an empty result.

**Why it matters for spec:** The pagination mechanism has no stable cursor guarantee. Between calls, link creation or deletion can change the result set, causing: missed links, duplicate links, or cursor invalidation. The spec must model pagination as a snapshot-less stateless query — each call is independent with no consistency guarantees across calls.

**Code references:**
- Cursor walk: `backend/spanf1.c:130-136` — if `tumblereq` never matches, `linkset` becomes NULL
- Empty result path: `backend/spanf1.c:138-141` — sets `*nextlinksetptr = NULL`, `*nptr = 0`

**Provenance:** Finding 0035 (section 5)

### INT-SPORGL-LINK-INDEX
**What happens:** RETRIEVEENDSETS discovers links through the spanfilade by searching with ORGLRANGE dimension prefixes. The three link endset types are indexed as separate ORGLRANGE subspaces: LINKFROMSPAN=1, LINKTOSPAN=2, LINKTHREESPAN=3. The specset input is converted to I-addresses (sporglset) for the SPANRANGE restriction, then each endset type is searched independently by restricting the ORGLRANGE dimension. Results are converted back to V-addresses using the querying document's docid.

**Why it matters for spec:** This reveals how the spanfilade serves as a content-identity-based link index. The same spanfilade search mechanism that supports FINDLINKSFROMTOTHREE also supports RETRIEVEENDSETS, but with different input (V-spec region vs. from/to/three constraints) and different output (resolved endset specs vs. link ISAs). The use of the querying document's docid for V-address resolution means endsets are always expressed relative to the querying context, not the link's home.

**Code references:**
- ORGLRANGE subspace definitions: `backend/spanf1.c:190-235`
- `retrievesporglsetinrange()`: spanfilade search with dual range restriction
- `linksporglset2specset()`: I-to-V conversion using querying document's docid

**Provenance:** Finding 0035 (section 3)
