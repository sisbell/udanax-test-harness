# Finding 0011 Analysis

## Entries

### PRE-INSERT
**What happens:** Preconditions for operations like insert, copy, and rearrange are implicit conventions, not enforced at runtime. The `acceptablevsa` function in `do2.c:110-113` always returns `TRUE`, meaning any V-position is accepted regardless of whether it follows the subspace convention (0.x for links, 1.x for text). Callers must know and follow the convention; the system does not validate.

**Why it matters for spec:** Formal preconditions must be explicitly stated in the specification even though the implementation does not enforce them. Every operation that accepts a V-position has an implicit precondition that the V-position falls within the appropriate subspace for the data type being stored. Dafny `requires` clauses must capture what the C code merely assumes.

**Code references:**
- `backend/green/do2.c:110-113` — `acceptablevsa` always returns TRUE
- Caller conventions for `docopy`, insert operations

**Concrete example:**
- Before: System receives a store operation with V-position `0.1.5` and text content
- Expected: Validation rejects (0.x is link subspace, not text)
- Actual: Operation succeeds silently, placing text in the link subspace, corrupting the document's semantic structure

**Provenance:** Finding 0011

### INV-SUBSPACE-CONVENTION
**What happens:** The subspace convention (V-position 0.x = links, 1.x = text) is a social contract enforced by convention, not by runtime checks. The unified enfilade storage treats all data uniformly — the system does not distinguish between link I-addresses and content I-addresses at the type level. Both are just tumblers. Dereferencing a link ISA as content produces garbage, but no error is raised.

**Why it matters for spec:** The formal specification must model subspace membership as a type-level distinction even though the implementation uses untyped tumblers. This invariant — that data at 0.x V-positions are links and data at 1.x V-positions are text — must be stated as a global invariant in the spec. Every operation that reads or writes V-positions should preserve this invariant. The spec makes explicit what the code leaves implicit.

**Code references:**
- `backend/green/do2.c:110-113` — `acceptablevsa` does not enforce subspace rules
- `specset2ispanset` and `ispanset2vstuffset` treat all I-addresses uniformly

**Provenance:** Finding 0011

### EC-ERROR-ABORT
**What happens:** When implicit contracts are violated, the system's error handling is to crash immediately via `qerror`/`abort` in `genf.c:546`. There is no recovery path, no error return, and no graceful degradation. Violations of conventions produce fatal aborts rather than error codes or exceptions.

**Why it matters for spec:** This establishes that the implementation treats precondition violations as undefined behavior terminated by abort. For specification purposes, this confirms that preconditions are hard requirements: violating them does not produce a defined error state, it produces program termination. The spec should model precondition violations as operations that are simply not defined, matching the implementation's "crash on invalid" behavior.

**Code references:**
- `backend/green/genf.c:546` — `qerror` calls `fprintf` then `abort()`

**Concrete example:**
- Before: Operation encounters an invalid internal state (null pointer, unexpected data type)
- After: Process terminates via `abort()` with a message to stderr. No state is returned. No partial result.

**Provenance:** Finding 0011

### PRE-COMPARE-VERSIONS
**What happens:** `compare_versions` assumes its inputs follow conventions — specifically that V-spans are in the text subspace. When link-subspace spans are passed (violating the convention), the operation crashes (Bug 0009). This is a direct consequence of the convention-over-enforcement philosophy: the operation has an implicit precondition that inputs are text-subspace spans.

**Why it matters for spec:** The precondition for `compare_versions` must explicitly require that input V-spans are in the text subspace (V-position 1.x). This precondition is not checked at runtime but is necessary for correct behavior.

**Code references:**
- Bug 0009 — crash when compare_versions receives link-subspace spans
- `correspond.c` — iteration assumes text-subspace data layout

**Provenance:** Finding 0011

### SS-DUAL-ENFILADE
**What happens:** The enfilade storage is unified — a single data structure stores both text content and links. V-position subspace (0.x vs 1.x) is the only discriminator, and it is a convention, not a type. I-addresses likewise have no type distinction: permascroll I-addresses (content) and document ISAs (references) are both tumblers with no runtime type tag.

**Why it matters for spec:** The specification must introduce type distinctions that the implementation lacks. The dual-enfilade model should formally distinguish between content-bearing I-addresses and reference I-addresses, and between link V-spans and text V-spans, even though the implementation represents all of these as untyped tumblers. This is the central modeling challenge: adding types to a typeless system.

**Code references:**
- `do2.c:110-113` — `acceptablevsa` does not discriminate
- `specset2ispanset` — uniform I-address handling
- `ispanset2vstuffset` — assumes I-addresses are permascroll content

**Provenance:** Finding 0011
