# Finding 0078 Analysis

## Entries

### INV-RETRIEVAL-V-SORTED

**What happens:** `incontextlistnd()` performs explicit insertion-sort by V-address as contexts are discovered during B-tree traversal. Each leaf node found by `findcbcinarea2d()` is inserted into a linked list at the position that maintains ascending order of `totaloffset.dsas[index]` (the left boundary in the specified dimension). The algorithm has four cases: (1) first insertion, (2) insert before head if new context precedes it, (3) insert between two adjacent contexts when the new context falls between their left boundaries, (4) append to end. The comparison uses `whereoncontext()` which computes the interval `[left, right)` for each context and calls `intervalcmp()` to classify the new address relative to that interval.

**Why it matters for spec:** This establishes a postcondition on all retrieval operations that use `incontextlistnd`: the result list is sorted by left boundary in the queried dimension. Formally:

```
forall poom : POOM, ispan : ISpan, index : Dimension ::
  let contexts = ispan2vspanset(poom, ispan, index) in
  forall j, k :: 0 <= j < k < |contexts| ==>
    contexts[j].totaloffset.dsas[index] <= contexts[k].totaloffset.dsas[index]
```

This ordering is **independent of tree structure** — it holds regardless of insertion order, split/rebalance operations, or diagonal ordering in 2D enfilades. The Dafny spec should include this as a postcondition on `ispan2vspanset` and all operations that return V-span results (Q3 compare_versions, Q6/Q7 findlinks, Q8 finddocscontaining).

**Code references:**
- `context.c:75-111` — `incontextlistnd()` insertion-sort implementation
- `context.c:124-149` — `whereoncontext()` computes interval and classifies address position
- `retrie.c:401-418` — `intervalcmp()` returns TOMYLEFT/ONMYLEFTBORDER/THRUME/ONMYRIGHTBORDER/TOMYRIGHT
- `retrie.c:229-268` — `findcbcinarea2d()` traverses B-tree left-to-right, calls `incontextlistnd` per leaf

**Concrete example:**
```
POOM B-tree contains contexts for V-positions 1.10, 1.30, 1.20, 1.40
(tree sibling order reflects insertion order, not V-address order)

Tree traversal discovers them in tree order:
  Context(V=1.10) → Context(V=1.30) → Context(V=1.20) → Context(V=1.40)

incontextlistnd insertion-sort produces:
  Context(V=1.10) → Context(V=1.20) → Context(V=1.30) → Context(V=1.40)

Result is V-sorted regardless of tree structure.
```

**Provenance:** Finding 0078

### SS-CONTEXT-LIST

**What happens:** Contexts discovered during B-tree retrieval are accumulated into a singly-linked list via `nextcontext` pointers. Two distinct accumulation strategies exist: `incontextlistnd()` maintains sorted order by insertion-sort (used for N-dimensional enfilades where tree order does not guarantee V-order), and `oncontextlistseq()` appends to the end preserving tree traversal order (used for 1D GRAN enfilades where sequential order is maintained by tree structure). The choice of accumulation function depends on the enfilade type being queried.

**Why it matters for spec:** The formal model needs two distinct list-building strategies. For POOM (2D) queries, the result type is `SortedSeq<Context>` with the V-sorted invariant. For GRAN (1D) queries, the result type is `Seq<Context>` where order reflects tree traversal. This distinction matters because GRAN tree structure preserves sequential order (by design of 1D enfilades), while POOM tree structure does not preserve V-order (due to 2D diagonal ordering per Finding 0071). The spec should not assume a single uniform ordering guarantee across all enfilade types.

**Code references:**
- `context.c:75-111` — `incontextlistnd()` sorted insertion for N-dimensional enfilades
- `context.c:113-123` — `oncontextlistseq()` sequential append for 1D enfilades

**Provenance:** Finding 0078

### FC-RETRIEVAL-TREE-INDEPENDENCE

**What happens:** The V-ordering of retrieval results is independent of the internal B-tree structure. Even if split/rebalance operations (Finding 0071) or out-of-order insertions (Finding 0041) produce a tree where sibling order does not match V-address order, the `incontextlistnd` insertion-sort re-establishes V-ordering during retrieval. Tree structure affects storage and traversal efficiency, but not the ordering of results.

**Why it matters for spec:** This is a frame condition: tree-internal reorganization (splits, rebalances, rotations) does not change the observable result ordering of retrieval operations. The formal spec can abstract away tree structure entirely for correctness proofs — the sorted-result postcondition holds for any tree that stores the same set of `(V-position, I-address)` entries. This simplifies verification: one need only prove that `incontextlistnd` produces a sorted list from any input order, not that the tree itself maintains any particular sibling ordering.

**Code references:**
- `context.c:75-111` — `incontextlistnd()` sorts independently of discovery order
- `retrie.c:252-265` — `findcbcinarea2d()` traverses left-to-right via `getrightbro`, but this order is not guaranteed to be V-sorted

**Provenance:** Finding 0078
