# Finding 0015 Analysis

## Entries

### SS-CONTENT-IDENTITY

**What happens**: "Common origin" in the context of `compare_versions` means shared **permascroll content identity** — I-addresses that point to immutable characters in the global permascroll. Link orgl ISAs are unique object identities, not content origins. Two documents cannot "share" a link ISA via transclusion because each link is a distinct object. The finding makes explicit that the I-address space has two non-comparable sorts: permascroll addresses (content-bearing, shareable) and link orgl ISAs (identity-bearing, unique).

**Why it matters for spec**: The formal model must distinguish these two I-address sorts. A function `ContentOrigin(doc, span) -> Option<IAddressRange>` returns `Some(ispan)` only for text subspace spans (`V >= 1.0`) and `None` for link subspace spans. I-span intersection — the core of `compare_versions` — is only defined over permascroll addresses. The spec needs a predicate `IsPermascrollAddress(iaddr)` that partitions the I-address space.

**Code references**:
- `correspond.c` — performs I-span intersection without distinguishing address types
- `orglinks.c:389-422` — `permute()` converts V↔I without type metadata

**Provenance**: Finding 0015, also Finding 0009

### PRE-COMPARE-VERSIONS

**What happens**: The `compare_versions` operation requires that input V-span sets be restricted to the text subspace (`V >= 1.0`). The finding specifies a concrete missing step: between retrieving V-spans and converting them to I-spans, the implementation must **filter to text subspace only**. Without this filter, link subspace V-spans (`0.x`) produce link orgl ISAs that are in a different address space from permascroll I-addresses. These will never intersect with text I-addresses (correct) but the code paths in `correspond.c` do not handle empty intersections gracefully (crash).

The finding frames this not as a defensive workaround but as the **semantically correct behavior**: the operation is defined over text content with common origin, and links have no "common origin" in this sense.

**Why it matters for spec**: The precondition can be expressed two equivalent ways: (a) `requires forall span :: span in input_vspanset ==> span.start >= V_TEXT_START`, placing the obligation on the caller; or (b) the operation's first step is `vspanset = filter_to_text_subspace(vspanset)`, internalizing the constraint. The finding argues for (b) — filtering is part of the operation's definition, not an external precondition.

**Code references**:
- `correspond.c` — retrieves ALL V-spans including `0.x`, no filtering step before `vspanset2ispanset`

**Concrete example**:
```dafny
method CompareVersions(doc_a: DocumentId, doc_b: DocumentId)
  requires ValidDocument(doc_a) && ValidDocument(doc_b)
  returns (correspondences: seq<(VSpan, VSpan)>)
  ensures forall (span_a, span_b) in correspondences ::
    span_a.start >= V_TEXT_START &&
    span_b.start >= V_TEXT_START &&
    ContentOrigin(doc_a, span_a) == ContentOrigin(doc_b, span_b)
```

Correct algorithm:
1. Retrieve V-spans from both documents (current behavior)
2. **Filter to text subspace only (V >= 1)** (missing step)
3. Convert V-spans to I-spans (current behavior)
4. Find common I-addresses (current behavior)
5. Map back to V-spans in each document (current behavior)

**Provenance**: Finding 0015, also Finding 0009

### ST-COMPARE-VERSIONS

**What happens**: The `compare_versions` operation (FEBE opcode 10: SHOWRELATIONOF2VERSIONS) answers the question: "What text content do these two documents share by common origin?" The operation produces a list of ordered pairs of V-spans — one from each document — where the paired spans reference the same permascroll I-address range. The semantic definition is: two spans correspond if and only if they map to the same permascroll content identities.

**Why it matters for spec**: This is the postcondition for `compare_versions`. Each pair `(span_a, span_b)` in the result satisfies: `VSpanToISpan(doc_a, span_a) == VSpanToISpan(doc_b, span_b)` where both I-spans are permascroll addresses. The result is complete: every shared permascroll address range appears in exactly one pair. The result covers only text content — link references are excluded by definition, not by accident.

**Code references**:
- `correspond.c` — nested loop computing I-span intersections and mapping back to V-spans

**Concrete example**:
```
Document A: "Hello World" (text at V 1.1..1.11, permascroll I-addrs P₁..P₁₁)
Document B: version of A, then insert "Dear " at position 6
  → "Hello Dear World" (V 1.1..1.16)
  → "Hello" has permascroll I-addrs P₁..P₅, "World" has P₆..P₁₁

compare_versions(A, B) returns:
  [(A: V 1.1 for 5, B: V 1.1 for 5),     // "Hello" — same P₁..P₅
   (A: V 1.6 for 6, B: V 1.11 for 6)]    // "World" — same P₆..P₁₁
```

**Provenance**: Finding 0015

### INV-SUBSPACE-CONVENTION

**What happens**: The finding provides a decision table confirming the subspace convention's implications for `compare_versions`:

| V-Position | Contains | I-Address Type | Has "Common Origin"? | Included in compare_versions? |
|------------|----------|----------------|---------------------|-------------------------------|
| 0.x | Link references | Link orgl ISAs | No | No |
| 1.x | Text content | Permascroll addresses | Yes | Yes |

Links have no "common origin" for three reasons: (1) link ISAs are unique identities, not content origins — two documents cannot share the same link ISA via transclusion; (2) links are metadata about content, not content itself; (3) comparing link ISAs is semantically undefined — even if they matched, it wouldn't mean "shared content."

**Why it matters for spec**: This strengthens the subspace convention invariant with a semantic justification: the link/text partition is not merely a storage convention but reflects a fundamental type distinction. Operations defined over "content with common origin" (compare_versions, and potentially others) must be restricted to the text subspace by definition, not by workaround.

**Code references**:
- `correspond.c` — does not implement subspace filtering
- `do1.c:199-225` — `docreatelink()` creates unique link ISAs (non-shareable)

**Provenance**: Finding 0015, also Finding 0009
