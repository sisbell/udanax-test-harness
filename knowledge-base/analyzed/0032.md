# Finding 0032 Analysis

## Entries

### SS-VERSION-ADDRESS

**What happens:** Version addresses are structurally subordinate to the source document's address, forming a parent-child hierarchy. Original at `1.1.0.1.0.1` produces version at `1.1.0.1.0.1.1`, and a version of that version at `1.1.0.1.0.1.1.1`. This contrasts with CREATEDOCUMENT + COPY, which produces sibling addresses (e.g., `1.1.0.1.0.1` and `1.1.0.1.0.2`). The address hierarchy is the structural signal that distinguishes a "version" relationship from an independent copy.

**Why it matters for spec:** The spec must distinguish two copy mechanisms by their address-allocation rule: `version_address(doc) = doc.address ++ child_component` (subordinate) vs `new_doc_address(session) = session.next_sibling()` (sibling). This is the only structural difference — both produce documents with shared I-addresses. The address hierarchy enables version-chain traversal without additional metadata.

**Code references:** `backend/do1.c:docreatenewversion` — calls `createorglingranf` with a hint derived from the source document's granf, producing a child address. Address structure confirmed in `golden/versions/version_chain.json`.

**Concrete example:**
```
Original:          1.1.0.1.0.1
Version:           1.1.0.1.0.1.1       (child)
Version of version: 1.1.0.1.0.1.1.1    (grandchild)

Separate doc+copy: 1.1.0.1.0.2         (sibling)
```

**Provenance:** Finding 0032

### ST-VERSION-CREATE

**What happens:** CREATENEWVERSION (command 13) is an atomic operation that creates a new document and copies all content in a single call. Internally, `docreatenewversion` performs three steps: (1) allocate a new orgl under the source's address space via `createorglingranf`, (2) retrieve the source document's full vspanset via `doretrievedocvspanfoo`, (3) copy all content preserving I-addresses via `docopyinternal`. The documented "OPENCOPY" command does not exist in the implementation — CREATENEWVERSION is its functional replacement.

**Why it matters for spec:** The version-create operation has a single-step atomicity guarantee: there is no observable intermediate state where the version exists but has no content. The precondition is simply that the source document exists (even empty documents can be versioned). The postcondition is: `references(new_version) = references(source)` with the new version at a child address. This atomicity distinguishes it from the two-step CREATEDOCUMENT + COPY sequence, which has an observable intermediate state (empty document exists).

**Code references:** `backend/do1.c:docreatenewversion` — full implementation. `backend/requests.h` — defines `CREATENEWVERSION 13`, no OPENCOPY defined. `backend/init.c:requestfns` — command dispatch table confirms OPENCOPY absent.

**Concrete example:**
```
Before: doc at 1.1.0.1.0.1 contains "Hello world" (I-addresses α₁..α₁₁)
CREATENEWVERSION(doc) →
After:  version at 1.1.0.1.0.1.1 contains "Hello world" (same I-addresses α₁..α₁₁)
        No intermediate state observable
```

**Provenance:** Finding 0032

### INV-ATOMICITY

**What happens:** CREATENEWVERSION is atomic — the new document and its content appear together. There is no window where the version document exists without its content. This follows from the implementation: `docreatenewversion` creates the orgl, retrieves the source vspanset, and copies content in a single request handler invocation before returning the new address.

**Why it matters for spec:** The spec should model version-create as an atomic state transition: `state' = state[new_addr -> copy_refs(state[source_addr])]`. The two-step alternative (CREATEDOCUMENT then COPY) does NOT have this atomicity — the intermediate state with an empty document is observable. This matters for any invariant that depends on document non-emptiness or content-presence after creation.

**Code references:** `backend/do1.c:docreatenewversion` — single function, no intermediate return points between orgl creation and content copy.

**Provenance:** Finding 0032

### INT-VERSION-TRANSCLUSION

**What happens:** When a document contains transcluded content (shared I-addresses from another document via COPY), creating a version preserves those transclusion relationships. The version shares the same I-addresses as the original, including any that originated from third-party documents. `compare_versions` between the version and the third-party source correctly reports shared content.

**Why it matters for spec:** This follows from ST-VERSION-CREATE's postcondition (`references(version) = references(source)`) combined with INV-TRANSITIVE-IDENTITY. No special transclusion-preservation rule is needed — it is a consequence of copying I-address references rather than content. The spec should verify: `forall iaddr in references(source) :: iaddr in references(version)`, which automatically covers transcluded I-addresses.

**Code references:** Test `golden/versions/version_preserves_transclusion.json`.

**Concrete example:**
```
Doc A: "Hello"          (I-addresses α₁..α₅)
Doc B: "Hello world"    (α₁..α₅ from copy of A, plus β₁..β₆ new)
Version of B: "Hello world"  (same α₁..α₅ and β₁..β₆)

compare(Version_of_B, A) → "Hello" shared (via α₁..α₅)
```

**Provenance:** Finding 0032

### INT-LINK-VERSION

**What happens:** Links are discoverable from versions because link lookup is indexed by I-address, and versions share I-addresses with their source. Calling `find_links` on a version returns the same link objects as calling it on the original document. The links themselves are not copied — the version simply inherits link visibility through shared content identity.

**Why it matters for spec:** This is a consequence of the link-discovery rule (`find_links(specset)` returns links whose endpoints intersect the specset's I-addresses) combined with ST-VERSION-CREATE. No version-specific link rule is needed. The spec should verify: `find_links(version) = find_links(source)` at creation time, diverging only as edits create new I-addresses in either document.

**Code references:** Test `golden/versions/version_with_links.json`.

**Concrete example:**
```
Source: "Click here" with link on "here" (I-addresses γ₃..γ₆)
Version of Source: "Click here" (same I-addresses γ₃..γ₆)

find_links(Source)  → [link₁]
find_links(Version) → [link₁]  (same link, via shared I-addresses)
```

**Provenance:** Finding 0032
