# Finding 0057 Analysis

## Entries

### INV-SPANF-WRITE-ONLY

**What happens:** The spanfilade is a write-only (append-only) index. Entries are added by `insertspanf` during COPY and INSERT operations, but no deletion function exists anywhere in the spanf codebase. Inspection of `spanf1.c` and `spanf2.c` reveals `insertspanf`, `findlinksfromtothreesp`, `retrieveendsetsfromspanf`, `finddocscontainingsp`, and `findnumoflinksfromtothreesp` — all insertion and query functions. No `deletespanf`, `removespanf`, or any removal mechanism exists. This applies to both DOCISPAN entries (content indexing) and link endset entries (link indexing).

**Why it matters for spec:** This is a structural invariant of the spanfilade: `∀ t₁ < t₂ : spanf_entries(t₁) ⊆ spanf_entries(t₂)`. The set of spanfilade entries is monotonically non-decreasing. No operation in the system can remove a spanfilade entry. This means the spanfilade is not a current-state index but a historical journal of all content placements that have ever occurred. Combined with INV-SPANF-GROWTH (Finding 0047), the growth bound becomes permanent: every DOCISPAN entry ever created persists indefinitely.

**Code references:**
- `backend/spanf1.c` — `insertspanf` exists; no delete function exists in entire file
- `backend/spanf2.c` — query functions only; no delete function exists in entire file
- `backend/do1.c:162-171` — `dodeletevspan` has no call to any spanf removal function

**Provenance:** Finding 0057

### ST-DELETE

**What happens:** DELETE (`dodeletevspan`) removes the V-to-I mapping from the document's POOM via `deletevspanpm` → `deletend`, but does NOT remove the corresponding spanfilade entry created by the original COPY/INSERT. The spanfilade continues to assert that the document contains I-addresses that the document's POOM no longer maps. Specifically, `deletevspanpm` calls only `deletend` on the document's orgl in granf and `logbertmodified` — there is no call to any spanf function.

**Why it matters for spec:** Extends ST-DELETE postcondition with an explicit frame condition on spanf: `delete(D, vspan) ⟹ spanf_entries_after = spanf_entries_before`. DELETE modifies only the POOM (granf layer) — the spanfilade is completely untouched. This means the postcondition of DELETE includes: (1) V-to-I mapping removed from POOM, (2) spanf unchanged. The formal model must track POOM state and spanf state independently, as they can diverge after DELETE.

**Concrete example:**
```
Before:
  POOM(D): v₁ → i₁  (content visible at position v₁)
  spanf: i₁ → {D}   (D indexed as containing i₁)

After DELETE(D, v₁):
  POOM(D): ∅          (v₁ mapping removed)
  spanf: i₁ → {D}    (UNCHANGED — D still indexed as containing i₁)
```

**Code references:**
- `backend/do1.c:162-171` — `dodeletevspan`: calls `findorgl` + `deletevspanpm`, no spanf call
- `backend/orglinks.c:145-152` — `deletevspanpm`: calls `deletend` (granf only) + `logbertmodified`
- Contrast with `backend/do1.c:45-65` — `docopy`: calls both `insertpm` AND `insertspanf`

**Provenance:** Finding 0057

### EC-STALE-SPANF-REFERENCE

**What happens:** After DELETE removes transcluded content, FIND_DOCUMENTS still returns the document as containing those I-addresses. The document appears in the result because the spanfilade entry persists, but attempting to convert the I-addresses to V-addresses in that document yields empty — the POOM has no mapping. This creates a "ghost reference" in the spanfilade: the index points to a document that no longer contains the content. The same behavior occurs for deleted links (Finding 0024) — the spanfilade retains references to deleted link endsets.

**Why it matters for spec:** FIND_DOCUMENTS returns a **superset** of documents currently containing the queried I-addresses. Formally: `actual_docs(i) ⊆ find_documents(i)` where `actual_docs(i) = {D | ∃ v : poom.D(v) = i}`. The reverse inclusion does NOT hold: `find_documents(i)` may include documents where `¬∃ v : poom.D(v) = i`. Consumers of FIND_DOCUMENTS must post-filter via I-to-V conversion (INV-ITOV-FILTERING from Finding 0048) to distinguish live from stale results.

**Concrete example:**
```
Setup:
  Source doc S has content at I-addresses α₁..α₅
  Target doc T COPYs that content → spanf registers T for α₁..α₅

After DELETE from T:
  FIND_DOCUMENTS(α₁..α₅) → {S, T}   (T is stale)
  I-to-V(α₁, T) → ∅                  (no V-position in T)
  I-to-V(α₁, S) → v₁                 (still live in S)

Multiple transclusions (A, B, C all COPY same content):
  DELETE from B only
  FIND_DOCUMENTS → {S, A, B, C}      (B is stale, no reference counting)
```

**Code references:**
- `backend/spanf1.c` — `finddocscontainingsp` queries spanf, returns stale entries
- `backend/orglinks.c:425-449` — `span2spanset` silently drops I-addresses with no POOM mapping (the post-filter)
- Test scenario: `delete_transcluded_content_spanfilade_cleanup` confirms stale result

**Provenance:** Finding 0057

### INT-DELETE-SPANF-DIVERGENCE

**What happens:** DELETE causes the POOM (granf) and spanfilade (spanf) to diverge. Before DELETE, both layers agree: the POOM says the document maps V-addresses to certain I-addresses, and the spanfilade says the document contains those I-addresses. After DELETE, the POOM no longer contains the mapping, but the spanfilade still claims the document contains those I-addresses. This divergence is permanent — no mechanism exists to reconcile the two layers.

**Why it matters for spec:** The formal model cannot treat spanf as derivable from POOM state. After any DELETE, the system may be in a state where `i ∈ spanf_index(D) ∧ ¬(∃ v : poom.D(v) = i)`. The invariant that holds is weaker than consistency: `∀ D, i : (∃ v : poom.D(v) = i) ⟹ i ∈ spanf_index(D)` (every live reference is indexed), but the converse is false (indexed does not imply live). This asymmetric invariant — spanf is a superset of current POOM associations — is the key structural property the spec must capture.

**Code references:**
- COPY path (both layers updated): `backend/do1.c:45-65` — `insertpm` (granf) + `insertspanf` (spanf)
- DELETE path (only granf updated): `backend/do1.c:162-171` — `deletevspanpm` (granf only)
- Same pattern for links: Creating a link calls `insertendsetsinspanf`; deleting does not clean up (Finding 0024)

**Provenance:** Finding 0057
