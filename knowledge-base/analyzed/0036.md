# Finding 0036 Analysis

## Entries

### SS-DOCISPAN

**What happens:** The spanf enfilade contains a type 4 index called DOCISPAN that maps I-addresses to the documents containing them. This is distinct from the link-search function of the spanf (which maps I-addresses to links). DOCISPAN is a reverse index: given an I-address range, it returns which documents hold content at those addresses, enabling `find_documents` / `FINDDOCSCONTAINING` queries. DOCISPAN entries are created by `insertspanf(taskptr, spanf, docisaptr, ispanset, DOCISPAN)`, where the `DOCISPAN` constant selects the type 4 spanfilade.

**Why it matters for spec:** The state model for `spanf` must include a DOCISPAN component separate from the link index: `SpanEnfilade = { link_index: Map<IAddress, Set<LinkISA>>, docispan: Map<IAddress, Set<DocISA>> }`. The `find_documents` operation queries `docispan`, not the link index. Operations that create DOCISPAN entries must be distinguished from those that don't — this determines which operations make content discoverable.

**Code references:**
- `do1.c:62` — `insertspanf(taskptr, spanf, docisaptr, ispanset, DOCISPAN)` in `docopy()`
- `do1.c:45-65` — `docopy()` full implementation showing DOCISPAN insertion as final step

**Provenance:** Finding 0036.

### ST-INSERT

**What happens:** INSERT creates new content in the granf (via `inserttextingranf`) which returns fresh I-addresses as an `ispanset`, then calls `docopy` with that ispanset. `docopy` places the content into the document's V-stream (via `insertpm`) and creates DOCISPAN entries in the spanf (via `insertspanf(..., DOCISPAN)`). The call chain is: `doinsert` → `inserttextingranf` → `docopy` → `insertpm` + `insertspanf(..., DOCISPAN)`.

**Why it matters for spec:** INSERT postcondition must specify effects on both enfilades:
1. `granf'`: new I-addresses allocated in permascroll; document orgl updated with V→I mapping
2. `spanf'`: new DOCISPAN entries mapping the fresh I-addresses → document ISA

This means INSERT makes content immediately discoverable via `find_documents`. The postcondition is: `∀ α ∈ new_i_addresses: doc ∈ FINDDOCSCONTAINING(α)`.

**Concrete example:**
```
Pre-state:
  Document 1.1.0.1.0.1 exists, empty
  FINDDOCSCONTAINING("Inserted") → []

doinsert(doc=1.1.0.1.0.1, vsa=1.1, text="Inserted text")

Post-state:
  granf: new I-addresses α₁..αₙ allocated for "Inserted text"
         document orgl maps V:1.1..1.13 → α₁..αₙ
  spanf: DOCISPAN entries α₁..αₙ → {1.1.0.1.0.1}
  FINDDOCSCONTAINING("Inserted") → [1.1.0.1.0.1]
```

**Code references:**
- `do1.c:91-127` — `doinsert()` implementation
- `do1.c:45-65` — `docopy()` called by `doinsert`, performs `insertspanf(..., DOCISPAN)`
- Test: `golden/discovery/insert_creates_docispan.json`

**Provenance:** Finding 0036.

### ST-INSERT-ACCUMULATE

**What happens:** Multiple INSERT operations on the same document each create their own DOCISPAN entries. Each insertion allocates fresh I-addresses and adds corresponding DOCISPAN mappings. The DOCISPAN entries from earlier inserts are not disturbed by later ones — they accumulate monotonically.

**Why it matters for spec:** This confirms that INSERT's DOCISPAN creation is additive: `DOCISPAN_after = DOCISPAN_before ∪ {new_i_addrs → doc}`. Combined with INV-IADDRESS-PERMANENT (from Finding 0023), the DOCISPAN index for a document only grows.

**Concrete example:**
```
INSERT "First " at V:1.1  → DOCISPAN: {α₁..α₆ → doc}
INSERT "Second " after     → DOCISPAN: {α₁..α₆ → doc, β₁..β₇ → doc}
INSERT "Third" after       → DOCISPAN: {α₁..α₆ → doc, β₁..β₇ → doc, γ₁..γ₅ → doc}

find_documents("First")  → [doc]
find_documents("Second") → [doc]
find_documents("Third")  → [doc]
```

**Code references:**
- Test: `golden/discovery/insert_multiple_times_accumulates_docispan.json`

**Provenance:** Finding 0036.

### PRE-INSERT

**What happens:** INSERT's call chain through `docopy` includes several precondition checks before DOCISPAN creation: `findorgl(taskptr, granf, docisaptr, &docorgl, WRITEBERT)` verifies the document exists and is writable; `acceptablevsa(vsaptr, docorgl)` validates the V-address is acceptable for the document's current state; `asserttreeisok(docorgl)` validates structural integrity. All must succeed (boolean AND chain) before `insertpm` and `insertspanf` execute.

**Why it matters for spec:** INSERT precondition: the document ISA must exist in granf, the document must be writable, and the target V-address must be valid for the document. Formally: `pre(INSERT(doc, vsa, text)) = doc ∈ granf ∧ writable(doc) ∧ valid_vsa(vsa, doc)`.

**Code references:**
- `do1.c:45-65` — `docopy()` precondition chain: `findorgl`, `acceptablevsa`, `asserttreeisok`
- `do1.c:91-127` — `doinsert()` also calls `makehint(DOCUMENT, ATOM, TEXTATOM, ...)` before `inserttextingranf`

**Provenance:** Finding 0036.

### EC-APPEND-NO-DOCISPAN

**What happens:** APPEND (`doappend`) does NOT create DOCISPAN entries. The source code shows `insertspanf(taskptr,spanf,docptr,textset,DOCISPAN)` is explicitly commented out in the APPEND implementation, with a note suggesting `appendpm` may include the spanf insertion internally (though the comment is ambiguous: `/*zzz dies this put in granf?*/`). This means content added via APPEND is not discoverable through `find_documents`.

**Why it matters for spec:** APPEND and INSERT have different postconditions regarding discoverability:
- INSERT: content discoverable (`DOCISPAN` entries created)
- APPEND: content NOT discoverable (`DOCISPAN` entries omitted)

The spec must distinguish these operations. APPEND postcondition should explicitly state: `spanf' = spanf` (no DOCISPAN change). This is a significant semantic distinction — APPEND creates content that exists in the granf but is invisible to reverse-index queries.

**Code references:**
- `do1.c:25-31` — `doappend()` with commented-out `insertspanf` call
- Comment: `/*zzz dies this put in granf?*/` — suggests uncertainty about whether `appendpm` handles DOCISPAN internally

**Concrete example:**
```
APPEND "Some text" to document D
  granf: D's orgl updated with new content
  spanf: unchanged — no DOCISPAN entries created
  find_documents("Some text") → []   # not discoverable
```

**Provenance:** Finding 0036.

### FC-CONTENT-SPANF-ISOLATION

**What happens:** Finding 0036 refines the granf/spanf isolation picture from Finding 0012. While Finding 0012 established that content operations access only granf and link operations access only spanf, this finding shows that INSERT (a content operation) actually DOES write to spanf — specifically the DOCISPAN portion. The corrected access pattern is: INSERT writes to both granf (new content) and spanf (DOCISPAN index). APPEND writes only to granf. This means FC-CONTENT-SPANF-ISOLATION from Finding 0012 is too strong: it should be restated as "content operations do not affect the *link index* portion of spanf" rather than "content operations do not touch spanf at all."

**Why it matters for spec:** The frame condition must be refined: for INSERT, `spanf.link_index' = spanf.link_index` (link findability unchanged), but `spanf.docispan' ≠ spanf.docispan` (document findability changes). This requires the spec to model spanf as having two independent sub-indices. Content operations may modify the DOCISPAN sub-index without affecting the link sub-index.

**Code references:**
- `do1.c:62` — INSERT path calls `insertspanf(..., DOCISPAN)` — writes to spanf
- `do1.c:386-391` — `dofindlinksfromtothree()` uses spanf for links (separate sub-index)

**Provenance:** Finding 0036, cross-referenced with Finding 0012.
