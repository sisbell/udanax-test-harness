# Finding 0055 Analysis

## Entries

### SS-TUMBLER

**What happens:** Tumbler subtraction via `strongsub` has an exponent guard: when the subtrahend's exponent is strictly less than the minuend's exponent, `strongsub` returns the minuend unchanged without performing any subtraction. This is not a deliberate subspace guard — it is a property of how `strongsub` handles cross-exponent arithmetic. The effect is that `tumblersub(a, b)` where `a.exp > b.exp` is a no-op (returns `a`).

This corrects Finding 0053's claim that `tumblersub` can produce negative tumblers from cross-subspace subtraction. The exponent mismatch prevents the subtraction from occurring at all. Negative tumblers from `tumblersub` can only arise when both operands share the same exponent and `b > a` in absolute value.

**Why it matters for spec:** The tumbler subtraction function has a partial behavior: `tumblersub(a, b) = a` when `b.exp < a.exp`. Formally: `strongsub(a, b, c) : b.exp < a.exp ==> c = a`. This must be modeled in any Dafny specification of tumbler arithmetic. It has downstream effects on which POOM operations can actually modify which entries — operations whose width tumbler has a lower exponent than the target entry's displacement tumbler are no-ops on that entry.

**Code references:**
- `tumble.c:534-547` — `strongsub`, exponent guard at line 544: `if (bptr->exp < aptr->exp) { movetumbler(aptr, cptr); return(0); }`
- `tumble.c:406-430` — `tumblersub` delegates to `strongsub` via negated `tumbleradd`

**Concrete example:**
```
strongsub(a={exp=0, mant=[2,1]}, b={exp=-1, mant=[3]}):
  b.exp (-1) < a.exp (0) → TRUE
  Returns a unchanged: {exp=0, mant=[2,1]} = tumbler 2.1

strongsub(a={exp=-1, mant=[4]}, b={exp=-1, mant=[3]}):
  b.exp (-1) < a.exp (-1) → FALSE
  Proceeds to main subtraction: result = {exp=-1, mant=[1]} = tumbler 0.1
```

**Provenance:** Finding 0055

### FC-SUBSPACE

**What happens:** DELETE at V-position `1.x` does NOT shift link entries at V-position `2.x`. Although `deletecutsectionnd` classifies the link crum as case 2 (shift) — because both knife blades `[1.1, 1.4]` are to the left of crum `2.1` — the actual `tumblersub(2.1, 0.3)` call is a no-op. The reason: the deletion width `0.3` has exponent `-1`, while the link displacement `2.1` has exponent `0`. The `strongsub` exponent guard returns `2.1` unchanged.

This is a different mechanism from INSERT's subspace isolation. INSERT uses an explicit two-blade knife with a second blade at the subspace boundary (Finding 0054). DELETE has no such explicit guard — its knife blades are simply `[origin, origin + width]`, with no subspace-boundary computation. Subspace isolation for DELETE is an accidental consequence of the `strongsub` exponent check.

Both INSERT and DELETE preserve the frame condition, but through fundamentally different mechanisms:
- INSERT: deliberate structural guard (two-blade knife with subspace boundary)
- DELETE: incidental arithmetic guard (exponent mismatch in `strongsub`)

**Why it matters for spec:** The frame condition `∀ op ∈ {DELETE} on subspace s, ∀ entry ∈ poom(doc) : entry.vpos.mantissa[0] ≠ s ==> entry.vpos' = entry.vpos` holds, but its enforcement mechanism differs from INSERT. For DELETE, the frame condition depends on the invariant that deletion widths always have a lower tumbler exponent than cross-subspace entry displacements. If `strongsub` were modified to handle cross-exponent subtraction, DELETE would break subspace isolation. A formal spec should document this as a fragile invariant.

**Code references:**
- `edit.c:40-43` — `deletend` knife construction: `blade[0] = origin`, `blade[1] = origin + width` (no subspace boundary)
- `edit.c:235-248` — `deletecutsectionnd` classifies link crum at `2.1` as case 2 (shift)
- `edit.c:63` — Case 2 calls `tumblersub(&ptr->cdsp.dsas[V], width, ...)`
- `tumble.c:534-547` — `strongsub` exponent guard prevents actual modification

**Concrete example:**
```
Pre-state:
  Text "ABCDEFGHIJ" at V-positions 1.1-1.10
  Link at V-position 2.1

Operation: DELETE 3 bytes at 1.1 (width = 0.3)
  Knife blades: [1.1, 1.4]
  Link crum at 2.1: classified as case 2 (shift)
  tumblersub(2.1, 0.3) called
  strongsub(2.1, 0.3): exp check → 0.3.exp(-1) < 2.1.exp(0) → no-op
  Link remains at 2.1

Post-state:
  Text shifted: 1.1=D, 1.2=E, ..., 1.7=J
  Link STILL at V-position 2.1 (unchanged)
  FOLLOWLINK still works

Operation: DELETE all remaining 7 bytes at 1.1
Post-state:
  Only link remains: vspanset shows "at 2.1 for 0.1"
  Link STILL at V-position 2.1
  FOLLOWLINK still works
```

**Provenance:** Finding 0055

### ST-DELETE

**What happens:** DELETE's V-position shifting via `tumblersub` only affects entries whose displacement tumbler shares the same exponent as the deletion width. Text crums within the deletion's subspace have displacements at exp=-1 (same level as the width), so `strongsub` proceeds to the main subtraction path and they shift. Link crums at exp=0 are unaffected because `strongsub` returns them unchanged.

This corrects Finding 0053's ST-DELETE entry. The postcondition for DELETE is not "all entries after the deletion point shift" — it is "only entries after the deletion point whose V-displacement exponent matches the width exponent shift." Entries at higher hierarchy levels (higher exponent) are immune to the shift.

**Why it matters for spec:** The corrected postcondition for DELETE: `∀ entry ∈ poom(doc) : entry.vpos > delete_end ∧ entry.vpos.exp = width.exp ==> entry.vpos' = entry.vpos - delete_width`. Entries where `entry.vpos.exp > width.exp` satisfy the frame condition `entry.vpos' = entry.vpos`. The exponent match condition is the discriminator, not a subspace check or type check.

**Code references:**
- `edit.c:63` — Case 2: `tumblersub(&ptr->cdsp.dsas[V], width, &ptr->cdsp.dsas[V])`
- `tumble.c:534-547` — `strongsub` exponent guard determines whether subtraction occurs

**Concrete example:**
```
Pre-state:
  Text crum at V-displacement 0.4 (exp=-1)
  Link crum at V-displacement 2.1 (exp=0)
  Deletion width: 0.3 (exp=-1)

Text crum: strongsub(0.4, 0.3) → exp match → subtraction proceeds → 0.1
Link crum: strongsub(2.1, 0.3) → exp mismatch → returns 2.1 unchanged
```

**Provenance:** Finding 0055

### PRE-DELETE

**What happens:** Finding 0053's claim that DELETE lacks a guard against negative V-positions for cross-subspace entries is incorrect. The `strongsub` exponent guard acts as an implicit precondition that prevents cross-exponent subtraction from occurring at all. For same-exponent entries within the deletion subspace, the question of negative V-positions producing invisible entries remains open — but this is constrained to within-subspace entries only, not cross-subspace entries.

The missing precondition concern from Finding 0053 is narrower than claimed: it only applies to entries within the same subspace and at the same exponent level as the deletion width. Cross-subspace entries (links at exp=0 vs text deletion width at exp=-1) are categorically unaffected.

**Why it matters for spec:** The precondition for DELETE need not guard against cross-subspace corruption because `strongsub` makes such corruption impossible. Any formal precondition about negative V-positions should be scoped to same-exponent entries: `∀ entry : entry.vpos > delete_end ∧ entry.vpos.exp = width.exp ==> entry.vpos - delete_width ≥ 0` (if this is desired as a safety invariant).

**Code references:**
- `tumble.c:534-547` — `strongsub` exponent guard provides implicit precondition
- `edit.c:63` — Case 2 subtraction, the only site where negative V-positions could arise

**Provenance:** Finding 0055

### EC-DEEPLY-ORPHANED-LINK

**What happens:** Finding 0053's "deeply orphaned link" state (link POOM entry at a negative V-position) does not occur via cross-subspace deletion. The mechanism proposed in Finding 0053 — DELETE shifting a link's V-position negative — is prevented by `strongsub`'s exponent guard. The empty endsets observed in golden tests after deletion have a different cause: the link's endset I-addresses are freed from the POOM (case 1 in `deletend`: `disown` + `subtreefree`), not the link's own V-position going negative.

When FOLLOWLINK returns empty spans after text deletion:
1. The link's POOM entry remains at V-position 2.1 (verified by `retrieve_contents` at 2.1)
2. The link's endset I-addresses are immutable (stored in I-space)
3. FOLLOWLINK resolves those I-addresses through the home document's current POOM
4. If the I-addresses were in the deletion range, they were freed from the POOM (case 1)
5. Resolution fails because the I-addresses no longer have V-position mappings
6. Result: empty endset spans — from I-address removal, not V-position corruption

**Why it matters for spec:** The "deeply orphaned" link lifecycle state from Finding 0053's analysis is retracted for cross-subspace deletion scenarios. Empty endsets after deletion are explained by I-address removal from the POOM, which is the standard orphaning mechanism (Finding 0024). The link lifecycle model does not need a fourth "deeply orphaned" state for this scenario. Whether same-exponent deletion could produce negative V-positions remains a separate question.

**Code references:**
- `edit.c:53-57` — Case 1 in `deletend`: `disown` + `subtreefree` removes I-addresses
- `golden/subspace/delete_text_does_not_shift_link_subspace.json` — link remains at 2.1 after all text deleted
- `golden/links/delete_text_before_link.json` — reinterpreted: empty endsets from I-address removal

**Provenance:** Finding 0055

### INT-DELETE-SUBSPACE-ASYMMETRY

**What happens:** INSERT and DELETE both preserve subspace isolation but through fundamentally different mechanisms. INSERT uses a deliberate structural guard: `findaddressofsecondcutforinsert()` computes a second knife blade at the next subspace boundary, causing `insertcutsectionnd` to classify cross-subspace entries as case 2 (no shift) before any arithmetic occurs. DELETE uses no such structural guard — its knife blades are `[origin, origin + width]` with no subspace boundary computation. Instead, DELETE relies on an incidental arithmetic property: `strongsub` returns the minuend unchanged when the subtrahend has a smaller exponent.

The asymmetry is a fragility risk. INSERT's protection is robust — it was designed intentionally (the source contains explanatory comments). DELETE's protection is accidental — there is no comment suggesting awareness of the exponent guard as a subspace protection mechanism. If `strongsub` were modified to handle cross-exponent subtraction correctly, DELETE would break subspace isolation while INSERT would remain safe.

**Why it matters for spec:** The formal spec should document this asymmetry. INSERT's frame condition is structurally guaranteed (by knife construction). DELETE's frame condition depends on an arithmetic invariant (`∀ width, entry : different_subspace(width, entry) ==> width.exp < entry.vpos.exp`). These are different proof obligations. INSERT's can be discharged by analyzing knife construction alone; DELETE's requires reasoning about tumbler exponent relationships across subspaces.

**Code references:**
- `insertnd.c:174-183` — `findaddressofsecondcutforinsert()` (INSERT's deliberate guard)
- `edit.c:40-43` — `deletend` knife construction (no equivalent guard)
- `tumble.c:534-547` — `strongsub` exponent check (DELETE's accidental guard)

**Provenance:** Finding 0055
