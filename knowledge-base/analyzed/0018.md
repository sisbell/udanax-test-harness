# Finding 0018 Analysis

## Entries

### SS-CONTENT-IDENTITY

**What happens:** Content identity in udanax-green is based on I-addresses (immutable positions in the permascroll), not textual value. Two documents containing identical text created independently do NOT share content identity — `compare_versions` returns an empty result. Identity is determined by *when and where* content was created.

**Why it matters for spec:** This is a foundational state-structure property: content identity is intensional (by origin), not extensional (by value). Any spec modeling content comparison or transclusion must use I-address equality, never string equality.

**Concrete example:**
```
Source1: "From source one"  → I-address X
Source2: "From source two"  → I-address Y
compare_versions(source1, source2) → []   # empty, no shared content
```

Even if both contained "same text", independently created content has distinct I-addresses.

**Code references:** Test `identity_mixed_sources` in scenarios.

**Provenance:** Finding 0018, Key Finding 1.

### ST-REARRANGE

**What happens:** Pivot and swap rearrange operations change V-positions but preserve I-addresses. After rearrangement, all content retains its original identity — `compare_versions` between pre- and post-rearrange states returns all content as shared.

**Why it matters for spec:** Rearrange postcondition: the multiset of I-addresses in the document is unchanged. Only the V-address mapping changes. This means rearrange is a pure structural permutation with no content creation.

**Concrete example:**
```
Before pivot: "First Second"
  "First " at V:1.1, I-address α
  "Second" at V:1.7, I-address β

After pivot: "SecondFirst "
  "Second" at V:1.1, I-address β  (same I-address)
  "First " at V:1.7, I-address α  (same I-address)

compare_versions(before, after) → all content shared
```

**Code references:** Tests `identity_through_rearrange_pivot`, `identity_through_rearrange_swap` in scenarios.

**Provenance:** Finding 0018, Key Finding 3.

### INV-REARRANGE-IDENTITY

**What happens:** Rearrange operations (pivot, swap) are identity-preserving: the set of I-addresses in a document is invariant across rearrangement. No new I-addresses are created and none are destroyed.

**Why it matters for spec:** Invariant: for any document D, `I-addresses(D_before_rearrange) = I-addresses(D_after_rearrange)`. This is a multiset equality — the same I-addresses exist with the same multiplicities, only V-position mappings change.

**Code references:** Tests `identity_through_rearrange_pivot`, `identity_through_rearrange_swap`.

**Provenance:** Finding 0018, Key Finding 3.

### INV-TRANSITIVE-IDENTITY

**What happens:** Content identity flows transitively through transclusion chains. If A transcludes from B, and B transcludes from C, then A and C share content identity for the transcluded portion — even though A never directly referenced C. `FINDDOCSCONTAINING` and `compare_versions` both respect this transitivity.

**Why it matters for spec:** Invariant: I-address sharing is transitive. If doc A contains I-address range R (via vcopy from B), and B contains R (via vcopy from C), then A and C share R. This follows from the fact that vcopy preserves I-addresses rather than creating new ones.

**Concrete example:**
```
C: "ABCDEFGHIJ"
B: vcopies all of C
A: vcopies "DEFGH" from B

compare_versions(A, C) → "DEFGH" shared
find_documents("DEF" from C) → [A, B, C]
```

**Code references:** Tests `find_documents_transitive`, `identity_partial_transclusion` in scenarios.

**Provenance:** Finding 0018, Key Findings 2 and 6.

### ST-VCOPY

**What happens:** Vcopy (transclusion) preserves I-addresses from the source. The copied content in the target document has the same I-addresses as the original, enabling content identity tracking across documents. Partial transclusion also preserves identity — copying a subset of already-transcluded content maintains the I-address chain back to the original source.

**Why it matters for spec:** Vcopy postcondition: for the copied span, `I-addresses(target[v_target..v_target+len]) = I-addresses(source[v_source..v_source+len])`. This is what makes transitive identity work and distinguishes vcopy from insert (which creates new I-addresses).

**Concrete example:**
```
C: "ABCDEFGHIJ"         # I-addresses α₁..α₁₀
B: vcopy(all of C)       # B contains I-addresses α₁..α₁₀
A: vcopy("DEFGH" from B) # A contains I-addresses α₄..α₈

compare_versions(A, C) → "DEFGH" shared (same I-addresses α₄..α₈)
```

**Code references:** Tests `identity_partial_transclusion`, `find_documents_transitive`.

**Provenance:** Finding 0018, Key Findings 2 and 6.

### FC-CONTENT-SPANF-ISOLATION

**What happens:** Deleting content from one document does not affect its I-address presence in other documents or in the spanf index. After deletion from the source, `FINDDOCSCONTAINING` still finds the content via any remaining document that holds the same I-addresses. The spanf index retains the I-address mapping even after deletion from a document's V-stream.

**Why it matters for spec:** Frame condition: `REMOVE(doc_A, span)` does not modify I-address mappings in any other document, and the spanf index continues to track the I-address for documents that still contain it. Deletion is per-document, not per-I-address.

**Concrete example:**
```
Source: "Keep. Transclude this. End."
Target: "Target has: Transclude this"  (vcopied from Source)

After DELETE("Transclude this" from Source):
  Source: "Keep.  End."
  Target: "Target has: Transclude this"  (unchanged)
  find_documents("Transclude this" from Target) → [Source, Target]
```

Note: even Source is still found — the spanf index retains the mapping despite deletion from the V-stream.

**Code references:** Test `find_documents_after_source_deletion` in scenarios.

**Provenance:** Finding 0018, Key Finding 4.

### ST-VERSION-CREATE

**What happens:** Version creation preserves content identity — the new version shares I-addresses with its parent for all inherited content. `compare_versions` between original and version returns the shared content, and `FINDDOCSCONTAINING` finds both.

**Why it matters for spec:** Version-create postcondition: all I-addresses present in the original are also present in the new version at creation time. Subsequent edits to the version create new I-addresses only for newly inserted content.

**Concrete example:**
```
Original: "Original text"             # I-addresses α₁..αₙ
Version:  "Original text v2 additions" # I-addresses α₁..αₙ + β₁..βₘ

compare_versions(original, version) → "Original text" shared
find_documents("Original" from original) → [original, version]
```

**Code references:** Test `identity_through_version_chain` in scenarios.

**Provenance:** Finding 0018, Key Finding 5.

### EC-COMPARE-VERSIONS-LINK-CRASH

**What happens:** Deep version chains (3+ versions with content added at each level) cause the backend to crash when `compare_versions` or `FINDDOCSCONTAINING` is called. This limits the testable depth of version-chain identity preservation.

**Why it matters for spec:** This is a known implementation limitation (Bug 0012). The spec should define the expected behavior for arbitrary version chain depths, even though the current implementation fails beyond depth 2.

**Code references:** Bug 0012.

**Provenance:** Finding 0018, Key Finding 5 note.
