# Finding 0016 Analysis

## Entries

### ST-REARRANGE

**What happens:** REARRANGE has two modes defined by cut-point geometry:

1. **Pivot (3 cuts):** `pivot(doc, cut1, cut2, cut3)` swaps two adjacent regions. Region1 spans `[cut1, cut2)`, region2 spans `[cut2, cut3)`. After pivot, the document content outside these regions is unchanged, and the two regions exchange positions.

2. **Swap (4 cuts):** `swap(doc, cut1, cut2, cut3, cut4)` swaps two non-adjacent regions. Region1 spans `[cut1, cut2)`, region2 spans `[cut3, cut4)`. The middle segment `[cut2, cut3)` remains in place between the swapped regions.

**Why it matters for spec:** These are permutations on the document's content sequence. The postcondition for pivot is:
- `doc_after[..cut1] = doc_before[..cut1]` (prefix unchanged)
- `doc_after[cut1..cut1+(cut3-cut2)] = doc_before[cut2..cut3]` (region2 moves left)
- `doc_after[cut1+(cut3-cut2)..] = doc_before[cut1..cut2] ++ doc_before[cut3..]` (region1 moves right, suffix unchanged)

For swap, the middle segment is a frame condition:
- `doc_after[cut2'..cut3'] = doc_before[cut2..cut3]` (middle preserved, though its v-addresses shift if regions differ in size)

Both modes preserve `|content(doc)|` — no content is created or destroyed.

**Concrete example (pivot):**
- Before: `"ABCDE"`, cuts at `1.2, 1.4, 1.6`
- Regions: `"BC"` (1.2–1.4) and `"DE"` (1.4–1.6)
- After: `"ADEBC"`

**Concrete example (swap):**
- Before: `"ABCDEFGH"`, cuts at `1.2, 1.4, 1.6, 1.8`
- Regions: `"BC"` (1.2–1.4) and `"FG"` (1.6–1.8)
- Middle: `"DE"` (1.4–1.6) unchanged
- After: `"AFGDEBCH"`

**Code references:** `edit.c:rearrangend()` (backend); `session.pivot()`, `session.swap()` (febe/client.py)

**Provenance:** Finding 0016 (extends Finding 0006)

### INV-REARRANGE-IDENTITY

**What happens:** Rearrange preserves content identity (I-addresses). After a pivot or swap, the moved content retains the same I-addresses it had before. Only V-addresses change — the content's position in the document is different, but its origin identity is the same.

**Why it matters for spec:** This is a key invariant distinguishing REARRANGE from a delete-then-insert sequence. Formally: `i_addresses(doc_after) = i_addresses(doc_before)` — the multiset of I-addresses is identical before and after. This is stronger than just preserving document length; it preserves the specific identity of each content unit. A delete+insert would destroy the original I-address and create a new one, breaking this invariant.

**Concrete example:**
- Content `"BC"` at V-address 1.2 has I-address `I_bc`
- After `pivot(doc, 1.2, 1.4, 1.6)`, `"BC"` is at a new V-address but still has I-address `I_bc`

**Code references:** `edit.c:rearrangend()` (backend); test `pivot_preserves_identity`

**Provenance:** Finding 0016

### INV-REARRANGE-LINK-SURVIVAL

**What happens:** Links bound to rearranged content remain discoverable after pivot or swap. Because links are bound to I-addresses (not V-addresses), moving content to new V-positions does not break link bindings. The link still resolves to the same content at its new location.

**Why it matters for spec:** This is a consequence of INV-REARRANGE-IDENTITY combined with the link binding model (links bind to I-addresses, per SS-LINK-ENDPOINT). Formally: for any link `L` bound to content `C`, if `C` is moved by rearrange, then `L` is still discoverable via the content's new V-address. The spec should verify: `∀ L ∈ links(doc), ∀ rearrange R: findlinks(doc_after_R, endpoint(L)) ≠ ∅` — links don't become orphaned through rearrangement.

**Concrete example:**
- Before swap: link from `"BC"` to `"FG"`
- After swap: same link still discoverable at the new positions of `"BC"` and `"FG"`

**Code references:** Test `swap_with_links`

**Provenance:** Finding 0016

### INV-PIVOT-SELF-INVERSE

**What happens:** Applying the same pivot operation twice with identical cut points restores the document to its original state. This means pivot is its own inverse: `pivot(pivot(doc, c1, c2, c3), c1, c2, c3) = doc`.

**Why it matters for spec:** This is a strong algebraic property of the pivot operation. It confirms that pivot is a transposition (order-2 permutation) on the document's content sequence. The spec can express this as: `∀ doc, c1, c2, c3: rearrange(rearrange(doc, [c1,c2,c3]), [c1,c2,c3]) = doc`. Note this holds only when the two regions are the same size; since pivot swaps adjacent regions around the same cut points, the cut points remain valid after the first application only if the regions don't change the document's length (which they don't — rearrange is length-preserving). This property does NOT necessarily hold for swap with 4 cuts when the swapped regions differ in size, because the cut points may refer to different content after the first swap.

**Concrete example:**
- `"ABCDE"` → `pivot(1.2, 1.4, 1.6)` → `"ADEBC"` → `pivot(1.2, 1.4, 1.6)` → `"ABCDE"`

**Code references:** Test `double_pivot`

**Provenance:** Finding 0016

### FC-REARRANGE-EXTERIOR

**What happens:** Content outside the cut-point range is unaffected by rearrange. For pivot with cuts `(c1, c2, c3)`, content before `c1` and after `c3` is unchanged. For swap with cuts `(c1, c2, c3, c4)`, content before `c1` and after `c4` is unchanged, and the middle segment between `c2` and `c3` is also preserved (though its V-addresses may shift if swapped regions differ in size).

**Why it matters for spec:** Frame condition for REARRANGE: `doc_after[..c1] = doc_before[..c1]` and `doc_after[c_last..] = doc_before[c_last..]`. For swap, additionally: the middle content is preserved in sequence. The spec must distinguish between content preservation (the characters/identities are the same) and address preservation (V-addresses may shift for the middle segment if regions differ in size).

**Code references:** `edit.c:rearrangend()` (backend); visible in all rearrange golden tests

**Provenance:** Finding 0016

## Omit

The following sections of Finding 0016 are omitted:

- **Use Cases:** Application-level usage suggestions (word reordering, paragraph shuffling, drag-and-drop) are design motivations, not behavioral properties.
- **Implementation Notes:** The algorithm description (slice identification, offset computation) is an implementation strategy, not a formalizable property.
- **Comparison table with Copy+Delete:** Useful for motivation but the individual properties (identity preservation, link survival) are already captured in dedicated entries above.
