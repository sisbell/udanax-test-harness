# Finding 0014 Analysis

## Entries

### SS-BERT

**What happens:** BERT (Booking Entry Record Table) is the access control state for document operations. It is a hash table of entries, each recording: a connection identifier, a document tumbler, access type (READBERT=1 or WRITEBERT=2), a reference count, and created/modified flags. NOBERTREQUIRED (0) is a sentinel that bypasses the table entirely for internal operations.

**Why it matters for spec:** BERT defines the access-control layer of the state model. Every document operation passes through `findorgl` with an access type parameter, making the BERT state a precondition for all document reads and writes. The spec must model this as a mapping from `(connection, document) -> access_level` with reference counting.

**State structure:**
```
BertEntry = { connection: ConnectionId, document: Tumbler, type: {READ, WRITE}, count: Nat }
BertTable: Map<(ConnectionId, Tumbler), BertEntry>
```

**Code references:** `bert.c:13-29` (struct definition), `common.h:165-167` (access level constants)

**Provenance:** Finding 0014

### PRE-OPEN-DOC

**What happens:** The `checkforopen` function implements an access control state machine that determines whether a document open request is granted, denied, or requires opening the document first. The decision depends on: (1) whether the document is already open, (2) the existing access level, (3) whether the request comes from the same connection, and (4) the requested access level.

The state machine returns:
- `>0` (access type): access granted
- `0`: document needs to be opened first
- `-1`: access denied (client should create a new version instead)

Key rules:
- READ request on a document not yet open → 0 (need to open)
- READ request on a document already open for READ by same connection → READ (granted)
- READ request on a document open for WRITE by same connection → WRITE (upgraded, granted)
- READ request on a document open for WRITE by different connection → -1 (denied)
- WRITE request on an unowned document that is not open → -1 (denied)
- WRITE request on an owned document that is not open → 0 (need to open)
- WRITE request on a document open for READ by any connection → -1 (denied)
- WRITE request on a document open for WRITE by same connection → WRITE (granted)
- WRITE request on a document open for WRITE by different connection → -1 (denied)

**Why it matters for spec:** This is the core precondition for all document mutation. The access control matrix fully determines which operations can proceed. The -1 return value ties directly into the versioning model — denied writes are redirected to version creation, supporting non-destructive editing.

**Concrete example:**
- Connection A opens doc 1.0.1.0.1 for WRITE → granted
- Connection B requests READ on doc 1.0.1.0.1 → denied (-1), B should create a version
- Connection A requests READ on doc 1.0.1.0.1 → returns WRITE (existing higher access)

**Code references:** `bert.c:43-50` (`checkforopen`), `do2.c` (`doopen`, `doclose`)

**Provenance:** Finding 0014

### INV-READ-SHARING

**What happens:** Multiple connections can hold READBERT access to the same document simultaneously. There is no limit on concurrent readers. However, the presence of any WRITEBERT holder on a document blocks new READ access from other connections.

**Why it matters for spec:** This is a classic readers-writer lock invariant. Formalizable as: `forall d: Document, c1 c2: Connection | bert(c1, d) = READ ∧ bert(c2, d) = READ → c1 ≠ c2 is permitted`. And: `bert(c1, d) = WRITE → forall c2 ≠ c1 | bert(c2, d) = NONE`.

**Code references:** `bert.c:43-50` (access matrix), `bert.c` (BERT table implementation)

**Provenance:** Finding 0014

### INV-WRITE-EXCLUSIVITY

**What happens:** At most one connection can hold WRITEBERT access to any given document. If connection A holds WRITE, all WRITE requests from other connections return -1. Additionally, all READ requests from other connections also return -1.

**Why it matters for spec:** This is the mutual exclusion invariant for document writes: `forall d: Document | |{c: Connection | bert(c, d) = WRITE}| <= 1`. Combined with the read-blocking rule: if any connection holds WRITE, no other connection holds any access. This guarantees single-writer consistency without requiring merge conflict resolution.

**Code references:** `bert.c:43-50` (access matrix shows -1 for cross-connection WRITE conflicts)

**Provenance:** Finding 0014

### INT-BERT-VERSION

**What happens:** When write access is denied (return -1), the protocol signals the client to create a new version of the document and open that version for writing instead. This connects BERT access control to the versioning system — access denial is not an error but a redirect into the version-branching workflow.

**Why it matters for spec:** The access control system and the versioning system interact: write contention triggers version creation rather than failure. This means the spec's version-creation operation has an implicit trigger from access denial, not just explicit user action. Formalizable as a protocol-level property: `denied_write(c, d) → should_create_version(c, d)`.

**Code references:** `bert.c:43-50` (return value -1 semantics), version creation logic in backend

**Provenance:** Finding 0014

## Omit

The following sections of Finding 0014 are omitted from analysis:

- **NOBERTREQUIRED bypass details:** The internal bypass mechanism (NOBERTREQUIRED=0) is an implementation optimization for avoiding redundant checks within already-protected contexts. It does not define new behavioral properties — it simply skips the access check. Not relevant to the formal specification of access semantics.
- **Test harness implications:** Single-connection test harness behavior is test infrastructure detail, not system semantics.
- **Connection tracking cleanup:** The cleanup-on-close behavior is operational lifecycle management, not a state property that needs formal verification.
