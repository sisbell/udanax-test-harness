# Finding 0071 Analysis

## Entries

### SS-ENFILADE-TREE

**What happens:** The 2D enfilade rebalancing algorithm (`recombinend`) differs fundamentally from the 1D algorithm (`recombineseq`) in how it orders children for merge consideration. `recombinend` at `recombine.c:104-131` works in four steps:

1. **Recursive descent:** Bottom-up rebalancing — recursively rebalance all children before the parent.
2. **Diagonal sort:** `getorderedsons` at `recombine.c:278-311` calls `shellsort`, which orders children by the sum of their two displacement coordinates (`cdsp.dsas[0] + cdsp.dsas[1]`). The code comment calls this the "compare crums diagonally hack." For SPAN enfilades, dimension 0 is ORGLRANGE (I-space) and dimension 1 is SPANRANGE (V-space), so sorting is by combined I+V position — an L1-norm diagonal sweep across the 2D address space.
3. **Pairwise nephew-stealing:** All O(n^2) pairs along the diagonal order are considered for merging, guarded by `ishouldbother`.
4. **Level pull:** If the root has only one child after merges, `levelpull` removes a tree level.

The 1D algorithm (`recombineseq`) is simpler: it iterates children in sibling order (not sorted), only considers adjacent pairs, and breaks after the first merge operation. The 2D algorithm must consider all pairs because spatial proximity in 2D does not follow sibling order.

**Why it matters for spec:** The rebalancing strategy is part of the enfilade's structural maintenance. A formal model of 2D enfilades must acknowledge that the child ordering used during rebalancing is not the storage order but a computed diagonal ordering. This affects what "adjacent" means for merge candidates: two nodes far apart in sibling order may be merged if they are close on the diagonal. The formal invariant is that after `recombinend`, no pair of children whose combined son count fits within `max_children` should remain separate — the algorithm is greedy over all pairs, not just adjacent ones.

**Code references:**
- `backend/recombine.c:104-131` — `recombinend` algorithm (4-step structure)
- `backend/recombine.c:278-311` — `getorderedsons` + `shellsort` with diagonal key
- `backend/recombine.c:313-320` — `comparecrumsdiagonally` (L1-norm comparison)
- `backend/recombine.c:57-102` — `recombineseq` (1D contrast: adjacent pairs only)

**Concrete example:**
```
2D enfilade with 4 children having displacements:
  Child A: dsas[0]=1, dsas[1]=5  → diagonal key = 6
  Child B: dsas[0]=3, dsas[1]=2  → diagonal key = 5
  Child C: dsas[0]=4, dsas[1]=4  → diagonal key = 8
  Child D: dsas[0]=2, dsas[1]=1  → diagonal key = 3

Diagonal sort order: D(3), B(5), A(6), C(8)

Pairwise merge consideration:
  (D,B), (D,A), (D,C), (B,A), (B,C), (A,C)
  — all pairs checked via ishouldbother, not just adjacent siblings
```

**Provenance:** Finding 0071

### ST-REBALANCE-2D

**What happens:** The `recombinend` rebalancing operation modifies 2D enfilade tree structure through two mechanisms:

1. **Full merge** (`eatbrossubtreend` at `recombine.c:205-233`): One node absorbs all children from another node, which is then deleted. This happens when the combined son count fits within the branching limit.
2. **Nephew stealing** (`takenephewnd` at `recombine.c:165-203`): Individual children are moved from an overpopulated sibling to an underpopulated one without deleting either node.

The merge guard `ishouldbother` at `recombine.c:150-163` checks:
- Combined son count: `dest->numberofsons + src->numberofsons <= (height > 1 ? MAXUCINLOAF : MAX2DBCINLOAF)`
- Reserved crums are skipped (age == RESERVED) to avoid interfering with in-progress operations
- `randomness(.3)` always returns TRUE (probabilistic path commented out), so all eligible pairs are merged

**Postconditions:**
- After `recombinend`, no pair of children in the node can be merged without exceeding `max_children`
- If the root ends up with exactly one child, `levelpull` removes the root level, decreasing tree height by 1
- Reserved crums are never disturbed

**Why it matters for spec:** The state transition for 2D rebalancing has a frame condition: reserved crums are untouched. The postcondition is a saturation property — no further merges are possible among children. This differs from 1D rebalancing which only attempts one merge per call. The formal model should express: `post(recombinend(node)) ⟹ ∀ i,j ∈ children(node): i ≠ j ⟹ ¬ishouldbother(i,j)`.

**Code references:**
- `backend/recombine.c:150-163` — `ishouldbother` merge guard
- `backend/recombine.c:165-203` — `takeovernephewsnd` (dispatch between merge and steal)
- `backend/recombine.c:205-233` — `eatbrossubtreend` (full subtree merge)
- `backend/recombine.c:104-131` — `recombinend` outer loop

**Provenance:** Finding 0071

### ST-SPLIT-2D

**What happens:** The 2D split strategy is dimension-aware and asymmetric between SPAN and POOM enfilades:

- **SPAN split** (`splitcrumsp` at `split.c:95-106`): Peels off the child with the largest diagonal position, using `comparecrumsdiagonally(ptr, correctone) == GREATER`. This matches the diagonal ordering used in `recombinend`, making split and merge complementary operations in the same ordering space.
- **POOM split** (`splitcrumpm` at `split.c:117-128`): Peels off the child with the largest SPANRANGE displacement only (`cdsp.dsas[SPANRANGE]`), ignoring the ORGLRANGE dimension entirely. Commented-out code shows diagonal splitting was tried for POOM but reverted.

The asymmetry is notable: SPAN uses the same L1-norm diagonal for both split and rebalance, while POOM uses diagonal for rebalance but single-dimension for split.

**Why it matters for spec:** The split operation is the inverse of merge for maintaining tree balance, but the two 2D enfilade types use different split criteria. A formal model needs separate split predicates:
- `split_span(node) → peel child c where diag(c) = max(diag(children(node)))`
- `split_poom(node) → peel child c where c.dsas[SPANRANGE] = max over children`

The asymmetry means the POOM tree shape may differ from SPAN even with identical data distributions, because split and rebalance use different orderings.

**Code references:**
- `backend/split.c:95-106` — `splitcrumsp` (SPAN split by diagonal)
- `backend/split.c:117-128` — `splitcrumpm` (POOM split by SPANRANGE only)
- `backend/recombine.c:313-320` — `comparecrumsdiagonally` (shared with rebalance)

**Concrete example:**
```
SPAN enfilade node with children at diagonals [3, 5, 6, 8, 9]:
  splitcrumsp peels child with diagonal 9

POOM enfilade node with children:
  A: dsas[SPANRANGE]=7, dsas[ORGLRANGE]=2  (diagonal=9)
  B: dsas[SPANRANGE]=8, dsas[ORGLRANGE]=1  (diagonal=9)
  splitcrumpm peels B (largest SPANRANGE=8), NOT based on diagonal
```

**Provenance:** Finding 0071

### INV-ENFILADE-OCCUPANCY

**What happens:** The `ishouldbother` merge guard in `recombinend` enforces that merges only occur when the result stays within branching bounds: `dest->numberofsons + src->numberofsons <= (height > 1 ? MAXUCINLOAF : MAX2DBCINLOAF)`. This ensures the merge-then-no-split property: a rebalancing merge never immediately triggers a split. The `randomness(.3)` probabilistic guard is effectively disabled (always returns TRUE), meaning all occupancy-eligible pairs are deterministically merged.

**Why it matters for spec:** The occupancy invariant is maintained through rebalancing as a postcondition: after `recombinend`, every node satisfies `1 <= sons <= max_children(height, type)`. The merge guard is the mechanism that prevents rebalancing from violating the upper bound. The deterministic behavior (no randomness) simplifies formal verification — the algorithm is fully determined by node occupancy counts.

**Code references:**
- `backend/recombine.c:150-163` — `ishouldbother` with occupancy check and reserved-crum guard

**Provenance:** Finding 0071

### FC-RESERVED-CRUM

**What happens:** During 2D rebalancing, `ishouldbother` at `recombine.c:150-163` skips any crum with `age == RESERVED`. Reserved crums are in-progress or held by other operations. The rebalancing algorithm treats them as immovable: they cannot be merged into another node, nor can another node steal their children.

**Why it matters for spec:** This is a frame condition on the rebalance operation: reserved crums and their subtrees are invariant under rebalancing. The formal model should express: `∀ node with age = RESERVED: recombinend(parent) does not modify node or node's children`. This ensures concurrent operations that have "reserved" a crum are not disrupted by tree restructuring.

**Code references:**
- `backend/recombine.c:150-163` — `ishouldbother` checks `age == RESERVED` and skips

**Provenance:** Finding 0071
