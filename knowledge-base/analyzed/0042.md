# Finding 0042 Analysis

## Entries

### INV-ATOMICITY

**What happens:** The `bed.c` event loop processes each FEBE operation atomically via run-to-completion scheduling. The `xanadu(&task)` call executes the entire operation — request parsing, state mutation, response sending, and memory cleanup — before returning to `select()`. Multi-step operations like INSERT (which involves I-address allocation, granfilade insertion, spanfilade update, and POOM update) execute as a single uninterruptible unit. There are no threads, no state-modifying signal handlers, and no preemption.

**Why it matters for spec:** This is the foundational atomicity invariant: every operation's view of shared state (ispace, spanfilade, POOMs) is consistent throughout execution. No interleaving is possible. This means all state transitions documented in other findings are truly atomic — there is no partial-execution state observable by any frontend. Any formal spec can model operations as atomic transitions without reasoning about interleavings.

**Code references:**
- `backend/bed.c:103-150` — main event loop with `select()` and sequential `xanadu()` dispatch
- `backend/bed.c:153-172` — `xanadu()` function: `getrequest` -> `requestfns[request]` -> `sendresultoutput` -> `tfree`

**Concrete example:**
- Before: Two frontends (FE1, FE2) both have pending INSERT requests ready on their file descriptors
- During: `select()` returns with both FDs ready. The loop iterates: FE1's INSERT runs to completion (all four internal steps: allocate I-address, insert text, insert DOCISPAN, update POOM), response sent. Then FE2's INSERT runs to completion. No interleaving occurs.
- After: Both INSERTs have executed sequentially; each saw a consistent snapshot of state.

**Provenance:** Finding 0042

### INV-SEQUENTIAL-DISPATCH

**What happens:** Even when multiple frontends have requests ready simultaneously (multiple FDs set in `select()`'s result), the event loop processes them strictly sequentially by iterating over file descriptors in order. Frontend i's request completes entirely before frontend i+1's request begins.

**Why it matters for spec:** The system's concurrency model is total serialization. For specification purposes, the system behaves as if there is a single global operation queue. This is stronger than per-document serialization — it means cross-document operations are also serialized. Any linearizability argument is trivially satisfied.

**Code references:**
- `backend/bed.c:118-128` — sequential iteration over ready FDs with blocking `xanadu(&task)` per iteration

**Provenance:** Finding 0042

### PRE-INSERT

**What happens:** I-address allocation via `findisatoinsertgr()` uses a global search-and-increment to find fresh addresses. This is safe without locking because the single-threaded event loop guarantees no concurrent allocations.

**Why it matters for spec:** The precondition for INSERT includes that the allocated I-address is globally unique. This property (called P1/Freshness in EWD-025) is guaranteed by sequential execution rather than by an explicit uniqueness check. A formal spec should state the freshness precondition explicitly even though the implementation achieves it structurally.

**Code references:**
- `backend/granf2.c:203-242` — I-address allocation via search-and-increment

**Provenance:** Finding 0042
