# Finding 0068 Analysis

## Entries

### SS-VERSION-ADDRESS
**What happens:** VERSION allocates the new document's address as a child of the source document, not as a sibling under the parent account. This produces a hierarchical version tree encoded directly in the address structure. The allocation uses a context-sensitive hint: when the user owns the source document, `makehint(DOCUMENT, DOCUMENT, 0, isaptr, &hint)` sets depth=1, placing the version under the source document's address prefix. When the user does NOT own the source document, `makehint(ACCOUNT, DOCUMENT, 0, wheretoputit, &hint)` sets depth=2, placing the version under the creating user's account instead (identical to CREATE behavior).

The ownership check uses `tumbleraccounteq(isaptr, wheretoputit) && isthisusersdocument(isaptr)`.

**Why it matters for spec:** The formal spec needs two address allocation rules for VERSION:
- Owned: `version_address(doc) ∈ children(doc)` — i.e., `prefix(version_address, length(doc)) = doc`
- Unowned: `version_address(doc) ∈ children(user_account)` — i.e., `prefix(version_address, length(account)) = account`

This extends SS-VERSION-ADDRESS from Finding 0007 with the ownership-sensitive allocation mechanism. The address hierarchy encodes version lineage only for owned documents; cross-user versions break the address-based lineage.

**Code references:** `do1.c:272-280` — ownership-sensitive hint creation in `docreatenewversion`. `do2.c:78-84` — `makehint` encodes hierarchy levels.

**Concrete example:**
- User owns doc `1.1.0.1.0.1` → version at `1.1.0.1.0.1.1` (child of doc)
- User owns doc `1.1.0.1.0.1`, second version → `1.1.0.1.0.1.2` (next child)
- User B (account `1.1.0.2`) versions User A's doc `1.1.0.1.0.1` → version at `1.1.0.2.0.1` (under User B's account)

**Provenance:** Finding 0068

### SS-ADDRESS-SPACE
**What happens:** Documents form hierarchical version trees encoded in the address structure. Each document is the root of its own version namespace. Versions of versions produce nested addresses, creating unbounded-depth trees:

```
1.1.0.1.0.1              (doc1)
├── 1.1.0.1.0.1.1        (version1 of doc1)
│   └── 1.1.0.1.0.1.1.1  (version of version1)
└── 1.1.0.1.0.1.2        (version2 of doc1)
```

The depth of version nesting is unlimited — the address simply grows by one component per version level.

**Why it matters for spec:** The address space model must accommodate arbitrary-depth version trees. The type hierarchy is recursive: `DOCUMENT → DOCUMENT → DOCUMENT → ...` with depth=1 at each level. The `makehint(DOCUMENT, DOCUMENT, ...)` case with depth=1 is the recursive step that enables this nesting.

**Code references:** `granf2.c:203-242` — `findisatoinsertnonmolecule`, depth=1 for DOCUMENT→DOCUMENT. Test evidence in `golden/versions/version_address_allocation.json`.

**Concrete example:**
- `d = 1.1.0.1.0.1`, `v1 = VERSION(d) = 1.1.0.1.0.1.1`, `v2 = VERSION(v1) = 1.1.0.1.0.1.1.1`
- Each level adds one component; no `.0.` boundary is crossed (depth=1)

**Provenance:** Finding 0068

### ST-ADDRESS-ALLOC
**What happens:** VERSION uses the same stateless query-and-increment allocation mechanism as CREATE and INSERT. For owned-document versions, the algorithm:

1. Computes upper bound: `tumblerincrement(source_doc, depth-1=0, 1)` — the next sibling of the source document (e.g., `1.1.0.1.0.2` for source `1.1.0.1.0.1`).
2. Calls `findpreviousisagr` to find the highest existing address below the upper bound.
3. Applies containment check: verifies the found address is actually under the source document.
4. If no child exists: allocates first child as `source_doc.1` (e.g., `1.1.0.1.0.1.1`).
5. If child exists: truncates and increments to produce next sibling (e.g., `1.1.0.1.0.1.2`).

This extends ST-ADDRESS-ALLOC from Finding 0021 with the VERSION-specific hint parameters.

**Why it matters for spec:** The postcondition for owned-version allocation is: `allocated = max_child(source_doc, granf) + 1`, where `max_child` returns the highest existing address under `source_doc`. If no children exist: `allocated = source_doc.1`. The allocation is a pure function of granfilade state, with no session-local counter.

**Code references:** `granf2.c:203-242` — `findisatoinsertnonmolecule` (query-and-increment). `granf2.c:255-278` — `findpreviousisagr` (tree traversal). `granf2.c:130-156` — `findisatoinsertgr` (allocation dispatcher).

**Concrete example:**
Second version of `1.1.0.1.0.1`:
1. `hintisa = 1.1.0.1.0.1`, depth=1
2. `upperbound = 1.1.0.1.0.2`
3. `findpreviousisagr` finds `1.1.0.1.0.1.1` (first version)
4. Truncate to length 7: `1.1.0.1.0.1.1`, increment: `1.1.0.1.0.1.2`

**Provenance:** Finding 0068

### INV-MONOTONIC
**What happens:** Version address allocation is monotonically increasing within each document's version namespace, using the same mechanism as I-address allocation. Deleting a version does not free its address — the granfilade retains all allocated addresses permanently. The sequence `.1`, `.2`, `.3` under a document never reuses a previously allocated version address.

**Why it matters for spec:** Extends INV-MONOTONIC from Finding 0061 to document-level allocation: `∀ version_alloc_a, version_alloc_b under doc D : time(a) < time(b) ⟹ addr(b) > addr(a)`. Combined with INV-NO-IADDR-REUSE, version addresses are permanent and gap-free within each document's child namespace.

**Code references:** `granf2.c:203-242` — same `findisatoinsertnonmolecule` as element allocation; queries granfilade maximum and increments.

**Concrete example:**
- Create version of `1.1.0.1.0.1` → `1.1.0.1.0.1.1`
- Delete `1.1.0.1.0.1.1`
- Create another version → `1.1.0.1.0.1.2` (not `.1` reused)

**Provenance:** Finding 0068

### PRE-VERSION-OWNERSHIP
**What happens:** The VERSION operation checks ownership before choosing the allocation strategy. The predicate `tumbleraccounteq(isaptr, wheretoputit) && isthisusersdocument(isaptr)` determines whether the version is allocated under the source document (owned) or under the creating user's account (unowned). This is not a precondition that rejects the operation — both paths succeed — but it is a precondition on the allocation path that determines where the new address lands.

**Why it matters for spec:** The allocation rule is conditional: `if owns(user, doc) then allocate_under(doc) else allocate_under(user.account)`. This is a branching postcondition keyed on the ownership predicate. The spec must model both paths. The ownership check uses account-level tumbler comparison (`tumbleraccounteq`), meaning ownership is determined by account prefix matching, not by an explicit permissions table.

**Code references:** `do1.c:272-280` — ownership branch in `docreatenewversion`. `tumbleraccounteq` — compares account components of two tumbler addresses. `isthisusersdocument` — verifies the document belongs to the current user.

**Concrete example:**
- User A (account `1.1.0.1`) versions own doc `1.1.0.1.0.1` → ownership check passes → child allocation `1.1.0.1.0.1.1`
- User B (account `1.1.0.2`) versions A's doc `1.1.0.1.0.1` → ownership check fails → account allocation `1.1.0.2.0.1`

**Provenance:** Finding 0068

### FC-GRANF-ON-DELETE
**What happens:** Deleting a version does not remove its address from the granfilade. The version's address persists permanently in the granfilade tree and continues to influence subsequent version allocation (the next version will be allocated after the deleted one, not in its place). This is the same frame condition as for I-address deletion documented in Finding 0061.

**Why it matters for spec:** Frame condition for VERSION addresses: `∀ op ∈ {DELETE_VERSION} : granf_after(op) = granf_before(op)`. Version addresses, like I-addresses, are write-once in the granfilade. This ensures version address stability for any external references to the version.

**Code references:** `granf2.c:203-242` — allocation queries granfilade tree which retains all addresses.

**Provenance:** Finding 0068
