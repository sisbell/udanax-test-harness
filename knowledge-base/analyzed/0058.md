# Finding 0058 Analysis

## Entries

### SS-ENFILADE-TREE

**What happens:** Enfilade trees have a `height` field on the fullcrum (apex node) that tracks tree depth. `createenf(POOM)` produces a minimal height-1 tree: a fullcrum with `isapex=TRUE`, `height=1`, containing a single bottom node (height-0) with zero width. For GRAN enfilades, the bottom node has `infotype=GRANNULL`. As content is inserted, loaf overflow triggers `splitcrumupwards`, and when the fullcrum itself overflows, `levelpush` increments the fullcrum's height and pushes existing children down one level. The inverse operation `levelpull` — which should collapse a height-H tree back to height H-1 when the fullcrum has only one child — exists in code but is disabled: it immediately returns 0 without executing the commented-out collapse logic.

Tree height can increase (via `levelpush`) but never decrease. The fullcrum height is a monotonically non-decreasing value over the lifetime of a document's enfilade.

**Why it matters for spec:** The state structure for enfilades must include `height: nat` on the fullcrum node, and the model must capture that height increases are permanent in the current implementation. The initial state constructor produces `height = 1`; `levelpush` is the only transition that modifies height, and it only increments. This is not the intended design — `levelpull` was meant to provide the inverse — but it is the actual invariant: `∀ t₁ < t₂ : enf.height(t₁) ≤ enf.height(t₂)`.

**Code references:**
- `backend/credel.c:492-516` — `createenf`: creates height-1 fullcrum with one bottom node
- `backend/genf.c:263-294` — `levelpush`: increments fullcrum height, pushes children down
- `backend/genf.c:318-342` — `levelpull`: disabled, immediately returns 0

**Concrete example:**
```
createenf(POOM):
  Fullcrum (height=1, isapex=TRUE, numberofsons=1)
    └─ Bottom node (height=0, width=0)

After many inserts (tree has grown):
  Fullcrum (height=3, isapex=TRUE, numberofsons=2)
    ├─ Height-2 node
    │    ├─ Height-1 node (bottom nodes...)
    │    └─ Height-1 node (bottom nodes...)
    └─ Height-2 node
         └─ Height-1 node (bottom nodes...)

levelpush incremented height from 1→2→3. levelpull would reverse this but is disabled.
```

**Provenance:** Finding 0058

### ST-DELETE

**What happens:** When DELETE removes all content from a document, the operation disowns and frees all bottom nodes (height-0) via `disown` + `subtreefree`, then calls `setwispupwards` and `recombine` on the father node. The `recombinend` function processes sibling pairs: `ishouldbother` checks if two siblings can be merged, and `takeovernephewsnd` transfers children between them (freeing empty siblings in the process). Finally, if `father->isapex`, `recombinend` calls `levelpull` — but since `levelpull` is disabled, the tree height is never reduced.

The result: after delete-everything, the tree retains its prior height with empty intermediate nodes (numberofsons=0) still allocated. The POOM returns zero-width content (functionally empty), but the tree structure is not collapsed.

**Why it matters for spec:** The ST-DELETE postcondition must include: after deleting the entire V-span, `poom(doc)` maps no V-addresses (retrieve returns empty), BUT the enfilade tree height is unchanged: `enf.height_after = enf.height_before`. The tree's structural state is NOT equivalent to `createenf()` output. This means `delete_all` is not the inverse of the cumulative inserts — it removes the mapping but not the structural growth. Formally: `delete_all(doc) ⟹ dom(poom(doc)) = ∅ ∧ enf.height(doc) = enf.height_before(doc)`.

**Code references:**
- `backend/edit.c:31-76` — `deletend`: Case 1 disowns/frees bottom nodes, calls `recombine`
- `backend/recombine.c:104-131` — `recombinend`: processes siblings, calls `levelpull` on apex
- `backend/recombine.c:194-202` — `takeovernephewsnd`: frees empty sibling nodes during merge
- `backend/genf.c:318-342` — `levelpull`: disabled, returns 0

**Concrete example:**
```
Before DELETE (8 bytes at 1.1, tree height=3):
  Fullcrum (height=3, numberofsons=2)
    ├─ Height-2 node (numberofsons=2)
    │    ├─ Height-1 node (bottom nodes with content)
    │    └─ Height-1 node (bottom nodes with content)
    └─ Height-2 node (numberofsons=1)
         └─ Height-1 node (bottom nodes with content)

After DELETE(doc, 1.1, 0.8):
  Fullcrum (height=3, numberofsons=2)    ← height unchanged
    ├─ Height-2 node (numberofsons=0)    ← empty, not freed
    └─ Height-2 node (numberofsons=0)    ← empty, not freed

  retrieve_vspanset → empty (zero-width)
  Tree height remains 3, not collapsed to 1
```

**Provenance:** Finding 0058

### INV-ENFILADE-MINIMALITY

**What happens:** The enfilade design (per EWD-006) calls for tree minimality: the tree should be as shallow as possible, with no unnecessary intermediate nodes. `levelpull` was intended to enforce this by collapsing the tree when the fullcrum has only one child and height > 1. The commented-out code in `genf.c:318-342` shows the algorithm: check `numberofsons > 1` (if so, no pull needed), check `height <= 1` (if so, already minimal), then disown the single child, decrement height, transfer grandchildren up, and free the former child.

Because `levelpull` is disabled, minimality is violated after any delete-everything operation. The tree retains whatever height it reached during content growth, even when all content is removed.

**Why it matters for spec:** The formal spec should NOT assert tree minimality as an invariant — the implementation violates it. Instead, the spec should note: (a) `levelpush` ensures height is sufficient for the current fan-out, (b) `levelpull` (tree height reduction) is not implemented, (c) the actual invariant is: `enf.height ≥ 1` (lower bound only, no upper bound tightness guarantee). The intended invariant `enf.height = min_height(content)` does not hold. This is relevant for any bounded-model checking (Alloy) that models tree structure — the height dimension is monotonic, not minimal.

**Code references:**
- `backend/genf.c:318-342` — `levelpull`: commented-out collapse algorithm, function returns 0
- `backend/genf.c:263-294` — `levelpush`: the only height-changing operation (increment only)
- `backend/recombine.c:136-137` — `recombinend` calls `levelpull` on apex (but it's a no-op)

**Provenance:** Finding 0058

### EC-EMPTY-DOC

**What happens:** Two distinct "empty document" states exist that are structurally non-equivalent:

| State | Height | Fullcrum sons | Bottom nodes |
|-------|--------|---------------|--------------|
| Never-filled (`createenf`) | 1 | 1 (zero-width bottom) | 1 |
| After delete-everything | H (from prior growth) | 2+ (empty intermediates) | 0 |

A never-filled document has a minimal height-1 tree with one zero-width bottom node. A document where all content was deleted has a taller tree with empty intermediate nodes and no bottom nodes at all. Both return empty content on retrieve, but their internal structures differ.

This non-equivalence has concrete consequences: Finding 0064 confirms that the empty-after-delete state causes INSERT and VCOPY to crash (Bug 0019) because `firstinsertionnd()` assumes a bottom crum always exists. When `findleftson()` returns NULL (no bottom nodes), the code dereferences a null pointer.

**Why it matters for spec:** The formal model must distinguish these two empty states, or at minimum specify that delete-everything does NOT restore the initial state. The predicate `is_empty(doc) ≡ dom(poom(doc)) = ∅` is true for both states, but `is_initial(doc) ≡ is_empty(doc) ∧ enf.height(doc) = 1 ∧ has_bottom_node(doc)` is only true for never-filled documents. The crash on reinsertion into a deleted-everything document means the current implementation has a hidden precondition: `pre_insert(doc) ⟹ has_bottom_node(enf(doc))`, which never-filled documents satisfy but delete-everything documents violate.

**Code references:**
- `backend/credel.c:492-516` — `createenf`: produces height-1 with one bottom node
- `backend/edit.c:31-76` — `deletend`: removes all bottom nodes without creating replacements
- Finding 0064 / Bug 0019 — crash on INSERT after delete-everything (null bottom node)

**Provenance:** Finding 0058
