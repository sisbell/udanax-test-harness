# Finding 0069 Analysis

## Entries

### PRE-FIND-LINKS

**What happens:** The `find_links` operation accepts an orgl range parameter that is supposed to restrict which orgls (documents/links) are searched. However, `sporglset2linkset()` in `sporgl.c:222-237` contains a dead-code guard `if (TRUE||!homeset)` that always evaluates true, replacing whatever orgl range the caller provides with a hardcoded range of width 100 starting at tumbler zero. The original intent was `if (!homeset)` — supply a default range only when none is specified — but the `TRUE||` prefix makes the parameter permanently ignored. The caller `findlinksfromtothreesp()` in `spanf1.c:56-103` faithfully passes its `orglrange` argument through, but the callee discards it.

**Why it matters for spec:** The spec must document that `find_links` has no effective orgl-dimension precondition in the implementation. A formal spec could define `find_links(from_spec, to_spec, three_spec, orgl_range)` where `orgl_range` constrains results, but the implementation behaves as `find_links(from_spec, to_spec, three_spec, _)` — the orgl range is accepted syntactically but has no semantic effect. This is a known deviation: the specified interface promises scoping that the implementation does not deliver. A spec should either (a) model the intended behavior (orgl filtering works) and flag this as a known bug, or (b) model the actual behavior (orgl range ignored, search is global in the orgl dimension).

**Code references:**
- `sporgl.c:220-230` — `sporglset2linkset()` with the `TRUE||` always-true guard
- `spanf1.c:56-103` — `findlinksfromtothreesp()` passes `orglrange` to `sporglset2linkset`
- `retrie.c:56-85` — `retrieverestricted()` converts range to start/end spans (downstream of the override)

**Concrete example:**
```
Caller requests: find_links(orgl_range = document 1.1.0.1.0.1 only)

Expected behavior:
  Search restricted to links whose orgls are within document 1.1.0.1.0.1

Actual behavior:
  homeset parameter replaced with {stream: 0, width: 100}
  Search covers all orgls from 0 to 100 in the orgl dimension
  Links from any document are returned if they match on the span dimension
```

**Provenance:** Finding 0069

### SS-SPANF-OPERATIONS

**What happens:** The spanfilade search operates in two dimensions: the span dimension (I-address content matching) and the orgl dimension (document/link origin scoping). The span dimension filter works correctly — `find_links` returns only links whose endpoints share I-addresses with the query. However, the orgl dimension filter is disabled by a code bug (`TRUE||!homeset` in `sporglset2linkset`). The actual search boundary in the orgl dimension is a hardcoded width of 100 tumbler digits starting from zero, set via `nullhomeset.width.mantissa[0] = 100`. This is effectively unbounded for any realistic deployment.

**Why it matters for spec:** The `SpanEnfilade` query model from Finding 0012 (`find_links(specset) = {link | endpoints(link) ∩ query_range ≠ ∅}`) is correct for the span dimension. But the intended 2D query — filtering by both content identity AND orgl origin — is reduced to a 1D query on content identity alone. The spec should model `find_links` as: `find_links(from, to, three) = {link ∈ all_links | endpoint_iaddrs(link) ∩ query_iaddrs ≠ ∅}` with no orgl scoping, reflecting the actual implementation. If the spec intends to model the design rather than the code, the orgl-range parameter should be included but annotated as unimplemented.

**Code references:**
- `sporgl.c:222-237` — `sporglset2linkset()` replaces homeset with hardcoded range
- `sporgl.c:239-269` — `sporglset2linksetinrange()` performs actual search using the overridden range

**Provenance:** Finding 0069

### EC-FIND-LINKS-GLOBAL

**What happens:** Because the orgl range parameter is ignored, all `find_links` calls are effectively global across the entire orgl address space. A call intended to find links only within a specific document will also return links from every other document, as long as the span-dimension (I-address) match succeeds. This interacts with transclusion: since transcluded content shares I-addresses across documents, a `find_links` scoped to document A would return links from document B if they share content — and with the orgl filter disabled, this is the only possible behavior anyway.

**Why it matters for spec:** This edge case means that no `find_links` result set can be attributed to a single document by orgl scoping. All link discovery is purely content-identity-based. This simplifies the spec model (no need for per-document link queries), but it also means there is no way to ask "what links exist within this document only" — the system has no such capability. Bounded model checking (Alloy) should verify that `find_links` results are identical regardless of what orgl range is passed.

**Code references:**
- `sporgl.c:222-226` — the `TRUE||` guard that makes all searches global
- Related: Finding 0026 documents link discovery via content identity, which is the only filtering mechanism that actually functions

**Provenance:** Finding 0069
