# Finding 0005 Analysis

## Entries

### INV-LINK-CONTENT-TRACKING

**What happens:** Links track content identity across all document modifications — insertions before a linked span, deletions of adjacent text, and modifications to target documents all leave links valid and findable. This finding confirms the invariant with a full matrix: all 17 link scenarios pass after Bug 0008 client fixes. Specifically, three survivability scenarios validate that non-overlapping edits never invalidate links: inserting before the linked span, deleting adjacent (non-overlapping) text, and modifying the target document.

**Why it matters for spec:** Confirms the invariant from Finding 0004: `forall link : Link, op : Operation :: content_ids(link.source) ⊆ all_content_ids(system) ==> findable(link)`. The 17-scenario pass provides stronger empirical backing — the invariant holds across insert, remove, vcopy, and their combinations with links on both source and target endpoints.

**Code references:** Tests `link_survives_source_insert`, `link_survives_source_delete_adjacent`, `link_survives_target_modify` (all PASS)

**Provenance:** Finding 0005

### ST-REMOVE

**What happens:** Deletion interacts with link endpoints in two distinct ways depending on overlap:

1. **Partial deletion of linked span:** The link survives and its source resolves to the remaining content. Deleting "hyper" from a link on "hyperlink" (9 chars) leaves the link pointing to "link" (4 chars). The link endpoint adjusts to the subset of content identities that remain referenced.

2. **Full deletion of linked span:** The link object still exists in the link enfilade. `follow_link()` succeeds but returns an empty span. However, `find_links()` on the document no longer returns the link — there are no content identities left in the document to match against.

**Why it matters for spec:** Extends the ST-REMOVE postcondition for links. After remove: `effective_source(link) = content_ids(link.source) ∩ all_referenced_content(system_after)`. When this intersection is empty, the link exists but is undiscoverable via content-based search. The asymmetry between `follow_link` (traverses the link object directly, always works) and `find_links` (searches by content identity intersection, fails when no content remains) is a key behavioral distinction the spec must capture.

**Concrete example:**
- Partial delete: Link on "hyperlink" (C₁..C₉) → delete "hyper" (C₁..C₅) → link resolves to "link" (C₆..C₉)
- Full delete: Link on "here" (C₁..C₄) → delete "here" → `follow_link()` returns empty, `find_links(doc)` returns nothing

**Code references:** Tests `link_source_partial_delete` (PASS), `link_when_source_span_deleted` (PASS), `link_when_target_span_deleted` (PASS)

**Provenance:** Finding 0005

### INT-LINK-TRANSCLUSION

**What happens:** When content with a link is transcluded (vcopy'd) to another document, the link is discoverable from the new location. Creating a link on "here" in document A, then vcopy'ing "here" to document C, makes `find_links()` on document C return the original link. This works because vcopy shares content identities, and link discovery is indexed by content identity.

**Why it matters for spec:** Confirms the interaction property from Finding 0004: `vcopy(content_ids(link.source), doc_source, doc_target) ==> findable(link, doc_target)`. Link discovery is a function of content identity presence in a document, not of which document was active when the link was created. The spec should define `find_links(specset)` as returning all links whose endpoint content identities intersect with the content identities referenced by the specset.

**Concrete example:**
- Document A: "Click [here] for details", link on "here" (content identity C₁)
- Document C: vcopy "here" from A → C references C₁
- `find_links(C)` → returns the link originally created in A's context

**Code references:** Test `link_with_vcopy_source` (PASS)

**Provenance:** Finding 0005

### EC-ORPHANED-LINK

**What happens:** When the entire content of a link's source span is deleted from all documents, the link enters an "orphaned" state: it exists in the link enfilade and can be traversed via `follow_link()` (returning empty content), but it cannot be discovered via `find_links()` because no document contains content identities matching its endpoints. The finding notes this as an open question — whether there should be a mechanism to find orphaned links.

**Why it matters for spec:** This is an edge case at the boundary of link persistence and link discoverability. The spec must distinguish between link existence (`link ∈ links(system)`, always true once created) and link discoverability (`∃ doc :: find_links(doc) returns link`, conditional on content reference survival). The predicate `orphaned(link) ≡ link ∈ links(system) ∧ ¬∃ doc :: discoverable(link, doc)` identifies links that exist but are unreachable via content search. Whether the system should provide an alternative discovery mechanism for orphaned links is a design question.

**Concrete example:**
- Link on "here" in document A
- Delete "here" from A (and no other document references those content identities)
- `follow_link(link)` → succeeds, returns empty span
- `find_links(A)` → does not return the link
- Link exists but is undiscoverable through normal content-based search

**Code references:** Test `link_when_source_span_deleted` (PASS)

**Provenance:** Finding 0005

### SS-LINK-ENDPOINT

**What happens:** Links are bidirectional — they have both source and target endpoints, and can be discovered by searching either endpoint. The `find_links` operation accepts source specs, target specs, or both. Searching `find_links(source_specs)` finds links by source content identity; searching `find_links(NOSPECS, target_specs)` finds links by target content identity. This confirms that both endpoints are indexed by content identity.

**Why it matters for spec:** The link state structure must reflect bidirectional indexing: `Link = (source: set<ContentId>, target: set<ContentId>, type: Tumbler)`. The `find_links` operation has two modes: `find_links(specset, NOSPECS) = {link | content_ids(link.source) ∩ content_ids(specset) ≠ ∅}` and `find_links(NOSPECS, specset) = {link | content_ids(link.target) ∩ content_ids(specset) ≠ ∅}`. Both endpoints participate symmetrically in discovery.

**Code references:** Test `find_links_by_target` (PASS), test `bidirectional_links` (PASS)

**Provenance:** Finding 0005
