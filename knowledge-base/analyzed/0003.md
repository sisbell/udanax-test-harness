# Finding 0003 Analysis

## Entries

### SS-SPECSET

**What happens:** A SpecSet is an ordered collection of VSpecs. Each VSpec identifies a span within a document via three components: a document ID (tumbler address), a start position (tumbler), and a width (tumbler representing span size). A SpecSet can contain VSpecs referencing different documents and non-contiguous regions within the same document. The ordering of VSpecs within a SpecSet is significant — results reflect the order in which VSpecs are specified.

**Why it matters for spec:** The formal spec needs: `VSpec = (doc: Tumbler, start: Tumbler, width: Tumbler)` and `SpecSet = seq<VSpec>` (a sequence, not a set, because order matters). The sequence semantics are operationally significant — retrieve concatenates in VSpec order, vcopy places content in VSpec order. The cross-document capability means SpecSet operations are not scoped to a single document: `forall ss : SpecSet :: |{v.doc | v in ss}| >= 1` (a SpecSet can reference one or many documents).

**Concrete example:**
- Document: "The quick brown fox jumps over the lazy dog"
- SpecSet with two VSpecs: chars 5-9 ("quick"), chars 36-39 ("lazy")
- Retrieve returns: "quicklazy" — concatenated in VSpec order

**Code references:** Tests `retrieve_noncontiguous_spans`, `retrieve_multiple_documents`

**Provenance:** Finding 0003

### ST-VCOPY

**What happens:** When vcopy operates on a SpecSet containing multiple non-contiguous spans, each span is copied independently and each gets its own identity mapping in the target document. The compare operation subsequently returns multiple shared regions — one per copied span — confirming that per-span identity is preserved, not merged into a single region. Cross-document vcopy (SpecSet referencing spans from multiple source documents) works atomically; all spans are placed into the target in a single operation.

**Why it matters for spec:** This extends the vcopy postcondition: `references(target) = references(target_before) ∪ ⋃{content_ids(vspec) | vspec in specset}`. Crucially, identity is preserved per-VSpec, not per-SpecSet: each VSpec's content identities remain independently trackable. The atomicity property means multi-span vcopy either completes for all VSpecs or none — there is no partial copy state. For formal spec: `|shared_regions(compare(source, target))| >= |specset|` when all spans have distinct content.

**Concrete example:**
- Source: "First part. Middle part. Last part."
- vcopy SpecSet with two VSpecs: "First part" (pos 1-10), "Last part" (pos 26-35), skipping middle
- Target: "Copied: First partLast part."
- compare returns TWO shared regions:
  - "First part" (source 1-10 <-> target 9-18)
  - "Last part" (source 26-35 <-> target 19-28)

**Code references:** Tests `vcopy_multiple_spans`, `vcopy_from_multiple_documents`

**Provenance:** Finding 0003

### FC-SPECSET-COMPARE

**What happens:** When comparing documents using SpecSets, only the specified spans are considered for identity matching. Content outside the SpecSet boundaries is excluded from comparison results. This means compare is not a whole-document operation — it respects the SpecSet as a filter on which content participates.

**Why it matters for spec:** This defines a frame condition on compare: `compare(specset_A, specset_B)` reports only identity overlaps between content referenced by specset_A and content referenced by specset_B. Content in either document but outside the specified spans does not appear in results. Formally: `shared_regions(compare(ss_A, ss_B)) ⊆ {c | c in content_ids(ss_A) ∩ content_ids(ss_B)}`. This is a significant constraint — compare is a filtered operation, not a global one.

**Concrete example:**
- DocA: "Shared prefix. A middle. Shared suffix."
- DocB: "Shared prefix. B middle. Shared suffix."
- Compare full documents: reports "Shared prefix. " and " Shared suffix." as shared
- Compare only middles ("A middle" vs "B middle"): no shared content reported

**Code references:** Test `compare_multispan_specsets`

**Provenance:** Finding 0003

### INV-SPECSET-ORDER

**What happens:** SpecSet operations preserve VSpec ordering in their results. Retrieve concatenates content in VSpec order. Vcopy places content in VSpec order. This is consistent across all multi-span operations tested: retrieve, vcopy, and compare all respect the sequence ordering of the SpecSet.

**Why it matters for spec:** This is an invariant on SpecSet processing: `forall op in {retrieve, vcopy} :: result_order(op(specset)) = vspec_order(specset)`. The formal spec must model SpecSet as a sequence (not a set or bag) and all SpecSet-consuming operations must process VSpecs in sequence order. This ensures deterministic behavior — the same SpecSet always produces the same result regardless of implementation details.

**Code references:** Tests `retrieve_noncontiguous_spans`, `retrieve_multiple_documents`

**Provenance:** Finding 0003
