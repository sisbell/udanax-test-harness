# Finding 0037 Analysis

## Entries

### ST-LINK-CREATE

**What happens:** When `domakelink` receives a V-span that maps to non-contiguous I-addresses (due to transclusion from multiple sources), the backend automatically splits the V-span into multiple I-spans (sporgls) in the link endset — one per contiguous I-address region. The front end does NOT need to pre-split the V-span. The critical mechanism is the inner loop in `vspanset2sporglset` (sporgl.c:49-58), which iterates over every I-span returned by `vspanset2ispanset` and creates a separate sporgl for each.

The conversion chain is: V-span → `vspanset2ispanset` → `permute` → `span2spanset` → `retrieverestricted` to find all context entries → separate I-span per contiguous I-address region → separate sporgl per I-span.

**Why it matters for spec:** The postcondition for `create_link` must specify that one V-span input may produce multiple I-span entries in the link endset. Formally: `create_link(home, source_vspan, target_vspan, type)` yields `link.source_endset = { sporgl(origin=i.start, width=i.width, doc=source_doc) | i ∈ V_to_ISpans(source_doc, source_vspan) }` where `V_to_ISpans` returns one I-span per contiguous I-address region. The cardinality of `link.source_endset` may exceed the cardinality of the input vspan set. This is a pure consequence of the V→I mapping; the operation does not modify any document state.

**Code references:**
- `do1.c:173-197` — `domakelink`, main link creation entry point
- `sporgl.c:35-65` — `vspanset2sporglset`, V-span to sporgl conversion with splitting
- `sporgl.c:49-58` — inner loop creating one sporgl per I-span
- `orglinks.c:397-402` — `vspanset2ispanset`, delegates to `permute`
- `orglinks.c:404-422` — `permute`, finds all contiguous I-regions
- `orglinks.c:425-454` — `span2spanset`, uses `retrieverestricted` to get contexts

**Concrete example:**
```
Document C contains "AABB" at V 1.1..1.4 where:
  "AA" was transcluded from document A (I-addresses from A's permascroll region)
  "BB" was transcluded from document B (I-addresses from B's permascroll region)

create_link(source = V-span 1.1 width 0.4 in doc C, ...)

Input:  1 V-span covering all of "AABB"
Output: 2 sporgls in source endset:
  sporgl₁: origin = I-addr(A,"AA"), width = 0.2, doc = C
  sporgl₂: origin = I-addr(B,"BB"), width = 0.2, doc = C

The I-addresses for A and B are non-contiguous in the permascroll,
so they cannot be represented as a single I-span.
```

**Provenance:** Finding 0037

### SS-LINK-ENDPOINT

**What happens:** A link endset is not simply a set of V-spans; internally it is a set of I-spans (sporgls). A single user-visible V-span may correspond to multiple I-spans in the endset when the V-span covers content transcluded from multiple sources. Each I-span independently tracks its content identity. This means the endset structure reflects the content identity graph, not the visual layout.

**Why it matters for spec:** The link endpoint model must be: `Endset = set<Sporgl>` where `|Endset| >= |input_vspans|`. The endset cardinality is determined by the I-address structure of the referenced content, not by the number of V-spans provided at link creation time. When retrieving endsets, `retrieve_endsets` reports multiple V-spans corresponding to the stored I-spans, one per contiguous I-region.

**Code references:**
- `sporgl.c:35-65` — `vspanset2sporglset` produces the multi-sporgl endset
- `sporgl.c:97+` — `linksporglset2specset` converts back to V-spans for retrieval

**Provenance:** Finding 0037

### INT-LINK-TRANSCLUSION

**What happens:** The automatic splitting of V-spans into I-spans at link creation time is a direct consequence of how transclusion composes content from multiple sources. When document C transcludes "AA" from A and "BB" from B, the contiguous V-span 1.1..1.4 in C maps to two disjoint I-address regions. The link subsystem handles this transparently: `vspanset2sporglset` calls `vspanset2ispanset` which walks the POOM (permutation matrix) to discover all I-address regions, producing one I-span per contiguous region. The front end sees a simple contiguous selection; the backend decomposes it into identity-preserving references.

This is the same mechanism that causes endset fragmentation after pivot operations (EC-PIVOT-LINK-FRAGMENTATION from finding 0019): any operation that makes previously contiguous I-addresses non-contiguous in V-space triggers the same splitting logic in `vspanset2sporglset`.

**Why it matters for spec:** The interaction between transclusion and link creation is: `create_link` is compositional over the content identity structure. The spec must model `V_to_ISpans(doc, vspan)` as returning the partition of the vspan's content into maximal contiguous I-address runs. This function is shared between link creation and endset reporting, ensuring round-trip consistency.

**Code references:**
- `sporgl.c:35-65` — shared splitting logic used by both link creation and other operations
- `orglinks.c:397-454` — `vspanset2ispanset` → `permute` → `span2spanset` chain

**Provenance:** Finding 0037

### EC-LINK-PARTIAL-SURVIVAL

**What happens:** Because each I-span in a link endset independently tracks its content, partial survival is possible. If document A (source of "AA") is deleted but document B (source of "BB") remains, the link endset retains the I-span for "BB" while the I-span for "AA" becomes unresolvable. The link survives partially — it still points to the "BB" content.

**Why it matters for spec:** The link validity predicate is per-I-span, not per-endset: `valid_endset(endset) = ∃ sporgl ∈ endset :: resolvable(sporgl)`. A link with a partially valid endset is still a valid link. This extends the ST-REMOVE postcondition (from finding 0004): content removal affects individual sporgls within an endset independently, never atomically invalidating the entire endset.

**Code references:**
- Implied by the per-sporgl structure in `sporgl.c:49-58`

**Provenance:** Finding 0037
