# Finding 0076 Analysis

## Entries

### SS-POOM-BOTTOM-CRUM

**What happens:** POOM bottom crums store dual-space coordinates with asymmetric tumbler precision. Each crum contains an origin and width in both V-space and I-space, but the tumbler representations have different lengths: I-addresses use 6-9 tumbler digits (e.g., `0.0.0.0.0.0.0.0.11`), while V-addresses use 2 tumbler digits (e.g., `0.5`, `1.1`). The widths mirror their respective address-space precision — an I-width is a full-length I-space tumbler, while a V-width is encoded at V-space precision using the V-address tumbler length as the exponent.

A POOM bottom crum has the structure:
```
BottomCrum = {
  origin: { dsas[I]: Tumbler,  dsas[V]: Tumbler },
  width:  { dsas[I]: Tumbler,  dsas[V]: Tumbler }
}
```

Where `tumblerlength(origin.dsas[I]) >> tumblerlength(origin.dsas[V])` in practice (9 vs 2 digits).

**Why it matters for spec:** The state structure for POOM crums must model each dimension's precision independently. A formal `BottomCrum` type cannot use a single tumbler type for both dimensions — the V and I components have structurally different representations of the same numeric width value. Any spec that models POOM crums must account for this precision asymmetry, particularly in width fields.

**Code references:**
- `orglinks.c:100-117` — `insertpm` creates bottom crums with asymmetric V/I encoding
- `tumble.c:259-262` — `tumblerlength()` returns `nstories(t) - t->exp`

**Concrete example:**
```
After inserting 11 characters at V-position 1.1:
  Crum I-origin: 0.0.0.0.0.0.0.0.11  (9 digits)
  Crum I-width:  0.0.0.0.0.0.0.0.11  (9 digits, direct copy from I-space span)
  Crum V-origin: 0.5                  (2 digits)
  Crum V-width:  0.11                 (2 digits, re-encoded at V-space precision)

Both widths represent the value 11, but at different tumbler precisions.
```

**Provenance:** Finding 0076

### ST-INSERT-VWIDTH-ENCODING

**What happens:** During INSERT, `insertpm` computes the V-width of a POOM bottom crum by extracting the integer value from the I-width and re-encoding it as a tumbler at V-space precision. The three-step process is:

1. `shift = tumblerlength(vsaptr) - 1` — compute exponent from V-address length
2. `inc = tumblerintdiff(&lwidth, &zero)` — extract integer value from I-width
3. `tumblerincrement(&zero, shift, inc, &crumwidth.dsas[V])` — create V-width tumbler with `exp = -shift`, `mantissa[0] = inc`

This produces a tumbler representing `inc * 10^(-shift)`. The I-width is copied directly without transformation: `movetumbler(&lwidth, &crumwidth.dsas[I])`.

**Why it matters for spec:** The INSERT postcondition on POOM crums must specify that V-width and I-width are not equal as tumblers, even though they encode the same numeric width. Formally: `value(crum.width.dsas[V]) == value(crum.width.dsas[I])` but `crum.width.dsas[V] != crum.width.dsas[I]` as tumbler representations. The V-width exponent is determined by the V-address length, not the I-address length. This is a derived encoding, not a copy.

**Code references:**
- `orglinks.c:105-117` — V-width computation in `insertpm`
- `tumble.c:599-623` — `tumblerincrement` zero-tumbler special case: sets `exp = -rightshift`, `mantissa[0] = bint`

**Concrete example:**
```
Input: vsaptr = "1.1" (tumblerlength = 2), lwidth represents 11 characters

Step 1: shift = tumblerlength("1.1") - 1 = 2 - 1 = 1
Step 2: inc = tumblerintdiff(lwidth, zero) = 11
Step 3: tumblerincrement(zero, 1, 11, &V-width)
        → V-width tumbler: exp = -1, mantissa[0] = 11
        → Tumbler notation: 0.11

Meanwhile: I-width = 0.0.0.0.0.0.0.0.11 (copied directly)
```

**Provenance:** Finding 0076

### INV-WIDTH-VALUE-EQUIVALENCE

**What happens:** For any POOM bottom crum, the integer value encoded in the V-width always equals the integer value encoded in the I-width. The tumbler representations differ (different exponents, different digit counts), but extracting the numeric value via `tumblerintdiff` yields the same integer from both. This holds because the V-width is constructed from the I-width's integer value — the construction preserves the value while changing the encoding precision.

**Why it matters for spec:** This is a structural invariant on POOM crums: `forall crum c :: tumblerintdiff(c.width.dsas[V], zero) == tumblerintdiff(c.width.dsas[I], zero)`. This invariant must hold after every operation that creates or modifies bottom crums. It enables value-based width comparison across address spaces — code that needs to compare V-widths with I-widths must use `tumblerintdiff` to extract values rather than `tumblercmp` on the raw tumblers.

**Code references:**
- `orglinks.c:105-117` — V-width construction preserves I-width value
- `tumble.c:599-623` — `tumblerincrement` encodes the same integer at a different exponent

**Provenance:** Finding 0076

### EC-VWIDTH-ZERO-ADDRESS

**What happens:** The V-width exponent computation `shift = tumblerlength(vsaptr) - 1` has an edge case when `vsaptr` is the zero tumbler. If `tumblerlength(vsaptr) = 0`, then `shift = -1`, producing a V-width with `exp = 1`. This would create a tumbler in a different magnitude range than normal V-widths (which have negative exponents). The original developer noted suspicion about this shift computation in a 1985 comment: `/*I'm suspissious of this shift <reg> 3/1/85 zzzz*/`.

**Why it matters for spec:** The precondition for V-width encoding should specify that `vsaptr` is a non-zero tumbler with `tumblerlength(vsaptr) >= 1`. If the zero-address case can occur, the resulting V-width has qualitatively different structure (positive exponent vs negative). A formal spec should either prove this case cannot arise (V-addresses are always non-zero during INSERT) or define behavior for it.

**Code references:**
- `orglinks.c:107` — `shift = tumblerlength(vsaptr) - 1` with suspicious-shift comment at line 106

**Provenance:** Finding 0076
