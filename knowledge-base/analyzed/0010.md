# Finding 0010 Analysis

## Entries

### INV-SUBSPACE-CONVENTION

**What happens**: The unified enfilade storage model treats all V→I mappings identically — `insertpm`, `docopy`, `retrieverestricted`, and `permute` are all type-agnostic. The convention that V-position `0.x` holds link orgl ISAs and `1.x` holds permascroll I-addresses is enforced solely by callers. The validation function `acceptablevsa()` in `do2.c:110-113` unconditionally returns `TRUE`, providing no runtime enforcement. This means it is possible to: (a) insert text at position `0.x`, corrupting the link subspace; (b) insert link references at position `1.x`, corrupting the text subspace; (c) create semantically invalid documents that violate the subspace convention.

**Why it matters for spec**: The convention-over-enforcement design means the subspace invariant is not a storage-layer property but a property that must be verified as a postcondition of every well-formed operation. In Dafny, this would be modeled as a `requires` clause on document mutation operations asserting that text content targets `V >= 1.0` and link references target `V < 1.0`. The `acceptablevsa` stub is a clear signal that enforcement was intended but never implemented.

**Code references**:
- `do2.c:110-113` — `acceptablevsa()` always returns `TRUE`
- `do1.c:45-65` — `docopy()` calls `acceptablevsa()` but gets no validation
- `do1.c:162-171` — `dodeletevspan()` performs no subspace check

**Concrete example**:
```
acceptablevsa(vsaptr, orglptr) always returns TRUE

Consequence: docopy(doc, vsa=0.5, text_ispanset) succeeds
  → permascroll I-address stored in link subspace
  → retrieve_contents on 0.x returns garbage (permascroll addr treated as link ISA)
  → find_links on 0.x finds no valid link orgl

Similarly: docopy(doc, vsa=1.5, link_ispanset) succeeds
  → link orgl ISA stored in text subspace
  → retrieve_contents on 1.x dereferences link ISA in permascroll → NULL/garbage
```

**Provenance**: Finding 0010, also Finding 0009

### PRE-RETRIEVE-CONTENTS

**What happens**: The `doretrievev` operation (`do1.c:376-384`) converts a specset to I-spans via `specset2ispanset`, then looks up content in the permascroll via `ispanset2vstuffset(taskptr, granf, ispanset, vstuffsetptr)`. It passes `granf` (the global enfilade) which expects permascroll I-addresses. If the specset includes V-positions from the link subspace (`0.x`), the corresponding I-addresses are link orgl ISAs, not permascroll addresses. Looking up a link ISA in the permascroll produces NULL or garbage bytes — a silent failure.

**Why it matters for spec**: This is a missing precondition. `doretrievev` requires that the input specset be restricted to the text subspace (`V >= 1.0`). The spec should either: (a) state this as a precondition, or (b) require the implementation to filter specset to text subspace before permascroll lookup. The silent failure mode (returning garbage rather than an error) makes this especially important for formal verification — an uncaught precondition violation produces unsound results rather than crashing.

**Code references**:
- `do1.c:376-384` — `doretrievev()` passes all I-addresses to permascroll lookup
- `orglinks.c:389-422` — `permute()` type-agnostic V↔I conversion

**Concrete example**:
```
Document has: V 0.1 → I 1.1.0.1.0.2 (link ISA)
              V 1.1..1.16 → I 2.1.0.5.0.1.. (permascroll)

doretrievev(specset covering V 0.0..2.0):
  specset2ispanset → includes I-address 1.1.0.1.0.2 from link subspace
  ispanset2vstuffset(granf, {1.1.0.1.0.2, 2.1.0.5.0...}):
    permascroll lookup of 1.1.0.1.0.2 → not a permascroll address → NULL/garbage
    permascroll lookup of 2.1.0.5.0.1 → valid text bytes
  Result: client receives corrupt content (garbage mixed with valid text)
```

**Provenance**: Finding 0010

### PRE-VCOPY

**What happens**: The `docopy` operation (`do1.c:45-65`) copies I-spans from a source specset into a destination document at V-position `vsaptr`. It performs no validation that the source I-address types match the destination subspace. Text I-addresses (permascroll) can be copied into the link subspace (`0.x`), and link ISAs can be copied into the text subspace (`1.x`). The `acceptablevsa` check is a no-op. This is especially dangerous during transclusion from documents with links: `retrieve_vspanset` returns spans for both `0.x` and `1.x`, and if a caller creates a specset from the full vspanset, `vcopy` copies ALL content including link references to the destination.

**Why it matters for spec**: The formal spec for `docopy` must include a precondition that the I-address types in the source specset are compatible with the destination V-subspace. Specifically: if `vsaptr` is in the text subspace (`>= 1.0`), all source I-addresses must be permascroll addresses; if in the link subspace (`< 1.0`), they must be link orgl ISAs. Without this, transclusion from a document with links silently copies link ISAs as text content, producing semantically meaningless bytes.

**Code references**:
- `do1.c:45-65` — `docopy()` with no type validation
- `do1.c:57` — `acceptablevsa(vsaptr, docorgl)` always returns TRUE
- `do2.c:110-113` — `acceptablevsa()` stub

**Concrete example**:
```
Document A: V 0.1 → link ISA 1.1.0.1.0.2
            V 1.1..1.16 → permascroll text

User vcopies full content of A into document B at V 1.1:
  retrieve_vspanset(A) → {0.1 for 0.1, 1.1 for 0.16}  (both subspaces)
  specset from full vspanset includes link ISA
  docopy(B, vsa=1.1, specset) → copies link ISA 1.1.0.1.0.2 into B's text subspace
  B now contains: V 1.1 → I 1.1.0.1.0.2 (link ISA masquerading as text)
  retrieve_contents(B) → dereferences link ISA in permascroll → garbage bytes
```

**Provenance**: Finding 0010

### PRE-DELETE

**What happens**: The `dodeletevspan` operation (`do1.c:162-171`) deletes a V-span from a document without checking which subspace the span falls in. Deleting V-range `0.x` removes link references from the document — the link orgls still exist in the system, but the document loses its references to them, creating orphaned links. The operation is technically valid but semantically dangerous: the document can no longer find its own links.

**Why it matters for spec**: The spec should note that `dodeletevspan` on the link subspace severs the document-to-link association without destroying the link itself. This is a weaker deletion than destroying the link — the link's endpoints still reference content, but the document has no record of the link. A formal model should distinguish: (a) deleting text content (removes V→I mappings for permascroll addresses), (b) deleting link references (removes V→I mappings for link ISAs, orphaning links).

**Code references**:
- `do1.c:162-171` — `dodeletevspan()` no subspace check

**Concrete example**:
```
Pre-state:
  Document has: V 0.1 → link ISA 1.1.0.1.0.2
                V 1.1..1.16 → permascroll text
  Link orgl 1.1.0.1.0.2 exists with endpoints

dodeletevspan(doc, vspan={0.1 for 0.1}):
  Removes V 0.1 → I 1.1.0.1.0.2 mapping from document

Post-state:
  Document has: V 1.1..1.16 → permascroll text (links gone)
  Link orgl 1.1.0.1.0.2 still exists (orphaned — no document references it)
  find_links on document → finds nothing
  Link's endpoints still reference content positions
```

**Provenance**: Finding 0010

### EC-RETRIEVE-VSPANSET-BOTH-SUBSPACES

**What happens**: The `retrieve_vspanset` operation returns the full V-extent of a document, including both the link subspace (`0.x`) and text subspace (`1.x`). Any caller that uses "full document extent" as input to another operation (compare_versions, vcopy, retrieve_contents) inadvertently includes link references. This is the root cause of multiple abstraction leaks: the unified storage model provides no built-in way to request "text content only."

**Why it matters for spec**: The spec should either: (a) define `retrieve_vspanset` as returning all subspaces and require callers to filter, or (b) provide a variant that returns text-only spans. Either choice creates a formal obligation — if (a), every operation using vspanset results must state a subspace precondition; if (b), the variant's postcondition must guarantee `V >= 1.0` for all returned spans.

**Code references**:
- Debug output evidence: `<VSpec in 1.1.0.1.0.1, at 0 for 0.1, at 1 for 1>` (both subspaces)

**Concrete example**:
```
Document with text and one link:
  retrieve_vspanset → {V 0.1 for 0.1, V 1.1 for 0.16}

Caller uses full vspanset for compare_versions → crash (Bug 0009)
Caller uses full vspanset for vcopy → copies link ISAs as text
Caller uses full vspanset for retrieve_contents → garbage bytes for link entries
```

**Provenance**: Finding 0010

### INT-LINK-RETRIEVAL

**What happens**: The `find_links` operation searches the span-f (link enfilade) by I-address to discover which links are attached to content. This only works with permascroll I-addresses from the text subspace (`1.x`). Searching with link ISAs from `0.x` is meaningless — link orgls are not indexed by other link ISAs. The caller must know to use text I-addresses, not link reference I-addresses.

**Why it matters for spec**: The spec for `find_links` must state a precondition that the search I-addresses are permascroll addresses (from text subspace), not link orgl ISAs. This creates a dependency between the retrieval subsystem and the subspace convention — `find_links` implicitly requires the caller to understand the dual-enfilade structure.

**Code references**:
- span-f (link enfilade) indexes links by content I-address, not by link ISA

**Provenance**: Finding 0010
