# Finding 0001 Analysis

## Entries

### SS-TUMBLER

**What happens:** Tumblers are digit sequences with no inherent structure requirements. The `.0.` field dividers are a docuverse convention for addresses starting with `1`, giving the pattern `Node.0.User.0.Doc.0.Element`. A tumbler like `1.1.0.1.0.2` is valid — it represents a document address without element-level fields. A tumbler like `1.1.0.1.0.1.0.2.1` addresses a specific element within a document. The distinction between document-level and element-level addressing is convention, not type enforcement.

**Why it matters for spec:** The type model for tumblers must represent them as unconstrained digit sequences. The document/element decomposition is a predicate over tumblers, not a structural subtype. Formal spec needs: a base type `Tumbler = seq<nat>`, a predicate `IsDocAddress(t)` vs `IsElementAddress(t)`, and the convention that `.0.` separates fields in docuverse addresses.

**Concrete example:**
- `1.1.0.1.0.2` — valid tumbler, addresses document 2 (no element field)
- `1.1.0.1.0.1.0.2.1` — valid tumbler, addresses element 1 within document 1 link 2

**Provenance:** Finding 0001

### PRE-SPECSET

**What happens:** The backend's `specset2sporglset()` validates specsets at document granularity only. It checks that the referenced document exists but does not enforce element-level tumbler structure. A specset referencing a valid document but with missing or malformed element fields is accepted without error.

**Why it matters for spec:** This defines the precondition boundary for specset-consuming operations (link retrieval, etc.). The precondition is: `exists doc : doc_id(tumbler) in created_documents`. There is explicitly no precondition requiring well-formed element addressing — that responsibility falls to the client. This means the backend's validation is weaker than the full docuverse convention would imply.

**Code references:** `specset2sporglset()` in the backend performs the document-existence check.

**Concrete example:**
- `VSpec(Address(1,1,0,1,0,2), [...])` — accepted if document 2 exists, even though this is a document-level address rather than an element address
- `VSpec(Address(1,1,0,1,0,1,0,2,N), [...])` — the correctly formed element-level address for document 1, link N

**Provenance:** Finding 0001

### INT-CLIENT-VALIDATION

**What happens:** Because the backend does not enforce element-level tumbler structure, clients must construct correct element addresses themselves. Malformed addresses (e.g., document-level tumblers used where element-level are expected) are silently accepted by the backend. Bug 0005 documented a case where pyxi used document-level addresses for link types, which the backend accepted without error.

**Why it matters for spec:** This defines an interaction boundary: the backend provides document-existence validation, and the client is responsible for element-level correctness. In a formal model, this means the system-level correctness property requires a conjunction of backend invariants AND client-side address construction rules. The backend alone does not guarantee well-formed specsets.

**Provenance:** Finding 0001
