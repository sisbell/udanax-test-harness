# Finding 0061 Analysis

## Entries

### SS-ADDRESS-SPACE
**What happens:** I-address allocation does not use a session-local counter. Each INSERT queries the granfilade tree via `findpreviousisagr` to find the highest existing I-address below an upper bound, then increments by 1. The allocation is purely derived from current tree state — there is no cached "next available" pointer. This means allocation is stateless with respect to the session: any session querying the same granfilade tree will allocate identically.

**Why it matters for spec:** The allocation function can be modeled as a pure function of the granfilade state: `next_iaddr(granf) = max_iaddr(granf) + 1`. No hidden session state participates in allocation. This simplifies formal reasoning because the precondition for allocation depends only on the granfilade, not on session history.

**Code references:** `findisatoinsertmolecule` in `backend/granf2.c:158-181` — calls `findpreviousisagr` then `tumblerincrement(&lowerbound, 0, 1, isaptr)`. `findpreviousisagr` in `backend/granf2.c:255-278` — tree traversal to find highest I-address.

**Concrete example:**
- Granfilade contains I-addresses I.1, I.2, I.3 (even if I.2 was deleted from V-space)
- `findpreviousisagr` returns I.3 as the highest
- `tumblerincrement` produces I.4 as the next allocation
- Session state plays no role; any INSERT in any session would allocate I.4

**Provenance:** Finding 0061

### INV-MONOTONIC
**What happens:** I-address allocation is strictly monotonically increasing and completely unaffected by DELETE or REARRANGE operations. Since DELETE modifies only the spanfilade (V-to-I mappings via `deletevspanpm`) and never touches the granfilade, deleted content's I-addresses remain in the granfilade tree and continue to influence allocation. Interleaved INSERT-DELETE-INSERT sequences produce contiguous, gap-free I-address sequences: INSERT "AAA" allocates I.1–I.3, DELETE removes a character (V-space only), INSERT "BBB" allocates I.4–I.6 (not reusing I.2).

**Why it matters for spec:** Strengthens the monotonic invariant: `∀ alloc_a, alloc_b : time(alloc_a) < time(alloc_b) ⟹ iaddr(alloc_b) > iaddr(alloc_a)`, and this holds regardless of intervening DELETE or REARRANGE operations. No operation in the system can cause an I-address to be freed or reused. Formally: `∀ op ∈ {DELETE, REARRANGE} : granf_state_after(op) = granf_state_before(op)`. The monotonic invariant is unconditional — it holds across all operation interleavings.

**Code references:** `findisatoinsertmolecule` in `backend/granf2.c:158-181` — allocation by query-and-increment. `deletevspanpm` in `backend/edit.c` — DELETE modifies spanfilade only. `insertseq` in `backend/insert.c:17-70` — inserts content at allocated I-address.

**Concrete example:**
```
INSERT "AAA" → allocates I.1, I.2, I.3; V-span width 0.3
DELETE pos 1.2 → V-span shrinks to 0.2; granfilade still has I.1, I.2, I.3
INSERT "BBB" → allocates I.4, I.5, I.6 (NOT reusing I.2); V-span width 0.5
DELETE pos 1.3-1.4 → V-span shrinks to 0.3; granfilade has I.1–I.6
INSERT "CCC" → allocates I.7, I.8, I.9; V-span width 0.6
```
Each INSERT always continues from the granfilade maximum, never filling gaps.

**Provenance:** Finding 0061

### FC-GRANF-ON-DELETE
**What happens:** DELETE and REARRANGE are frame-condition-preserving with respect to the granfilade. These operations modify only the spanfilade (V-to-I mappings) and leave the granfilade (I-space content storage) completely unchanged. Content inserted into the granfilade persists permanently at its I-address regardless of subsequent V-space operations.

**Why it matters for spec:** Frame condition: `∀ op ∈ {DELETE, REARRANGE} : granf_after(op) = granf_before(op)`. The granfilade is write-once-never-delete: only INSERT adds entries, and no operation removes them. This is the mechanism underlying the Xanadu principle "bytes never die, addresses never change." For the formal model, the granfilade state can be modeled as a monotonically growing set: `granf(t+1) ⊇ granf(t)` for all timesteps t.

**Code references:** `deletevspanpm` in `backend/edit.c` — calls only spanfilade operations, no granfilade modification. `dodeletevspan` in `backend/do1.c:162-171` — no call to any granf insertion or deletion function. Contrast with `insertseq` in `backend/insert.c:17-70` which does modify the granfilade.

**Provenance:** Finding 0061

### INV-NO-IADDR-REUSE
**What happens:** Deleted I-addresses are never reused. Since the granfilade is never modified by DELETE, and allocation always queries the granfilade for the current maximum, "gaps" in V-space created by DELETE do not create "gaps" in I-space. The I-address space grows strictly monotonically and permanently. There is no free-list, no gap-tracking, and no garbage collection of I-addresses.

**Why it matters for spec:** Formalizable as: `∀ i ∈ I-space : once_allocated(i) ⟹ always_allocated(i)`. Combined with INV-MONOTONIC, this means I-addresses form a contiguous, ever-growing sequence within each document's allocation range. The no-reuse guarantee is essential for transclusion integrity: if document B transcludes content from document A via shared I-addresses, deleting that content from A's V-space cannot cause the I-addresses to be reallocated to different content in a later INSERT.

**Code references:** `findisatoinsertmolecule` in `backend/granf2.c:158-181` — no free-list consulted, always queries tree maximum. `findpreviousisagr` in `backend/granf2.c:255-278` — returns the highest existing I-address, including those of deleted-from-V-space content.

**Concrete example:**
- Document has I.1, I.2, I.3. Delete the character at I.2 from V-space.
- Granfilade still contains I.1, I.2, I.3 (all three entries persist).
- Next allocation: `findpreviousisagr` returns I.3 → allocates I.4.
- I.2 is never reused, even though it is no longer mapped in any V-space.

**Provenance:** Finding 0061
