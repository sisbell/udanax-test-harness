# Finding 0073 Analysis

## Entries

### ST-REBALANCE-2D

**What happens:** In the 2D pairwise merge loop (`recombinend` at `recombine.c:120-128`), a single receiver node can absorb multiple donors in one pass. The inner `j` loop does **not** break after a successful merge — two `break` statements are commented out with the annotation "6/16/84", indicating an intentional design choice. After `takeovernephewsnd(&sons[i], &sons[j])` completes, the loop continues to `j+1, j+2, ...`, allowing `sons[i]` to absorb further donors.

Donor depletion uses NULL-marking in the sons array:
- **Full absorption** (`eatbrossubtreend`): All children transferred, donor freed, `*broptr = NULL` (recombine.c:180-182)
- **Partial absorption with depletion** (`takeovernephewsnd` stealing path): All nephews stolen one-by-one, donor becomes empty, freed, `*broptr = NULL` (recombine.c:194-200)
- **Partial absorption without depletion**: Donor retains some children, remains non-NULL, available for subsequent merge attempts by other receivers

The NULL guards in the loop (`sons[i] &&` and `sons[j] &&`) prevent dereferencing depleted donors. If a receiver itself becomes NULL (via being absorbed if the algorithm were symmetric — but it is not: `sons[i]` is always the receiver), the outer loop skips it.

This contrasts with 1D rebalancing (`recombineseq` at `recombine.c:38-68`), which uses **active** `break` statements after both `eatbrossubtreeseq` and `takeovernephewsseq`. The 1D algorithm absorbs at most one donor per pass; multiple passes are needed for full consolidation.

**Why it matters for spec:** The multi-donor absorption makes the 2D rebalance postcondition achievable in a single call: `post(recombinend(node)) ⟹ ∀ i,j ∈ children(node): i ≠ j ⟹ ¬ishouldbother(i,j)`. The 1D algorithm only guarantees progress (at least one merge per call if one is possible), not saturation. The formal model must distinguish these:
- `recombinend`: greedy saturation — single pass exhausts all merge opportunities
- `recombineseq`: incremental — one merge per invocation, requires repeated calls

The NULL-marking mechanism is the algorithm's bookkeeping for tracking which donors have been consumed. The formal model can abstract this as a set that shrinks: `active_children' ⊆ active_children` after each merge step.

**Code references:**
- `backend/recombine.c:120-128` — Phase 2 pairwise loop with commented-out `break` statements
- `backend/recombine.c:165-203` — `takeovernephewsnd`: sets `*broptr = NULL` on donor depletion
- `backend/recombine.c:180-182` — Full absorption path (`eatbrossubtreend` + NULL)
- `backend/recombine.c:194-200` — Partial absorption depletion path (all nephews stolen + NULL)
- `backend/recombine.c:38-68` — `recombineseq` (1D) with active `break` for contrast

**Concrete example:**
```
Initial diagonally-sorted sons: [c0, c1, c2, c3, c4]

Pass with i=0 (c0 is receiver):
  j=1: c0 absorbs c1 fully     → [c0, NULL, c2, c3, c4]
  j=2: c0 steals from c2       → [c0, NULL, c2', c3, c4]  (c2 retains some children)
  j=3: c0 steals from c3, depletes it → [c0, NULL, c2', NULL, c4]
  j=4: c0 full, ishouldbother=FALSE, skip

Pass with i=1: sons[1]=NULL, skip

Pass with i=2 (c2' is receiver):
  j=3: sons[3]=NULL, skip
  j=4: c2' absorbs c4           → [c0, NULL, c2', NULL, NULL]

Result: 2 nodes (c0, c2'), each having absorbed multiple donors.
Saturation: ishouldbother(c0, c2') = FALSE (combined sons exceed limit).
```

**Provenance:** Finding 0073 (extends Finding 0071 ST-REBALANCE-2D with multi-donor absorption detail)

### EC-RECOMBINE-RECEIVER-SATURATION

**What happens:** A receiver stops absorbing donors when any of these conditions hold:
1. `ishouldbother(sons[i], sons[j])` returns FALSE because the combined son count exceeds the branching limit (`MAXUCINLOAF` for height > 1, `MAX2DBCINLOAF` for height == 1)
2. The receiver's `age == RESERVED` (checked by `ishouldbother`)
3. The donor is NULL (already depleted by a prior merge) or RESERVED
4. `roomformoresons(sons[i])` returns FALSE during partial absorption (nephew-stealing path)

Once saturated, the receiver skips all remaining donors for that outer loop iteration, but remains in the array for subsequent iterations where it might be a donor to a later receiver (at position `i' > i`).

**Why it matters for spec:** The saturation conditions define the termination guarantee for the inner loop: a receiver cannot grow unboundedly. Combined with the occupancy invariant (`sons <= max_children`), this ensures rebalancing never creates overful nodes. The formal precondition for a merge attempt is: `ishouldbother(r, d) ∧ r ≠ NULL ∧ d ≠ NULL`.

**Code references:**
- `backend/recombine.c:150-163` — `ishouldbother` capacity and reserved-crum guards
- `backend/recombine.c:120-128` — Loop guards checking `sons[i] && sons[j]`
- `backend/recombine.c:186` — `roomformoresons` check in partial absorption path

**Provenance:** Finding 0073
