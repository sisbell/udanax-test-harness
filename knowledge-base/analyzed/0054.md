# Finding 0054 Analysis

## Entries

### SS-TWO-BLADE-KNIFE

**What happens:** INSERT constructs a two-blade knife to partition the POOM tree into shift and no-shift regions. `makegappm()` sets `blade[0]` to the insertion V-position and `blade[1]` to the start of the next subspace, computed by `findaddressofsecondcutforinsert()`. For an insertion at `N.x`, the second blade is always `(N+1).1`. The knife has exactly 2 blades (`knives.nblades = 2`).

The second blade computation uses tumbler arithmetic:
1. Increment first digit: `N.x → (N+1).x`
2. Behead to get fractional tail: `N.x → 0.x`
3. Subtract fractional part: `(N+1).x - 0.x = (N+1).0`
4. Add 1 at second digit: `(N+1).0 → (N+1).1`

The source comment confirms design intent: "needs this to give it a place to find intersectionof for text is 2.1".

**Why it matters for spec:** The two-blade knife is the data structure that implements subspace isolation for INSERT. The formal model of INSERT must include the knife construction as part of the operation's mechanism. The knife defines a bounded shift region `[blade[0], blade[1])` — only POOM entries within this half-open interval are shifted. This is the structural reason why INSERT at `1.x` cannot affect `2.x` entries.

**Code references:**
- `insertnd.c:144-146` — `makegappm()` knife construction with 2 blades
- `insertnd.c:174-183` — `findaddressofsecondcutforinsert()` computes second blade

**Concrete example:**
```
INSERT at V-position 1.3:
  blade[0] = 1.3  (insertion point)
  blade[1] = 2.1  (next subspace boundary)
  Shift region: [1.3, 2.1)

INSERT at V-position 2.5:
  blade[0] = 2.5  (insertion point)
  blade[1] = 3.1  (next subspace boundary)
  Shift region: [2.5, 3.1)
```

**Provenance:** Finding 0054

### FC-SUBSPACE

**What happens:** INSERT at V-position `1.x` does not shift link entries at `2.x`. The mechanism is the two-blade knife in `insertcutsectionnd()` (edit.c:207-233). When the knife has 2 blades, the function first checks each POOM crum against `blade[1]` (the subspace boundary). For a link crum at `2.1` with `blade[1] = 2.1`, `whereoncrum` returns `ONMYLEFTBORDER` (-1). Since `cmp <= ONMYLEFTBORDER`, the crum is classified as **case 2** (no shift) and the `blade[0]` check is never reached.

The classification logic for blades `[1.3, 2.1]`:
- Crums at `< 1.3`: case 0 (before insertion, no shift)
- Crums in `[1.3, 2.1)`: case 1 (shifted right by insertion width)
- Crums at `>= 2.1`: case 2 (beyond second blade, no shift)

This confirms and explains the behavioral observation in Finding 0038 with the precise code-level mechanism.

**Why it matters for spec:** The frame condition `∀ op ∈ {INSERT, DELETE} on subspace s, ∀ entry ∈ poom(doc) : entry.vpos.mantissa[0] ≠ s ⟹ entry.vpos' = entry.vpos` is enforced structurally by the two-blade knife, not by per-entry type checking. The knife partitions by V-position range, and subspace boundaries happen to align with knife blade positions. For Dafny, this can be stated: `forall e :: e in poom(doc) && e.vpos >= blade[1] ==> e.vpos == old(e.vpos)`.

**Code references:**
- `edit.c:207-233` — `insertcutsectionnd()` classification logic
- `retrie.c:345-391` — `whereoncrum()` spatial relationship check
- `common.h:86-90` — `TOMYLEFT`, `ONMYLEFTBORDER`, `THRUME`, `ONMYRIGHTBORDER`, `TOMYRIGHT`

**Concrete example:**
```
Pre-state:
  Text "ABCDE" at V-positions 1.1-1.5
  Link at V-position 2.1 (ISA: 1.1.0.1.0.1.0.2.1)

Operation: INSERT "XY" at V-position 1.3
  Knife blades: [1.3, 2.1]

Post-state:
  Text "ABXYCDE" at V-positions 1.1-1.7 (text shifted within 1.x)
  Link STILL at V-position 2.1 (unchanged — case 2, no shift)
  V-position 2.3 is empty (nothing shifted into link subspace)
  FINDLINKS still discovers link; FOLLOWLINK still resolves
```

**Provenance:** Finding 0054

### ST-INSERT

**What happens:** INSERT shifts only POOM entries within the bounded region `[blade[0], blade[1])`. The two-blade knife restricts the shift to entries between the insertion point and the next subspace boundary. `insertcutsectionnd()` classifies each POOM crum into three cases:
- Case 0: crum is before `blade[0]` — no shift
- Case 1: crum is between `blade[0]` and `blade[1]` — shift right by insertion width
- Case 2: crum is at or beyond `blade[1]` — no shift

This corrects EWD-037's claim that `insertcutsectionnd` shifts ALL crums after the insertion point via lexicographic comparison. The actual behavior is bounded: only crums in the same subspace as the insertion point are affected.

**Why it matters for spec:** The postcondition for INSERT's V-position shifting is bounded, not global: `∀ entry ∈ poom(doc) : blade[0] ≤ entry.vpos < blade[1] ⟹ entry.vpos' = entry.vpos + insert_width`. Entries outside this range are unchanged. This is a stronger (more precise) postcondition than "all entries after insertion point shift," and it is what the implementation actually enforces.

**Code references:**
- `edit.c:207-233` — `insertcutsectionnd()` three-case classification
- `insertnd.c:124-172` — `makegappm()` with two-blade knife

**Provenance:** Finding 0054

### INV-SUBSPACE-CONVENTION

**What happens:** The subspace isolation property generalizes across all three subspaces. For ANY insertion at `N.x` (where `N` is the subspace digit), the second blade is `(N+1).1`, restricting shifts to the `N.x` subspace only:
- INSERT at `1.x` → blades `[1.x, 2.1)` → shifts only text
- INSERT at `2.x` → blades `[2.x, 3.1)` → shifts only links
- INSERT at `3.x` → blades `[3.x, 4.1)` → shifts only type endpoints

Each subspace is a self-contained shift domain. This is a structural consequence of `findaddressofsecondcutforinsert()` computing `(N+1).1` regardless of the fractional part of the insertion position.

**Why it matters for spec:** The invariant `∀ N ∈ {1,2,3}, ∀ op = INSERT(N.x) : shift_region(op) ⊆ [N.1, (N+1).1)` holds for all insertions. This can be verified in Dafny as a lemma about `findaddressofsecondcutforinsert`: for input `N.x`, the output is always `(N+1).1`, which combined with the knife classification logic guarantees subspace isolation.

**Code references:**
- `insertnd.c:174-183` — `findaddressofsecondcutforinsert()` generalizes across subspaces

**Provenance:** Finding 0054
