# Finding 0077 Analysis

## Entries

### SS-ADDRESS-SPACE
**What happens:** The granfilade contains both document addresses and content I-addresses, but they occupy separate tumbler ranges and are allocated independently. Document addresses are allocated under the parent account/document via `findisatoinsertnonmolecule` (depth 1 or 2), while content I-addresses are allocated under the document's content subspace via `findisatoinsertmolecule` (depth 3+). The address layout:

```
1.1.0.1                      (account)
├── 1.1.0.1.0.1              (document d1)
│   ├── 1.1.0.1.0.1.1        (version v1 — document address)
│   └── 1.1.0.1.0.1.2        (version v2 — document address)
├── 1.1.0.1.0.2              (document d2)
└── 1.1.0.1.0.1.3.0.1.1      (content I-address for text in d1)
    1.1.0.1.0.1.3.0.1.2      (next content I-address)
```

There is no single global "next" counter (no Σ.next). Allocation is stateless query-and-increment on different tumbler ranges via `findpreviousisagr`.

**Why it matters for spec:** The formal model should NOT use a single `Σ.next` counter. Instead, allocation is a family of independent functions partitioned by tumbler range: `next_doc_addr(granf, parent) = max_child(granf, parent) + 1` and `next_content_addr(granf, doc) = max_content(granf, doc) + 1`. Both query the same granfilade tree but search different subtrees. The EWD simplification of a single counter does not match the implementation.

**Code references:** `findisatoinsertgr` in `backend/granf2.c:130-156` — dispatches to molecule (content) vs non-molecule (document) allocation. `findisatoinsertmolecule` in `backend/granf2.c:158-181` — content allocation. `findisatoinsertnonmolecule` in `backend/granf2.c:203-242` — document allocation.

**Concrete example:**
- INSERT "ABC" allocates content I-addresses I.1, I.2, I.3 (via `findisatoinsertmolecule`)
- CREATENEWVERSION allocates document address `1.1.0.1.0.1.2` (via `findisatoinsertnonmolecule`)
- INSERT "XYZ" allocates content I-addresses I.4, I.5, I.6 (via `findisatoinsertmolecule` — contiguous with ABC, unaffected by document allocation)

**Provenance:** Finding 0077

### ST-VERSION
**What happens:** CREATENEWVERSION(d) performs exactly two effects: (1) allocates a new document address d' via `createorglingranf` with a DOCUMENT hint (which calls `findisatoinsertnonmolecule`), and (2) copies SPAN entries from d's spanfilade to d' via `docopyinternal` → `insertspanf`. It does NOT allocate any new content I-addresses — no call to `findisatoinsertgr` for content. The copied SPANs reuse the source document's existing I-addresses; `insertspanf` takes I-spans as input parameters and records them without allocation.

Call chain: `docreatenewversion` → `createorglingranf` (doc address) → `doretrievedocvspanfoo` (get d's V-span) → `docopyinternal` → `specset2ispanset` (convert V-spans to I-spans from source) → `insertpm` (update POOM) → `insertspanf` (record SPAN entries).

**Why it matters for spec:** Postcondition for VERSION: `granf_content_after = granf_content_before` (no new content entries). Only `granf_doc_after = granf_doc_before ∪ {d'}` (one new document entry). The new document d' shares I-addresses with the source d — this is how version content identity is established. Formally: `ispans(d') = ispans(d)` immediately after VERSION.

**Code references:** `docreatenewversion` in `backend/do1.c:260-299` — entry point. `docopyinternal` in `backend/do1.c:66-82` — calls `insertspanf`, not `findisatoinsertgr`. `insertspanf` in `backend/spanf1.c:15-54` — records SPAN entries with provided I-addresses (no allocation).

**Concrete example:**
```
Before: doc1 has "ABC" at I-addresses I.1, I.2, I.3
VERSION(doc1) → doc2
After:  doc2 has "ABC" mapped to SAME I-addresses I.1, I.2, I.3
        No new content I-addresses allocated
        INSERT "XYZ" into doc1 → allocates I.4, I.5, I.6 (contiguous with ABC)
        compare_versions(doc1, doc2) → 1 shared span pair (all 6 chars contiguous)
```

**Provenance:** Finding 0077

### FC-GRANF-ON-VERSION
**What happens:** CREATENEWVERSION does not modify the content portion of the granfilade. Like DELETE and REARRANGE, it is content-allocation-neutral. However, unlike DELETE, it DOES modify the granfilade by adding a document address entry. This places VERSION in a middle category:

| Operation | Content granfilade | Document granfilade |
|-----------|-------------------|-------------------|
| INSERT | Modified (new content) | Unchanged |
| DELETE | Unchanged | Unchanged |
| CREATELINK | Modified (link orgl) | Unchanged |
| CREATENEWVERSION | **Unchanged** | **Modified** (new doc addr) |

**Why it matters for spec:** Frame condition: `∀ op ∈ {VERSION} : granf_content_after(op) = granf_content_before(op)`. But NOT `granf_after(op) = granf_before(op)` (because a document address is allocated). This refines the operation classification from Finding 0063: `{DELETE, REARRANGE}` are fully granfilade-preserving; `{VERSION}` is content-granfilade-preserving but document-granfilade-modifying; `{INSERT, CREATELINK}` are content-granfilade-modifying.

**Code references:** `docreatenewversion` in `backend/do1.c:260-299` — calls `createorglingranf` (document allocation) but NOT `findisatoinsertgr` for content. `docopyinternal` in `backend/do1.c:66-82` — only spanfilade operations.

**Provenance:** Finding 0077

### INV-MONOTONIC
**What happens:** CREATENEWVERSION does NOT break I-address contiguity for subsequent text INSERTs. Unlike CREATELINK (Finding 0063), which allocates a link orgl in the content region of the granfilade and disrupts text I-address contiguity, VERSION allocates only a document address in a separate tumbler range. The content allocation counter is unaffected.

Test evidence: INSERT "ABC" → CREATENEWVERSION → INSERT "XYZ" yields 1 shared span pair covering all 6 characters with contiguous I-addresses. Contrast with INSERT "ABC" → CREATELINK → INSERT "XYZ" which yields 2 shared span pairs (gap from link orgl).

**Why it matters for spec:** Refines the contiguity-breaking predicate from Finding 0063: `text_contiguous(insert_a, insert_b) ⟺ ¬∃ alloc_c : time(a) < time(c) < time(b) ∧ alloc_c ∈ content_allocations`. CREATENEWVERSION is NOT a content allocation, so it does not break contiguity. The set of contiguity-breaking operations is `{INSERT, CREATELINK}` (operations that call `findisatoinsertmolecule` or `findisatoinsertgr` for content), not `{INSERT, CREATELINK, VERSION}`.

**Code references:** `docreatenewversion` in `backend/do1.c:260-299` — no call to `findisatoinsertgr` for content. Contrast with `docreatelink` in `backend/do1.c:199-225` — calls `createorglingranf` for content (link orgl).

**Concrete example:**
```
INSERT "ABC"        → I.1, I.2, I.3
CREATENEWVERSION    → doc address allocated (separate range), content counter unchanged
INSERT "XYZ"        → I.4, I.5, I.6 (contiguous with ABC)
compare_versions    → 1 shared span pair, combined I-span width 0.6

vs.

INSERT "ABC"        → I.1, I.2, I.3
CREATELINK          → link orgl at ~I.2.0 (content range), content counter advanced
INSERT "DEF"        → I.2.1+ (non-contiguous with ABC)
compare_versions    → 2 shared span pairs (gap)
```

**Provenance:** Finding 0077
