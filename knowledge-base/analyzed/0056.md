# Finding 0056 Analysis

## Entries

### ST-REARRANGE

**What happens:** The rearrange algorithm operates in four steps on the POOM enfilade:

1. **Sort cuts** — `sortknives()` reorders cut points into ascending order regardless of input order.
2. **Compute offsets** — `makeoffsetsfor3or4cuts()` derives a tumbler offset for each region from the cut positions alone.
3. **Classify spans** — `rearrangecutsectionnd()` determines which region (0–4) each content span belongs to.
4. **Apply offsets** — `tumbleradd()` adds the computed offset to each span's V-address in place.

For **pivot (3 cuts)** at positions `cut0 < cut1 < cut2`:
- `diff[1] = cut2 - cut1` (region 1 moves forward by size of region 2)
- `diff[2] = -(cut1 - cut0)` (region 2 moves backward by size of region 1)

For **swap (4 cuts)** at positions `cut0 < cut1 < cut2 < cut3`:
- `diff[1] = cut2 - cut0` (region 1 moves to region 3's position)
- `diff[2] = (cut3 - cut2) - (cut1 - cut0)` (middle shifts by size difference)
- `diff[3] = -(cut2 - cut0)` (region 3 moves to region 1's position)

The operation modifies V-addresses exclusively — it calls `tumbleradd(&ptr->cdsp.dsas[index], &diff[i], &ptr->cdsp.dsas[index])` which updates the displacement's V-address component. No I-addresses are touched, no content is copied, no new permascroll entries are created.

**Why it matters for spec:** This confirms rearrange is a pure V-address permutation. The state transition can be modeled as: for each content unit `c`, `v_after(c) = v_before(c) + offset(region(c))`, where `offset` is determined by the cut geometry. All cuts are in the **pre-move** address space — offsets are computed from pre-move positions with no reference to post-move state.

**Concrete example (pivot):** `"ABCDE"` with cuts at `1.2, 1.4, 1.6`:
- Region 1 (`[1.2, 1.4)` = "BC"): offset = `1.6 - 1.4` = `+0.2`, moves to `[1.4, 1.6)`
- Region 2 (`[1.4, 1.6)` = "DE"): offset = `-(1.4 - 1.2)` = `-0.2`, moves to `[1.2, 1.4)`
- Result: `"ADEBC"`

**Concrete example (swap):** `"ABCDEFGH"` with cuts at `1.2, 1.4, 1.6, 1.8`:
- Region 1 (`[1.2, 1.4)` = "BC"): offset = `1.6 - 1.2` = `+0.4`, moves to `[1.6, 1.8)`
- Region 2 (`[1.4, 1.6)` = "DE"): offset = `(1.8 - 1.6) - (1.4 - 1.2)` = `0`, stays
- Region 3 (`[1.6, 1.8)` = "FG"): offset = `-(1.6 - 1.2)` = `-0.4`, moves to `[1.2, 1.4)`
- Result: `"AFGDEBCH"`

**Code references:** `backend/edit.c:78-184` — `rearrangend()`, `makeoffsetsfor3or4cuts()`, `rearrangecutsectionnd()`, `tumbleradd()`

**Provenance:** Finding 0056 (extends Findings 0006, 0016)

### PRE-REARRANGE

**What happens:** Cut points are specified in the **pre-move address space**. The algorithm reads current V-positions, computes offsets from the cut positions via `makeoffsetsfor3or4cuts()` (which takes only `knives->blades[]`), and applies offsets — no reference to post-move state exists. Additionally, `sortknives()` reorders cuts into ascending order, so misordered inputs are silently accepted and normalized rather than rejected.

**Why it matters for spec:** The precondition domain is the current document state: `∀ i: cuts[i] ∈ v_space(doc_before)`. The sort-before-use behavior means the precondition does not require ordered input: `pre_rearrange(doc, cuts) ≡ |cuts| ∈ {3,4}` — ordering is not a precondition because the implementation normalizes it. This is a robustness property that the spec should capture: the operation is commutative in its cut arguments (up to sorting).

**Code references:** `backend/edit.c:107` — `sortknives(&knives)`; `backend/edit.c:164-184` — offset computation references only `knives->blades[]`

**Provenance:** Finding 0056 (extends Finding 0006)

### INV-REARRANGE-IDENTITY

**What happens:** Rearrange preserves I-addresses exactly. The code modifies only `ptr->cdsp.dsas[index]` (the V-address component of the displacement). The I-address, stored separately, is never touched. No new I-addresses are allocated, no content is duplicated in the permascroll, and the same enfilade nodes (crums) are retained.

**Why it matters for spec:** Formally: `∀ c ∈ content(doc): i_addr(c, doc_after) = i_addr(c, doc_before)`. This is what makes rearrange the **unique** identity-preserving move operation. A delete+insert would: (1) destroy the original I-address, (2) allocate a new I-address, (3) break all links bound to the original content, (4) break all cross-document transclusion references.

**Concrete example:**
- Content "BC" at V-address 1.2 has I-address `I_bc`
- After `pivot(1.2, 1.4, 1.6)`, "BC" is at V-address 1.4 but still has I-address `I_bc`
- Links bound to `I_bc` still resolve; transclusions referencing `I_bc` still find the content

**Code references:** `backend/edit.c:125` — `tumbleradd(&ptr->cdsp.dsas[index], &diff[i], &ptr->cdsp.dsas[index])`

**Provenance:** Finding 0056 (extends Findings 0016, 0002)

### EC-REARRANGE-EMPTY-REGION

**What happens:** If a region `[cutN, cutN+1)` contains no content, it contributes to offset computation but doesn't move anything. The algorithm operates per-span, and empty regions simply have no spans to process. This is correct behavior — the offset arithmetic is unaffected.

**Why it matters for spec:** Edge case for the rearrange postcondition: when a region is empty, its size still contributes to the offset for other regions. For pivot with an empty region 1 (`cut0 = cut1`), `diff[1] = 0` and `diff[2] = 0`, making the operation a no-op. The spec should handle this: `cut0 = cut1 ⇒ rearrange(doc, [cut0, cut1, cut2]) = doc`.

**Code references:** `backend/edit.c:78-184` — per-span iteration with `rearrangecutsectionnd()`

**Provenance:** Finding 0056

### EC-REARRANGE-CROSS-SUBSPACE

**What happens:** Rearrange can move content across subspace boundaries because offsets are computed purely from tumbler arithmetic with no digit-0 (subspace) validation. Content at V-address `1.x` can be moved to `2.x` if the cut geometry spans the boundary.

**Why it matters for spec:** This violates the content discipline (CD0) which requires content type to match subspace. The rearrange operation lacks a precondition check: there is no `pre_rearrange_subspace(doc, cuts) ≡ ∀ regions r1, r2: subspace(r1) = subspace(r2)` guard. The spec should note this as a missing validation — the implementation accepts inputs that produce semantically invalid states.

**Code references:** `backend/edit.c:78-184` — no subspace validation in `rearrangend()`

**Provenance:** Finding 0056 (see also Finding 0051)

## Omit

The following sections of Finding 0056 are omitted:

- **Comparison with Delete+Insert table:** The individual properties (identity preservation, link survival, transclusion maintenance) are already captured in INV-REARRANGE-IDENTITY and INV-REARRANGE-LINK-SURVIVAL from Finding 0016. The comparison is motivational, not a new behavioral property.
- **Key function list** (`makecutsnd`, `recombine`, etc.): Implementation helper descriptions without behavioral properties beyond what is captured in ST-REARRANGE.
