# Finding 0012 Analysis

## Entries

### SS-DUAL-ENFILADE

**What happens:** The system maintains two separate global enfilades with distinct roles. **`granf`** (type `typegranf`, `INT *`) stores all content and document structure — the permascroll, document orgls, link orgls, and V→I mappings. **`spanf`** (type `typespanf`, `INT *`) is a link search index that maps I-addresses to the links that reference them. Both are created at initialization via `createenf()` with different type flags (`GRAN` vs `SPAN`), indicating different internal structure. The granf is indexed by document ISA and V-position; the spanf is indexed by content I-address and returns links.

**Why it matters for spec:** The formal state model requires two top-level structures, not one. `SystemState = (granf: GranEnfilade, spanf: SpanEnfilade)`. Operations must specify which enfilade(s) they read and write. Content operations (insert, read, create document) access only `granf`. Link search (`find_links`) accesses only `spanf`. Link creation is the critical compound operation that writes to both. This factoring determines which frame conditions are possible — content operations cannot affect link findability (they don't touch `spanf`), and link searches cannot affect content (they don't touch `granf`).

**Code references:**
- `xanadu.h:13` — `typegranf` definition (`INT *`)
- `xanadu.h:15` — `typespanf` definition (`INT *`)
- `entexit.c:44-45` — initialization: `granf = createenf(GRAN); spanf = createenf(SPAN)`
- `corediskout.c:21-22` — global variable definitions

**Concrete example:**
```
Initialization:
  granf = createenf(GRAN)  — empty content enfilade
  spanf = createenf(SPAN)  — empty link index

After inserting text into document 1.1.0.1.0.1:
  granf: contains document orgl with V→I mapping for text content
  spanf: unchanged (no links created)

After creating a link:
  granf: new link orgl + link reference in document's 0.x subspace
  spanf: new index entries mapping endpoint I-addresses → link
```

**Provenance:** Finding 0012

### SS-GRANF-OPERATIONS

**What happens:** The `granf` enfilade supports four key operation classes: (1) `findorgl()` — locates an orgl by its ISA; (2) `inserttextingranf()` — inserts text content; (3) `createorglingranf()` — creates a new orgl (used for documents and links); (4) `ispanset2vstuffset()` — dereferences I-addresses to their content bytes. These operations cover the full lifecycle of content: creation, storage, and retrieval.

**Why it matters for spec:** These operations define the interface of the `GranEnfilade` abstract data type. The spec should model `granf` as supporting at minimum: `find(isa) → Orgl`, `insert_text(text) → ISpanSet`, `create_orgl() → ISA`, and `deref(ispanset) → content`. All document-level operations (`doinsert`, `docopy`, `docreatelink`) are composed from these primitives.

**Code references:**
- `granf1.c`, `granf2.c` — granf operation implementations
- `do1.c:199` — `createorglingranf()` called during link creation
- Various retrieval paths through `ispanset2vstuffset()`

**Provenance:** Finding 0012

### SS-SPANF-OPERATIONS

**What happens:** The `spanf` enfilade supports two key operation classes: (1) `insertspanf()` / `insertendsetsinspanf()` — indexes link endpoints by their content I-addresses; (2) `findlinksfromtothreesp()` / `retrieveendsetsfromspanf()` — queries for links whose endpoints intersect with given I-address ranges. The spanf is a pure index — it does not store link content, only the mapping from I-addresses to links.

**Why it matters for spec:** The `SpanEnfilade` is a secondary index: `SpanEnfilade = Map<IAddress, Set<LinkISA>>`. It is derived state — its content is fully determined by the link orgls in `granf`. The spec should model spanf queries as: `find_links(from, to, three) = {link ∈ all_links | endpoints(link) ∩ query_range ≠ ∅}`. The insert operations maintain this index in sync with link creation.

**Code references:**
- `spanf1.c`, `spanf2.c` — spanf operation implementations
- `do1.c:386-391` — `dofindlinksfromtothree()` delegates entirely to `findlinksfromtothreesp()`

**Provenance:** Finding 0012

### ST-CREATE-LINK

**What happens:** Link creation (`docreatelink`) is a compound state transition that updates both enfilades atomically: (1) create a link orgl in `granf` via `createorglingranf()`; (2) copy the link's ISA reference into the document's link subspace (`0.x`) via `docopy()`; (3) index all link endpoints in `spanf` via `insertendsetsinspanf()`. This three-step sequence modifies both `granf` (new orgl + document modification) and `spanf` (new index entries).

**Why it matters for spec:** This is the only documented operation that writes to both enfilades. The postcondition must specify effects on both: `granf' = granf + {new_link_orgl} + doc_updated` AND `spanf' = spanf + {endpoint_i_addrs → new_link}`. The precondition is that the document and endpoint content must exist in `granf`. This compound transition is where the dual-enfilade consistency invariant (INV-DUAL-ENFILADE-CONSISTENCY) is most at risk.

**Code references:**
- `do1.c:199-225` — `docreatelink()` full three-step sequence

**Concrete example:**
```
Pre-state:
  granf: document orgl at ISA 1.1.0.1.0.1 with text content
  spanf: empty

docreatelink(doc=1.1.0.1.0.1, from=..., to=..., three=...)

Post-state:
  granf: document orgl updated (0.1 → link ISA 1.1.0.1.0.2)
       + new link orgl at ISA 1.1.0.1.0.2
  spanf: from-endpoint I-addrs → 1.1.0.1.0.2
       + to-endpoint I-addrs → 1.1.0.1.0.2
       + three-endpoint I-addrs → 1.1.0.1.0.2
```

**Provenance:** Finding 0012

### INV-DUAL-ENFILADE-CONSISTENCY

**What happens:** The `spanf` index must be consistent with the link orgls stored in `granf`. For every link orgl in `granf`, its endpoints must be indexed in `spanf` (otherwise the link exists but is not findable). Conversely, every entry in `spanf` must correspond to an existing link orgl in `granf` (otherwise queries return phantom links). This consistency is maintained by `docreatelink()` updating both enfilades in sequence, but there is no transactional mechanism documented — if the sequence is interrupted partway, the enfilades can desynchronize.

**Why it matters for spec:** This is a cross-structure invariant: `forall link_isa ∈ granf.link_orgls :: endpoints(link_isa) ⊆ spanf.indexed_endpoints(link_isa)` AND `forall (i_addr, link_isa) ∈ spanf :: link_isa ∈ granf.link_orgls`. The spec should state this as an invariant that holds before and after every complete operation. It should also note the absence of transactional guarantees — partial failures during `docreatelink` could violate this invariant. Dafny verification should prove that each operation's postcondition preserves this invariant assuming no interruption.

**Code references:**
- `do1.c:199-225` — `docreatelink()` updates both enfilades sequentially, no rollback on failure

**Provenance:** Finding 0012

### FC-CONTENT-SPANF-ISOLATION

**What happens:** Content operations (text insertion, document creation, text retrieval) access only `granf` and never modify `spanf`. Link search operations access only `spanf` and never modify `granf`. This separation is structural — the operation implementations reference different global variables. The access pattern table from the finding confirms: insert text (granf only), create document (granf only), read content (granf only), find links (spanf only). Only link creation and link following cross the boundary.

**Why it matters for spec:** This is a frame condition that enables modular reasoning. For any content-only operation `op`: `spanf' = spanf` (link findability unchanged). For any link-search operation `op`: `granf' = granf` (content unchanged). The spec can verify content operations and link search operations independently, only needing cross-structure reasoning for `docreatelink` and link-following operations.

**Code references:**
- `granf1.c`, `granf2.c` — content operations, no `spanf` references
- `spanf1.c`, `spanf2.c` — link index operations, no `granf` references
- `do1.c:386-391` — `dofindlinksfromtothree()` uses only `spanf`

**Provenance:** Finding 0012
