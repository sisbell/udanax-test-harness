# Finding 0022 Analysis

## Entries

### SS-SESSION-STATE
**What happens:** The backend daemon maintains two tiers of state. Global state (enfilades, document storage, link storage, content identity/SPORGL) is shared across all connected sessions. Per-session state (current account, open document handles, connection socket) is isolated to each session. The daemon supports up to 25 concurrent connections (MAX_PLAYERS) via a `player[]` array, multiplexed with `select()`.

**Why it matters for spec:** Defines the boundary between shared and isolated state. Any formal model of multi-session behavior must partition the system state into a global component (documents, links, content identity) and per-session components (account context, open handles). This partition determines which operations have cross-session visibility.

**Code references:** `backend/bed.c` (player array, MAX_PLAYERS), `backend/socketbe.c` (connection multiplexing, select loop)

**Concrete example:**
- Session A sets `account(1.1.0.1)`, Session B sets `account(1.1.0.1)`
- Session A switches to `account(1.1.0.2)` — Session B remains on `1.1.0.1`
- Session A creates doc → `1.1.0.2.0.1`; Session B creates doc → `1.1.0.1.0.2`

**Provenance:** Finding 0022, sections 1 and Architecture

### INV-GLOBAL-ADDRESS-UNIQUENESS
**What happens:** Document addresses are globally unique even when multiple sessions use the same account. The backend maintains a per-account counter shared across all sessions, so concurrent `create_document()` calls from different sessions on the same account produce distinct, sequential addresses.

**Why it matters for spec:** This is a system-wide invariant: for all sessions S1, S2 and any `create_document()` calls, the resulting addresses are always distinct. The per-account counter is part of global state, not session state, preventing duplicate allocation.

**Code references:** `backend/disk.c` (document storage, address allocation)

**Concrete example:**
- Both sessions: `account(1.1.0.1)`
- Session A: `create_document()` → `1.1.0.1.0.1`
- Session B: `create_document()` → `1.1.0.1.0.2`

**Provenance:** Finding 0022, section 2

### FC-SESSION-ACCOUNT-ISOLATION
**What happens:** Changing the current account in one session does not affect any other session's account context. The account is strictly per-session state.

**Why it matters for spec:** Frame condition: for any session S1 that executes `account(X)`, for all other sessions S2 where S2 ≠ S1, S2's current account is unchanged. This confirms accounts are session-local namespace selectors, not authentication credentials with shared side effects.

**Concrete example:**
- Session A: `account(1.1.0.1)`, Session B: `account(1.1.0.1)`
- Session A: `account(1.1.0.2)` — only A's account changes
- Session B: `create_document()` → `1.1.0.1.0.2` (still uses `1.1.0.1`)

**Provenance:** Finding 0022, section 1

### ST-LINK-GLOBAL-VISIBILITY
**What happens:** Links created in any session are immediately visible to all other sessions. `find_links()` from session B returns links created by session A without any synchronization or coordination step.

**Why it matters for spec:** Postcondition of link creation: after `create_link(source, target)` succeeds in any session, `find_links(source)` in any session (including others) includes the new link. Link storage is part of global state.

**Concrete example:**
- Session A: `create_link(source, target)` → `link_id`
- Session B: `find_links(source)` → `[link_id]`

**Provenance:** Finding 0022, section 3

### INT-CROSS-SESSION-TRANSCLUSION
**What happens:** Content identity (SPORGL/provenance tracking) is maintained globally. When session A transcludes content from session B's document via `vcopy`, content identity is preserved — `compare_versions` detects shared spans across session boundaries.

**Why it matters for spec:** The content identity system operates on global state. The invariant that transclusion preserves content identity holds regardless of which session performed the original insertion and which session performed the copy. This means the SPORGL system's tracking is not scoped to sessions.

**Concrete example:**
- Session B: `create_document(source)`, `insert("Shared content")`
- Session A: `create_document(dest)`, `vcopy(source → dest)`
- Any session: `compare_versions(dest, source)` → shared spans detected

**Provenance:** Finding 0022, section 4

### EC-CONFLICT-COPY-NO-MERGE
**What happens:** When multiple sessions open the same document with `CONFLICT_COPY`, each session gets an independent copy. Changes made in different sessions are NOT merged — the final state depends on which copy is accessed. This means true concurrent editing requires application-level merge logic.

**Why it matters for spec:** This is an important edge case for concurrent access semantics. `CONFLICT_COPY` does not provide automatic conflict resolution or merging. The system makes no guarantees about combining concurrent edits — only one session's changes survive in a given read. This is a deliberate design boundary, not a bug.

**Concrete example:**
- Document contains: `"AAAA____BBBB"`
- Session A: opens with CONFLICT_COPY, changes `AAAA` → `XXXX`
- Session B: opens with CONFLICT_COPY, changes `BBBB` → `YYYY`
- Final read: `"XXXX____BBBB"` (only A's changes visible)

**Provenance:** Finding 0022, section 5

### ST-CROSS-SESSION-VERSIONING
**What happens:** When multiple sessions create versions of the same document, each version gets a unique address. The versions can be modified independently while sharing content identity with the original.

**Why it matters for spec:** Postcondition of `create_version`: the resulting version address is globally unique (ties to INV-GLOBAL-ADDRESS-UNIQUENESS). Multiple sessions versioning the same document produce distinct version addresses that each maintain independent state while preserving content identity with the source.

**Concrete example:**
- Session A: `create_version(original)` → `version_a`
- Session B: `create_version(original)` → `version_b`
- `version_a ≠ version_b`, both share content identity with `original`

**Provenance:** Finding 0022, section 6
