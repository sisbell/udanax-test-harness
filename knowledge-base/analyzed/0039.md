# Finding 0039 Analysis

## Entries

### SS-POOM-MULTIMAP

**What happens:** The POOM (Permutation Of Ordered Mappings) is a 2D enfilade (B-tree) that stores `(V-position, I-address)` entries. Critically, it functions as a **multimap**: a single I-address can map to multiple V-positions within the same document. The search algorithm `findcbcinarea2d()` traverses all siblings at each B-tree level and recursively descends into all qualifying subtrees, accumulating every matching leaf node. The accumulation function `incontextlistnd()` inserts each found context into a sorted linked list, never replacing existing entries. This means a query by I-address returns ALL V-positions referencing that address.

**Why it matters for spec:** The POOM's type must be modeled as `POOM = Multimap<(VPosition, IAddress)>`, not a bijection or function. The `ispan2vspanset` operation returns a set, not a single value: `ispan2vspanset(poom, i) : Set<VSpan>`. This is structurally necessary for internal transclusion — without multimap semantics, a document could not reference the same content identity at multiple positions. The Dafny model should define `ispan2vspanset` with return type `set<VSpan>` and prove `|result| >= 1` when the I-address exists in the POOM.

**Code references:**
- `orglinks.c:389-394` — `ispan2vspanset()` delegates to `permute()` with direction I→V
- `orglinks.c:404-422` — `permute()` iterates restriction spanset, calls `span2spanset()` per span
- `retrie.c:229-268` — `findcbcinarea2d()` B-tree traversal: iterates siblings, recurses into subtrees
- `context.c:75-111` — `incontextlistnd()` inserts into sorted linked list, never replaces

**Concrete example:**
```
Document has "B" at V-positions 1.2, 1.4, and 1.5, all referencing I-address i_B.

ispan2vspanset(poom, i_B) = {
  VSpan(1.2, width=0.1),
  VSpan(1.4, width=0.1),
  VSpan(1.5, width=0.1)
}

Result set cardinality = 3 (one per V-position referencing i_B)
```

**Provenance:** Finding 0039

### ST-VCOPY

**What happens:** When vcopy copies content within the same document (internal transclusion), it creates a new V-position that references the same I-address as the source position. After the operation, the document's POOM contains multiple `(V-position, I-address)` entries with the same I-address but different V-positions. This is the same mechanism as cross-document transclusion — the POOM's multimap structure handles intra-document sharing identically to inter-document sharing.

**Why it matters for spec:** The ST-VCOPY postcondition from Finding 0002 (`references(target) = references(target_before) ∪ source_content_ids`) applies unchanged for internal transclusion. When `target = source`, the postcondition becomes `references(doc) = references(doc_before) ∪ { existing_content_ids_at_new_positions }`. No special case is needed — the same postcondition covers both internal and external transclusion because the POOM is a multimap that naturally accommodates duplicate I-addresses at different V-positions.

**Concrete example:**
```
Before: doc has "text" at V 1.10..1.13, mapped to I-addresses i₁..i₄
After vcopy(doc, V=1.19, specset=V 1.10..1.13):
  doc has "text" at V 1.10..1.13 → i₁..i₄ (original, unchanged)
  doc has "text" at V 1.19..1.22 → i₁..i₄ (new positions, same I-addresses)

compare_versions on those two regions reports shared content:
  shared = [{first: {start: 1.10, width: 0.4}, second: {start: 1.19, width: 0.4}}]
```

**Code references:** Tests `internal/internal_transclusion_identity`, `internal/internal_transclusion_multiple_copies`

**Provenance:** Finding 0039

### INV-LINK-IDENTITY-DISCOVERY

**What happens:** Links bound to an I-address are discoverable from ALL V-positions that reference that I-address, including multiple positions within the same document created by internal transclusion. When a link is created on the first occurrence of content (V=1.10), `find_links` on the second occurrence (V=1.19) returns the same link. This is because link discovery operates in I-space: `find_links` converts the query V-span to I-spans, then searches the spanf index by I-address. Since both V-positions map to the same I-address, both resolve to the same link.

**Why it matters for spec:** This confirms the invariant: `forall v1 v2 : VPos, doc : Doc :: iaddrs(doc, v1) = iaddrs(doc, v2) ==> findlinks(doc, v1) = findlinks(doc, v2)`. Link discovery is a function of content identity, not position. The formal spec should state that `findlinks` factors through I-space: `findlinks(doc, vspan) = findlinks_by_iaddr(vspan2ispan(doc, vspan))`. This is the same INV-LINK-GLOBAL-VISIBILITY from Finding 0008, applied to the special case of intra-document sharing.

**Concrete example:**
```
doc has "text" at V 1.10 and V 1.19, both referencing I-addresses i₁..i₄
create_link(from=V 1.10..1.13) → link_id

find_links(from=V 1.10..1.13) → [link_id]  (direct: link on this position)
find_links(from=V 1.19..1.22) → [link_id]  (indirect: same I-addresses)
```

**Code references:** Test `internal/internal_transclusion_with_link`

**Provenance:** Finding 0039

### EC-SELF-TRANSCLUSION

**What happens:** Internal transclusion (copying content within the same document) is a valid operation that the system handles without special-casing. A document can reference the same I-address at N distinct V-positions (tested with N=2 and N=3). All N positions are recognized as sharing identity: `compare_versions` between any pair reports shared content. The N-to-1 relationship (N V-positions to 1 I-address) scales correctly — all pairwise comparisons among three positions sharing one I-address report shared content.

**Why it matters for spec:** Self-transclusion is an edge case that validates the generality of the POOM multimap model. The spec need not distinguish internal from external transclusion — both are instances of "add a V-position reference to an existing I-address." The only difference is that source and target are the same document. The N-ary case (3+ copies) confirms there is no implicit cardinality constraint on how many V-positions can reference one I-address.

**Concrete example:**
```
doc has character "B" at V-positions 1.2, 1.4, 1.5 — all referencing I-address i_B

Pairwise comparisons:
  compare(V 1.2, V 1.4) → shared (same I-address)
  compare(V 1.2, V 1.5) → shared (same I-address)
  compare(V 1.4, V 1.5) → shared (same I-address)

No limit observed on number of V-positions per I-address.
```

**Code references:** Test `internal/internal_transclusion_multiple_copies`

**Provenance:** Finding 0039
