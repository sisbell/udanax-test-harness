# Finding 0034 Analysis

## Entries

### SS-CONTENT-IDENTITY
**Detail level:** Essential

Content in udanax-green is stored as opaque bytes with no encoding semantics. The storage unit is `typegrantext`, a fixed-size byte buffer with a length counter:

```c
typedef struct structgrantext {
    char textstring[GRANTEXTLENGTH];  // GRANTEXTLENGTH = 950 bytes
    unsigned textlength;              // byte count, not character count
} typegrantext;
```

`char` is a single byte (8 bits). The system stores, copies, and retrieves raw bytes with no encoding interpretation or validation. Content retrieval uses `movmem` (mapped to `memmove`) — a raw byte copy with no encoding conversion or character boundary checking. Length is computed via `strlen()`, which returns byte count.

**Why it matters for spec:** The fundamental content type in the formal model is `seq<byte>`, not `seq<char>` or `string`. V-space width equals byte count, not character count. All address arithmetic operates on byte offsets. A 5-character UTF-8 string using 10 bytes occupies 10 V-space positions.

**Code references:**
- `wisp.h:76` — `char textstring[GRANTEXTLENGTH]` byte array storage
- `wisp.h:77` — `unsigned textlength` byte count field
- `common.h:115` — `#define GRANTEXTLENGTH 950` max bytes per atom
- `context.c:308` — `movmem()` raw byte copy on retrieval
- `corediskout.c:242` — `movmem()` raw byte copy for disk persistence
- `xumain.c:143` — `strlen()` for byte-count length

**Concrete example:**
- Insert "caf\xc3\xa9" (UTF-8 cafe with e-acute): 5 bytes stored, V-space width = 5
- Insert "hello" (ASCII): 5 bytes stored, V-space width = 5
- Insert "\xf0\x9f\x98\x80" (UTF-8 emoji): 4 bytes stored, V-space width = 4

**Provenance:** Finding 0034

### INV-SINGLE-CHAR-GRANULARITY
**Detail level:** Essential

The granularity of all address operations is the single byte, not the character. Each byte position in content receives exactly one I-space address. V-space positions correspond 1:1 with bytes. This is an invariant: no operation in the system aggregates bytes into multi-byte units.

**Why it matters for spec:** The invariant `forall content c, vspan_width(c) == byte_length(c)` holds unconditionally. The formal model must use byte indexing, not character indexing. Operations like partial retrieval, deletion, and link endpoint addressing all resolve to individual byte positions. No character-boundary-aware operation exists in the backend.

**Concrete example:**
- Content "caf\xc3\xa9" has byte_length = 5 and vspan_width = 5
- Byte at position 4 is `\xc3`, byte at position 5 is `\xa9` — each has its own I-address
- These are the two bytes of a single UTF-8 character, but the system treats them as independent units

**Provenance:** Finding 0034

### EC-ENCODING-BOUNDARY-SPLIT
**Detail level:** Essential

Partial retrieval and link endpoints can split multi-byte character encodings because all operations use byte addressing. The backend performs no character boundary validation on any operation. Retrieving a sub-range of a V-span that straddles a multi-byte character boundary returns byte sequences that are invalid in the original encoding.

**Why it matters for spec:** The formal model does not need to model encoding validity — but any frontend/application layer must. The spec should document that partial retrieval returns `seq<byte>` with no encoding guarantee. This is not a bug but a design property: the backend is encoding-agnostic by construction. Preconditions on retrieval do not include encoding boundary checks.

**Concrete example:**
```
Content: "caf\xc3\xa9" (5 bytes, UTF-8 for "cafe with e-acute")
V-space: 1.1 through 1.5

Retrieve V-span [1.1, 1.4]: Returns bytes "caf\xc3" — invalid UTF-8
  (the \xc3 is the first byte of a 2-byte sequence, missing its continuation \xa9)

Retrieve V-span [1.5, 1.5]: Returns byte "\xa9" — invalid UTF-8
  (a continuation byte without its leading byte)
```

**Code references:**
- `context.c:308` — `movmem()` copies arbitrary byte ranges with no boundary check

**Provenance:** Finding 0034

### INT-TRANSCLUSION
**Detail level:** Useful

Transclusion (vcopy) preserves byte identity — the same bytes at the same I-addresses appear in multiple documents. Since content is encoding-opaque, transclusion inherits whatever encoding the original content had. Mixed encodings within a single document are possible if content is transcluded from sources using different encodings.

**Code references:**
- `context.c:308` — byte-level copy semantics

**Provenance:** Finding 0034
