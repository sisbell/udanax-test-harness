# Finding 0021 Analysis

## Entries

### SS-ADDRESS-SPACE
**What happens**: Tumbler addresses encode a containment hierarchy. Accounts are namespaces within the address space; documents live under accounts; nodes live under nodes. The hierarchy level is encoded by the number of `.0.` boundaries in the address:

- Account address: `1.1.0.2`
- First document under that account: `1.1.0.2.0.1`
- Nodes under a node: `1.1.0.1.1`, `1.1.0.1.2` (no `.0.` boundary)

The `makehint` function encodes the hierarchy depth:

| supertype | subtype | depth | Meaning |
|-----------|---------|-------|---------|
| NODE | NODE | 1 | Node under node |
| ACCOUNT | DOCUMENT | 2 | Document under account |
| DOCUMENT | DOCUMENT | 1 | Version under document |
| DOCUMENT | ATOM | - | Content in document |

`depth = (supertype == subtype) ? 1 : 2`

**Why it matters for spec**: Defines the address type hierarchy that all operations reference. The depth calculation determines the `.0.` boundary structure, which is essential for containment checks and address allocation correctness.

**Code references**: `makehint` in granf allocation logic; `granf2.c:findisatoinsertnonmolecule` for allocation.

**Concrete example**:
- Account `1.1.0.2` → first document is `1.1.0.2.0.1` (depth=2, crosses one `.0.` boundary)
- Node `1.1.0.1` → next node is `1.1.0.1.1` (depth=1, no `.0.` boundary)

**Provenance**: Finding 0021

### SS-TUMBLER-CONTAINMENT
**What happens**: Containment of address A under prefix B is checked by truncating A to the length of B and comparing for equality:

```c
tumblertruncate(&A, tumblerlength(&B), &truncated);
tumblereq(&truncated, &B);  // TRUE if A is under B
```

**Why it matters for spec**: This is the fundamental predicate for hierarchical address space queries. It defines what "under" means for tumbler addresses — pure prefix matching on the digit sequence. This predicate is used to enforce account boundaries during allocation and would appear in preconditions and invariants involving address containment.

**Code references**: `tumblertruncate`, `tumblerlength`, `tumblereq` — tumbler utility functions.

**Concrete example**:
- Is `1.1.0.1.0.1` under `1.1.0.2`? Truncate to length 4: `1.1.0.1`. Compare: `1.1.0.1 ≠ 1.1.0.2` → NO.
- Is `1.1.0.2.0.1` under `1.1.0.2`? Truncate to length 4: `1.1.0.2`. Compare: `1.1.0.2 = 1.1.0.2` → YES.

**Provenance**: Finding 0021

### ST-ADDRESS-ALLOC
**What happens**: New addresses are allocated by `findisatoinsertnonmolecule` in `granf2.c`:

1. Compute upper bound from the parent (hint) address: `upperbound = tumblerincrement(hintisa, depth-1, 1)` — the next sibling of the parent.
2. Find the highest existing address below upperbound via `findpreviousisagr`.
3. If nothing found under the parent, create the first child: `hintisa.0.1`.
4. Otherwise, truncate the found item and increment to produce the next sibling.

The entire granf (global address enfilade) is a single flat tree; the allocation algorithm enforces hierarchical structure by bounding searches to the parent's address range.

**Why it matters for spec**: Defines the postcondition for address allocation — the allocated address must be (a) under the parent, (b) greater than all existing addresses under the parent, and (c) unique. The first-child convention (`parent.0.1`) is a concrete invariant.

**Code references**: `granf2.c:findisatoinsertnonmolecule`, `findpreviousisagr`, `tumblerincrement`.

**Concrete example**:
- Parent account `1.1.0.2`, no existing documents → allocates `1.1.0.2.0.1`
- Parent account `1.1.0.2`, existing document `1.1.0.2.0.1` → allocates `1.1.0.2.0.2`

**Provenance**: Finding 0021

### PRE-ADDRESS-ALLOC
**What happens**: The allocation search via `findpreviousisagr` must find only addresses that are actually under the target parent. Bug 0013 showed that without a containment check, the search crosses account boundaries: when allocating under account `1.1.0.2`, the search finds `1.1.0.1.0.1` (under a different account) and incorrectly increments from it, producing `1.1.0.1.0.2` — an address under the wrong account.

The fix adds a prefix-match check: after finding the highest address below the upper bound, verify it is actually contained under the target parent using tumbler truncation/comparison.

**Why it matters for spec**: This is a precondition on the allocation algorithm: the candidate address used as an increment base must be under the target parent. Without this, the monotonic allocation invariant holds locally but violates account isolation. This is a concrete example of flat storage requiring explicit hierarchical enforcement.

**Code references**: `granf2.c:findisatoinsertnonmolecule`, `findpreviousisagr`; Bug 0013.

**Concrete example**:
- Before fix: Allocating under `1.1.0.2` finds `1.1.0.1.0.1`, increments to `1.1.0.1.0.2` (WRONG — under account `1.1.0.1`).
- After fix: Allocating under `1.1.0.2` finds `1.1.0.1.0.1`, rejects it via containment check, falls back to first-child `1.1.0.2.0.1` (CORRECT).

**Provenance**: Finding 0021

### INV-ACCOUNT-ISOLATION
**What happens**: Documents allocated under one account must have addresses that are proper descendants of that account's address. The first document under any account is always `account.0.1`. Subsequent documents increment monotonically within the account's address range.

**Why it matters for spec**: This is a global invariant: for all documents D and accounts A, if D was created under A, then `contains(A, address(D))` must be true. Bug 0013 showed this invariant was violated by the original allocation algorithm, confirming it is not automatically enforced by the flat storage structure and must be explicitly maintained.

**Code references**: `granf2.c:findisatoinsertnonmolecule`; test scenarios `febe/scenarios/accounts.py:account_switch`.

**Provenance**: Finding 0021
