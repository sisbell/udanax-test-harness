# Finding 0053 Analysis

## Entries

### SS-TUMBLER

**What happens:** Tumblers use sign-magnitude representation. The `sign` field is 0 (positive) or 1 (negative). `tumblersub` (subtraction) implements `a - b` as `a + (-b)` by negating `b`'s sign and calling `tumbleradd`. When `b > a`, the result is a negative tumbler — not an underflow or error, but a valid tumbler with `sign=1` and positive magnitude. The representation is sign-magnitude, not two's complement: `1.2 - 0.10 = -0.8` (sign=1, mantissa=[8], exp=-1).

`tumblercmp` treats negative tumblers as strictly less than all positive tumblers and zero, regardless of magnitude. A negative tumbler sorts before all valid V-addresses.

**Why it matters for spec:** The tumbler type must include a sign field: `Tumbler = {sign: bool, digits: seq<nat>}`. The total order over tumblers is: all negative tumblers < zero < all positive tumblers, with sign-aware absolute comparison within each sign class. Subtraction is closed over the tumbler type (always produces a valid tumbler), but the result may be negative even when both operands are positive. This is critical because the POOM and other data structures do not guard against negative tumblers being stored.

**Code references:**
- `tumble.c:406-440` — `tumblersub` implementation, sign negation at lines 424 and 427
- `tumble.c:72-85` — `tumblercmp`, negative tumblers always compare as LESS

**Concrete example:**
```
tumblersub(1.2, 0.10):
  b (0.10) > a (1.2) in absolute value
  Result: sign=1, magnitude=0.8  (i.e., -0.8)

tumblercmp(-0.8, 0.0):  → LESS
tumblercmp(-0.8, 1.1):  → LESS
tumblercmp(-0.8, -0.3): → GREATER (larger absolute value = more negative)
```

**Provenance:** Finding 0053

### ST-DELETE

**What happens:** DELETE shifts V-positions of POOM entries after the deletion range. In `deletend()` (edit.c:31-76), Case 2 handles entries positioned entirely after the deletion: their V-position is reduced by the deletion width via `tumblersub(&ptr->cdsp.dsas[index], width, &ptr->cdsp.dsas[index])`. There is no bounds check — if the deletion width exceeds the entry's current V-position, the result is a negative tumbler that is stored directly back into the POOM entry.

This means DELETE can produce POOM entries whose V-positions are negative. These entries remain in the POOM tree but become invisible: negative tumblers sort before all positive tumblers, placing them outside the valid V-address range. Link endsets at such positions return empty results from FOLLOWLINK.

**Why it matters for spec:** The postcondition for DELETE's V-position shifting must account for the possibility of negative results. Formally: `∀ entry ∈ poom(doc) : entry.vpos > delete_end ⟹ entry.vpos' = entry.vpos - delete_width`. When `delete_width > entry.vpos`, the result `entry.vpos'` is negative, creating a state where the entry exists in the POOM but maps to no valid V-address. The current implementation has no precondition preventing this — `pre_delete` does not check whether the shift would push entries negative.

**Code references:**
- `edit.c:63` — Case 2 subtraction: `tumblersub(&ptr->cdsp.dsas[index], width, &ptr->cdsp.dsas[index])`
- `edit.c:31-76` — `deletend()` full case analysis

**Concrete example:**
```
Pre-state:
  Document text at 1.1-1.15, link endset at V-position 1.5 (after POOM creation)

Operation: DELETE 3 bytes at 1.1
  Case 2 shift: 1.5 - 0.3 = 1.2 (valid, positive)
  Link endset now at 1.2

Operation: DELETE 10 bytes at 1.1
  Case 2 shift: 1.2 - 0.10 = -0.8 (negative!)
  Link endset stored at V-position -0.8

Post-state:
  POOM entry exists with sign=1 V-position
  FOLLOWLINK returns empty endsets []
  FINDLINKS cannot locate the link
```

**Provenance:** Finding 0053

### PRE-DELETE

**What happens:** DELETE does not validate whether V-position shifting will produce negative tumblers. The `deletend()` function processes all POOM entries after the deletion point uniformly — it subtracts the deletion width without checking whether the result would be negative. The only existing precondition for DELETE is non-zero width (checked in `deletevspanpm()`). There is no guard of the form `entry.vpos >= delete_width` for shifted entries.

This is a missing precondition: the backend accepts DELETE operations that corrupt POOM entries by shifting them to negative V-positions. The corruption is silent — no error is returned, and the entries become invisible rather than being removed or flagged.

**Why it matters for spec:** A complete precondition for DELETE should include: `∀ entry ∈ poom(doc) : entry.vpos > delete_end ⟹ entry.vpos - delete_width ≥ 0`. The current implementation does not enforce this. For formal verification, this is a case where the spec should document both the ideal precondition (what should hold) and the actual behavior (what happens when it's violated — negative tumblers, invisible entries).

**Code references:**
- `orglinks.c:145-152` — `deletevspanpm()` only checks zero-width
- `edit.c:31-76` — `deletend()` Case 2, no bounds check before subtraction

**Provenance:** Finding 0053

### INV-POOM-BIJECTIVITY

**What happens:** The POOM is designed to maintain a bijection between V-addresses and I-addresses (EWD-018 invariant I₁: `poom_d` is a bijection). DELETE can violate this invariant by creating POOM entries with negative V-positions. A negative V-position is in the domain of the stored POOM map but does not correspond to any valid V-address in the document's V-stream (which is defined over non-negative tumblers only). The entry occupies tree space and has a valid I-address target, but its V-address key is outside the legal V-space.

The system allows these I₁ violations to persist — there is no integrity check or cleanup mechanism. The violations are silent: no error is raised, and the entries are simply unreachable by any V-space query.

**Why it matters for spec:** Invariant I₁ as written (`poom_d` is a bijection from V-addresses to I-addresses) does not hold after certain DELETE sequences. The formal spec must either: (a) strengthen the DELETE precondition to prevent negative V-positions, or (b) weaken I₁ to: `poom_d restricted to non-negative V-addresses is a bijection`. Option (b) matches the actual implementation. The negative-position entries are effectively dead state — formally present but operationally unreachable.

**Code references:**
- `edit.c:63` — the subtraction that can violate I₁
- `tumble.c:72-85` — comparison semantics that make negative entries unreachable

**Provenance:** Finding 0053

### EC-DEEPLY-ORPHANED-LINK

**What happens:** When DELETE shifts a link's endset V-positions negative, the link enters a state distinct from a standard orphaned link (Finding 0024). In a standard orphan, the link's POOM entry exists at a valid V-position but the content it points to has been deleted. In a deeply orphaned link, the POOM entry itself has an invalid (negative) V-position — the entry exists in the tree but is unreachable by any query.

| Scenario | POOM V-pos | I-space | FOLLOWLINK | FINDLINKS |
|----------|-----------|---------|------------|-----------|
| Normal link | Valid positive | Exists | Returns endsets | Finds link |
| Orphaned (0024) | Valid positive | Exists | Empty (content gone) | Fails |
| Reverse orphan (0040) | Absent (deleted) | Exists | Works | Works |
| Deeply orphaned (0053) | Negative (invalid) | Exists | Empty endsets | Fails |

The deeply orphaned state differs from POOM deletion (Finding 0040) in that the POOM entry still physically exists but is invisible. It also cannot be targeted by a subsequent `DELETEVSPAN` because its V-position is negative and thus unreachable by a positive-valued V-span argument.

**Why it matters for spec:** This is a fourth link lifecycle state that the formal model must account for. The predicate `link_reachable(link, doc) ≡ link ∈ poom(doc) ∧ link.vpos ≥ 0` distinguishes reachable links from deeply orphaned ones. Unlike reverse orphans (where the POOM entry is cleanly removed), deeply orphaned entries are leaked state that cannot be reclaimed by normal operations.

**Code references:**
- `orglinks.c:446-448` — FOLLOWLINK fails to map negative V-positions to I-addresses
- Golden test `golden/links/delete_text_before_link.json` lines 118-122 — empty endsets after full deletion
- Golden test `golden/links/delete_partial_text_before_link.json` lines 118-126 — shift 1.5→1.2; line 160 — empty endsets after negative shift

**Provenance:** Finding 0053
