# Finding 0041 Analysis

## Entries

### SS-DUAL-ENFILADE
The enfilade B-tree used by the permanent layer (ispace + spanf) stores I-address to data mappings in a sibling-linked tree structure. New entries are inserted as the RIGHT BROTHER of the retrieval position via `adopt(new, RIGHTBRO, ptr)`. Siblings are walked left-to-right during retrieval (`findcbcseqcrum`), and nodes split by moving the rightmost half of sons to a new sibling when overflow occurs (`splitcrumseq`).

**Why it matters for spec:** The physical tree structure is an implementation detail below the abstraction boundary. The spec should model the enfilade as a set/multimap of I-address mappings, not as a tree with sibling ordering. The tree details are relevant only for proving that the implementation correctly refines the abstract spec.

**Code references:**
- `backend/insert.c:43-46` — `insertseq()`, new crum adopted as RIGHTBRO
- `backend/retrie.c:167-188` — `findcbcseqcrum()`, left-to-right sibling walk
- `backend/split.c:70-93` — `splitcrumseq()`, rightmost-half split policy
- `backend/genf.c:419` — `adopt()` sibling insertion

**Provenance:** Finding 0041

### INV-ENFILADE-CONFLUENCE
The permanent layer is logically confluent under concurrent additions: if operations O1 and O2 independently add entries E1 and E2 to the permanent layer, the queryable content is independent of execution order. Formally: `add(add(sigma, E1), E2)` and `add(add(sigma, E2), E1)` produce the same set of I-address mappings and the same results for `retrieve` and `retrieveinspan` queries.

This confluence holds at the abstraction boundary (query results) but NOT at the physical level (tree shape, sibling ordering, split points differ based on insertion order).

**Why it matters for spec:** This is a key commutativity invariant for the permanent layer. It means the spec can model permanent layer additions as set union without worrying about ordering. It also means serialization strategy for concurrent access is a correctness concern only for structural integrity, not for logical content.

**Concrete example:**
Inserting A then B at I-address `1.1.0.1.0.1`:
- Before: empty enfilade
- After (A then B): `{1.1.0.1.0.1 -> A, 1.1.0.1.0.1 -> B}`, tree has Crum_A as left sibling of Crum_B
- After (B then A): `{1.1.0.1.0.1 -> A, 1.1.0.1.0.1 -> B}`, tree has Crum_B as left sibling of Crum_A
- Query results: identical in both cases

**Code references:**
- `backend/insert.c:43-46` — insertion always as RIGHTBRO determines physical ordering
- `backend/retrie.c:167-188` — retrieval walks left-to-right but returns same logical content regardless of tree shape

**Provenance:** Finding 0041

### PRE-CONCURRENT-INSERT
Concurrent unsynchronized insertion into the same enfilade is unsafe. The `adopt(new, RIGHTBRO, ptr)` call modifies shared pointers, `father->numberofsons` can suffer lost updates, and split/rebalance operations assume exclusive access. Serialization is required for structural integrity.

**Why it matters for spec:** This is a precondition for safe multi-threaded permanent layer access. The spec should require mutual exclusion (or equivalent) around enfilade modification operations. However, since logical confluence holds (INV-ENFILADE-CONFLUENCE), any serialization order produces correct results — the choice of serialization strategy is an implementation freedom.

**Code references:**
- `backend/insert.c:43-46` — shared pointer modification in `adopt()`
- `backend/split.c:70-93` — `splitcrumseq()` assumes exclusive access to `father->numberofsons`

**Provenance:** Finding 0041

### FC-ENFILADE-QUERY-INDEPENDENCE
Query operations (`retrieve`, `retrieveinspan`) return results that are independent of the physical tree structure. Different insertion orderings produce different tree shapes (sibling ordering, split points, disk layout) but identical query results. The widdative summaries (`cwid` fields) maintain the same logical intervals regardless of tree shape.

**Why it matters for spec:** This is a frame condition on the observation functions — the physical tree structure is not observable through the query interface. The spec can treat the enfilade as an abstract set without modeling tree internals, and refinement proofs need only show that queries over any valid tree shape produce the same results.

**Code references:**
- `backend/retrie.c:167-188` — `findcbcseqcrum()` returns same logical content regardless of sibling order

**Provenance:** Finding 0041
