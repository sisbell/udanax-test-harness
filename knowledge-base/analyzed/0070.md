# Finding 0070 Analysis

## Entries

### SS-ENFILADE-BRANCHING

**What happens:** Enfilade tree shape is governed by three hard-coded branching constants in `enf.h` that set maximum children per node. The limits are type-aware and height-aware:

| Constant | Value | Scope |
|----------|-------|-------|
| `MAXUCINLOAF` | 6 | Upper crums (height > 1), all enfilade types |
| `MAX2DBCINLOAF` | 4 | Bottom crums (height 0-1) in 2D enfilades (SPAN, POOM) |
| `MAXBCINLOAF` | 1 | Bottom crums in 1D enfilades (GRAN) |

The GRAN bottom limit of 1 means granfilades are effectively lists at the bottom level, with B-tree structure only in upper levels. The comment "so text will fit" indicates this is a deliberate design choice tied to the data model, not a tuning parameter.

These constants are baked into the on-disk format: `coredisk.h:56` declares `ducarray[MAXUCINLOAF]` in the disk upper crum structure, so changing the branching factor requires a format migration.

**Why it matters for spec:** The branching constants define the domain of valid node states. Any enfilade invariant about node occupancy must reference these type-dependent and height-dependent bounds. A formal model needs a function `max_children(height, enfilade_type) -> nat` that returns the correct limit for each context. Tree depth is bounded by `O(log_6(N))` for upper levels.

**Code references:**
- `backend/enf.h:26-28` — constant definitions
- `backend/coredisk.h:50,56` — disk layout arrays sized by `MAXUCINLOAF`

**Provenance:** Finding 0070

### INV-ENFILADE-OCCUPANCY

**What happens:** Four threshold functions in `genf.c:239-261` define a rebalancing envelope that maintains node occupancy within valid bounds. For upper crums (branching factor B = `MAXUCINLOAF` = 6):

| Predicate | Condition | Upper crum threshold | Triggers |
|-----------|-----------|---------------------|----------|
| `toomanysons(ptr)` | `sons > B` | > 6 | Split via `splitcrumupwards` |
| `roomformoresons(ptr)` | `sons < B` | < 6 | Allows insertion of another child |
| `toofewsons(ptr)` | `sons < B - 1` | < 5 | Merge/steal via `recombinend` |

The thresholds create three occupancy zones:
- **Underfull** (1..B-2 = 1..4): `toofewsons` is TRUE, node tries to steal nephews
- **Normal** (B-1 = 5): Neither underfull nor at capacity
- **At capacity** (B = 6): `roomformoresons` is FALSE (cannot accept more), but `toomanysons` is also FALSE (no split needed) — this is the stable maximum
- **Overfull** (> B = 7+): `toomanysons` triggers split

The gap between `roomformoresons` (strict <) and `toomanysons` (strict >) at exactly B sons creates a stable equilibrium state. A node at exactly B children is full but valid.

All four functions select their threshold using the same height-aware, type-aware dispatch: `height > 1 ? MAXUCINLOAF : is2d ? MAX2DBCINLOAF : MAXBCINLOAF`.

**Why it matters for spec:** This defines the core B-tree invariant for enfilades. For every non-root internal node, the occupancy must satisfy `1 <= sons <= B` where B = `max_children(height, type)`. The rebalancing operations (split, merge, steal) maintain this invariant as a postcondition. The invariant can be stated:

```
forall node in enfilade:
  node.sons >= 1  (except empty root, see Bug 0019)
  node.sons <= max_children(node.height, enfilade.type)
```

The split precondition is `sons > B`; the merge precondition is `sons < B - 1` (for upper crums).

**Code references:**
- `backend/genf.c:239-261` — `toomanysons`, `roomformoresons`, `toofewsons` threshold functions
- `backend/split.c:16-43` — `splitcrumupwards` loop (splits while `toomanysons`)
- `backend/recombine.c:104-131` — `recombinend` rebalancing (steals while `toofewsons`)
- `backend/insertnd.c:242-275` — `insertcbcnd` checks `roomformoresons` before adding child

**Concrete example:** Upper crum with 6 children (at capacity):
- `toomanysons` → FALSE (6 is not > 6)
- `roomformoresons` → FALSE (6 is not < 6)
- `toofewsons` → FALSE (6 is not < 5)
- State: stable, no rebalancing triggered

Insert a 7th child:
- `toomanysons` → TRUE (7 > 6)
- `splitcrumupwards` splits the node into two nodes (e.g., 4+3 or 3+4)
- If node is the fullcrum (root), `levelpush` adds a new root level
- If node is not root, `splitcrum` splits within the current level

**Provenance:** Finding 0070

### PRE-SPLIT

**What happens:** `splitcrumupwards` at `split.c:16-43` loops while `toomanysons(ptr)` returns TRUE. Before each iteration, the function checks `isfullcrum(ptr)` to decide the split strategy:

- If `isfullcrum` is TRUE (node is the root/apex): calls `levelpush` to create a new root level above, then splits the old root into children of the new root.
- If `isfullcrum` is FALSE (node is internal): calls `splitcrum` to split the node within its current level, distributing children between the original node and a new sibling.

Despite its name, `isfullcrum` tests whether the crum is the **fullcrum** (root/apex node), not whether it is "full" in the occupancy sense. It is implemented as `((typecorecrum *)(x))->isapex`.

**Why it matters for spec:** The split operation has a branching precondition: at the root it changes tree height (structural), while at internal nodes it changes tree width (local). The formal model needs both cases:
- `split_root(tree)`: height' = height + 1, new root has 2 children
- `split_internal(node)`: parent gains one child, node loses some children to new sibling

**Code references:**
- `backend/split.c:16-43` — `splitcrumupwards` loop with `isfullcrum` dispatch
- `backend/genf.c:239-242` — `toomanysons` predicate (loop guard)

**Provenance:** Finding 0070

### EC-GRAN-BOTTOM-SINGLETON

**What happens:** GRAN (1D) enfilades have `MAXBCINLOAF = 1`, meaning bottom crums hold exactly one entry. The comment in `enf.h` says "so text will fit." This makes the granfilade bottom level effectively a linked list: each bottom crum contains a single text entry, with B-tree fan-out only at upper levels (where `MAXUCINLOAF = 6` still applies).

This asymmetry means the threshold functions behave differently at the bottom of a GRAN enfilade:
- `toomanysons` triggers at > 1 (any bottom node with 2+ children must split)
- `roomformoresons` returns TRUE only when sons = 0 (empty)
- `toofewsons` returns TRUE when sons < 1 (i.e., the node is empty)

**Why it matters for spec:** The formal model must handle GRAN bottom crums as a degenerate case of the B-tree structure. The occupancy invariant at the bottom level of a GRAN is `sons = 1` (exactly one entry per bottom crum), which is much tighter than the upper-level bound. This also means GRAN bottom crums never undergo merge/steal operations in the usual sense — they're always at their only valid occupancy.

**Code references:**
- `backend/enf.h:28` — `MAXBCINLOAF` = 1, with comment "so text will fit"
- `backend/genf.c:239-261` — threshold functions selecting `MAXBCINLOAF` for GRAN bottom crums

**Provenance:** Finding 0070
