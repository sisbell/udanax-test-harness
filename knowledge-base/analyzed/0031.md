# Finding 0031 Analysis

## Entries

### SS-TUMBLER

**What happens:** A tumbler is stored as a sign bit, a short exponent, and a fixed-length mantissa of `NPLACES` (16) digits. The exponent shifts the mantissa: `exp = 0` means the first mantissa digit is the most-significant; negative exponent represents fractional/sub-positions. Zeros within the mantissa act as hierarchical separators (e.g., `1.1.0.2.0.5` = node `1.1`, account `1.1.0.2`, item `1.1.0.2.0.5`). `tumblerlength()` returns the number of significant digits: `nstories(t) - t.exp`.

**Why it matters for spec:** The concrete representation constrains the formal type. A tumbler is not an arbitrary rational — it is a fixed-precision hierarchical number with at most 16 digits. The exponent/mantissa encoding means two tumblers are equal iff their sign, exponent, and all 16 mantissa digits match (no normalization ambiguity after `tumblerjustify`). The zero-separator convention is semantic, not structural — the data type itself does not enforce hierarchy boundaries.

**Code references:** `common.h:59-65` (struct definition), `tumble.c:24-36` (`tumblereq`), `tumble.c:599-623` (`tumblerincrement`).

**Concrete example:**
- Tumbler `1.1.0.2.0.5`: `exp=0`, `mantissa=[1,1,0,2,0,5,0,0,...,0]`
- Tumbler zero: all mantissa digits zero, detected by `iszerotumbler()`

**Provenance:** Finding 0031

### SS-SPAN

**What happens:** A span (`typespan`) consists of a linked-list pointer, an item ID, a start tumbler (`stream`), and a width tumbler (`width`). Width is computed as `end - start` via tumbler subtraction. The same struct is used for both I-space spans (`typeispan`) and V-space spans (`typevspan`) — they are typedefs, not distinct types.

**Why it matters for spec:** Span is the fundamental unit of content reference. The formal type is `Span(itemid, start: Tumbler, width: Tumbler)` where `end = tumbleradd(start, width)`. The I-span/V-span distinction is semantic (which address space), not structural. Width being a tumbler (not an integer) means hierarchical widths are representable, though text content uses flat numeric widths where width equals character count.

**Code references:** `xanadu.h:65-76` (struct definition), `granf2.c:106` (`tumblersub(&lsa, &spanorigin, &ispanptr->width)`).

**Concrete example:**
- Insert "Hello" (5 chars) at I-address `2.1.0.5.0.100`: end address is `2.1.0.5.0.105`, width represents 5 positions.
- Width = `tumblersub(endAddr, startAddr)`

**Provenance:** Finding 0031

### INV-TUMBLER-TOTAL-ORDER

**What happens:** `tumblercmp` defines a total order over tumblers. Comparison proceeds: (1) check for zero tumblers, (2) compare signs, (3) compare absolute values via `abscmp`. `abscmp` first compares exponents — a larger exponent means a larger absolute value — then compares mantissa digits lexicographically left-to-right. The result is always `LESS`, `EQUAL`, or `GREATER`.

**Why it matters for spec:** The total order on tumblers is a foundational invariant. All interval checks, span containment tests, and enfilade traversals depend on this ordering being total, antisymmetric, and transitive. The ordering is lexicographic after exponent alignment, which means the zero-separator hierarchy is respected: `1.1.0.2` < `1.1.0.2.0.1` because the shorter tumbler has trailing zeros that are less than the non-zero continuation.

**Code references:** `tumble.c:72-85` (`tumblercmp`), `tumble.c:87-111` (`abscmp`).

**Concrete example:**
- `tumblercmp(1.1.0.2, 1.1.0.2.0.1)` → `LESS` (trailing zeros vs non-zero digits)
- `tumblercmp(zero, any_positive)` → `LESS`
- `tumblercmp(negative, positive)` → `LESS`

**Provenance:** Finding 0031

### SS-INTERVAL-CMP

**What happens:** `intervalcmp(left, right, address)` classifies an address relative to a half-open-ish interval `[left, right]`. It returns five spatial relationships: `TOMYLEFT` (address < left), `ONMYLEFTBORDER` (address == left), `THRUME` (left < address < right), `ONMYRIGHTBORDER` (address == right), `TOMYRIGHT` (address > right). The borders are distinguished from the interior, making this a closed-interval test with explicit border detection.

**Why it matters for spec:** This is the primitive for all span-containment and overlap checks. The five-way result (not just boolean in/out) is essential — operations behave differently at span borders vs. interior. The spec needs: `IntervalPos = ToLeft | OnLeft | Through | OnRight | ToRight` with `IntervalCmp(left, right, addr) -> IntervalPos` as a derived function from the tumbler total order.

**Code references:** `tumble.c:144-160` (`intervalcmp`).

**Concrete example:**
- `intervalcmp(10, 20, 5)` → `TOMYLEFT` (-2)
- `intervalcmp(10, 20, 10)` → `ONMYLEFTBORDER` (-1)
- `intervalcmp(10, 20, 15)` → `THRUME` (0)
- `intervalcmp(10, 20, 20)` → `ONMYRIGHTBORDER` (1)
- `intervalcmp(10, 20, 25)` → `TOMYRIGHT` (2)

**Provenance:** Finding 0031

### ST-INSERT

**What happens:** During text insertion (`inserttextgr`), I-addresses are allocated contiguously: the start address is found via `findisatoinsertgr`, then advanced by text length using `tumblerincrement(&lsa, 0, textset->length, &lsa)`. The `rightshift=0` parameter means the increment is applied at the last significant digit of the current address. The resulting I-span width is `tumblersub(endAddr, startAddr)`, which equals the character count for text content.

**Why it matters for spec:** This defines the state transition for insert: `I_next = tumblerincrement(I_current, 0, len)` and `width = I_next - I_current`. The `rightshift=0` semantics of `tumblerincrement` means new content extends at the same hierarchy level as the insertion point. One I-address per character is the granularity invariant for text.

**Code references:** `granf2.c:83-108` (`inserttextgr`), `granf2.c:100` (increment), `granf2.c:106` (width computation).

**Concrete example:**
- Insert "Hello" at `2.1.0.5.0.100`: `tumblerincrement(2.1.0.5.0.100, 0, 5)` → `2.1.0.5.0.105`
- Width: `tumblersub(2.1.0.5.0.105, 2.1.0.5.0.100)` → represents 5 positions

**Provenance:** Finding 0031

### INV-IADDR-IMMUTABILITY

**What happens:** `tumblerintdiff` extracts the integer value from a tumbler width, but only when the width is "flat" (no hierarchical structure). This is used in `insertpm` (`orglinks.c:116-117`) to convert a tumbler width back to an integer count. The permascroll is append-only: text characters occupy contiguous I-addresses, and these allocations are permanent.

**Why it matters for spec:** Confirms that I-address allocation is monotonic and append-only. The `tumblerintdiff` function acts as a witness that text widths are always flat integers at the implementation level, supporting the invariant that text content occupies exactly one I-address per character with no gaps.

**Code references:** `orglinks.c:116-117` (`tumblerintdiff` and `tumblerincrement` in `insertpm`).

**Provenance:** Finding 0031
