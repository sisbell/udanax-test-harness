# Finding 0002 Analysis

## Entries

### SS-CONTENT-IDENTITY

**What happens:** Content in udanax-green has permanent, immutable identity. Documents are not containers of mutable text; they are collections of references to content identities. When a user "edits" a document, the system creates new content for the inserted material — it does not modify existing content in place. A document's view is the set of content identities it currently references.

**Why it matters for spec:** This is the foundational state structure for the content model. The formal spec needs: a type `ContentId` that is unique and permanent, a document state `Document = set<ContentRef>` where each `ContentRef` maps a position to a `ContentId`, and the invariant that `ContentId` values are never reused or mutated. All operations (insert, remove, vcopy) manipulate which `ContentId` values a document references, not the content itself.

**Concrete example:**
- Before: Source document references content identities for "Original content here"
- After insert at beginning: Source now references NEW content identities for "NEW: " plus the SAME identities for "Original content here"
- The string "Original content here" still has the same content identities — the insert created new identities only for "NEW: "

**Code references:** `scenario_vcopy_source_modified` in `febe/scenarios/content/vcopy.py:271-338`

**Provenance:** Finding 0002

### INV-CONTENT-IMMUTABILITY

**What happens:** Content identities, once created, are never modified or destroyed. Deletion from a document removes that document's reference to the content, but the content identity persists as long as any document in the system references it. Insertion into a document creates new content identities without affecting existing ones. This holds across all operations tested: insert, remove, and vcopy.

**Why it matters for spec:** This is a global invariant: `forall c : ContentId, t1 t2 : Time :: exists_at(c, t1) && referenced(c, t2) ==> exists_at(c, t2)` — content that exists and is referenced is never destroyed. More strongly, content identity is eternal: once created, the identity exists permanently in the system regardless of reference count (the system does not garbage-collect content). The formal spec should assert that the set of all content identities is monotonically growing.

**Concrete example:**
- Source: "Keep this. Delete this. Keep end."
- Target vcopies "Delete this." from source
- "Delete this." is removed from source: Source becomes "Keep this. Keep end."
- Target still reads "Transcluded: Delete this." — the content identity persists

**Code references:** `scenario_vcopy_source_deleted` in `febe/scenarios/content/vcopy.py:341-417`

**Provenance:** Finding 0002

### ST-INSERT

**What happens:** Insert creates new content identities for the inserted text and adds them to the document's reference set at the specified position. Existing content identities in the document are not modified — their positions may shift but their identities remain the same. Documents that transclude content from this document are unaffected because they reference the original content identities, which are unchanged.

**Why it matters for spec:** The postcondition for insert is: (1) new `ContentId` values are created for the inserted material, (2) the document's reference set grows by those new identities, (3) no existing `ContentId` in any document is modified. This is the key distinction from a mutable-string model: insert does not mutate, it extends.

**Concrete example:**
- Before insert: Source references identities for "Original content here"
- After `insert(source, Address(1,1), ["NEW: "])`: Source references identities for "NEW: " (new) + "Original content here" (same identities as before)
- Target that transcluded "Original content" still reads the same — unaffected

**Code references:** `scenario_vcopy_source_modified` in `febe/scenarios/content/vcopy.py:306-310`

**Provenance:** Finding 0002

### FC-DOC-ISOLATION

**What happens:** Modifications to a source document (both insertions and deletions) do not affect documents that have transcluded content from it. After vcopy, the target holds its own references to the content identities. Subsequent changes to the source document's reference set have no effect on the target's reference set. Each document's view is independent.

**Why it matters for spec:** This is a frame condition on insert and remove: `forall doc_other != doc_modified :: references(doc_other) is unchanged`. The formal spec must assert that insert and remove operations on one document do not alter any other document's reference set. This is a direct consequence of content immutability — since operations create/remove references rather than mutating content, and each document has its own reference set, cross-document interference is impossible.

**Concrete example:**
- Source: "Original content here", Target transcluded "Original content"
- Insert "NEW: " at start of source → Source: "NEW: Original content here"
- Target: still "Target: Original content" (unchanged)
- Delete "Delete this." from source → Source loses that reference
- Target that transcluded "Delete this." still has it (its reference is independent)

**Code references:** `scenario_vcopy_source_modified` at `febe/scenarios/content/vcopy.py:312-317`, `scenario_vcopy_source_deleted` at `febe/scenarios/content/vcopy.py:388-395`

**Provenance:** Finding 0002

### ST-VCOPY

**What happens:** The vcopy (virtual copy / transclusion) operation adds references to existing content identities into the target document. It does not copy the content itself — it creates new references to the same identities that the source document references. After vcopy, `compare_versions` between source and target reports shared content, confirming that both documents reference the same content identities.

**Why it matters for spec:** The postcondition for vcopy is: `references(target) = references(target_before) ∪ {content_ids referenced by source_specset}`. No new content identities are created. The target gains references to exactly the content identities specified in the source specset. This makes vcopy fundamentally different from insert — insert creates new identities, vcopy shares existing ones.

**Concrete example:**
- Source references identities for "Shared content that will be transcluded"
- After `vcopy(target, position, specset_referencing_source["Shared content"])`:
  - Target now references both its own "Prefix: " identities AND the source's "Shared content" identities
  - `compare_versions(source, target)` returns the shared span

**Code references:** `scenario_vcopy_preserves_identity` in `febe/scenarios/content/vcopy.py:61-128`

**Provenance:** Finding 0002

### INV-TRANSITIVE-IDENTITY

**What happens:** Content identity is preserved transitively through chains of transclusion. If document B transcludes from C, and document A transcludes from B, then A and C share content identity even though A never directly referenced C. The `compare_versions` operation between A and C correctly reports the shared content.

**Why it matters for spec:** This is an invariant on identity propagation: `shares_identity(A, B) && shares_identity(B, C) ==> shares_identity(A, C)`. It follows from the vcopy semantics — since vcopy shares the actual content identity (not a copy), chains of vcopy naturally preserve identity. The formal spec need not add a special transitivity rule; it falls out of the state-transition definition of vcopy.

**Concrete example:**
- C: "Original from C"
- B: "B prefix: " + vcopy("Original" from C) → B references C's content identity for "Original"
- A: "A prefix: " + vcopy(all of B) → A references B's "B prefix: " identities AND C's "Original" identity
- `compare_versions(A, C)` reports shared content "Original"

**Code references:** `scenario_nested_vcopy` in `febe/scenarios/content/vcopy.py:180-268`

**Provenance:** Finding 0002

### ST-REMOVE

**What happens:** Remove (deletion) removes content references from a document's reference set at the specified span. The content identities themselves are not destroyed. Other documents that reference the same content identities are unaffected.

**Why it matters for spec:** The postcondition for remove is: `references(doc) = references(doc_before) \ {content_ids at specified span}`. Combined with INV-CONTENT-IMMUTABILITY, the full postcondition is: the document loses references, but global content state is unchanged. This makes remove a local operation on the document's reference set with no global side effects.

**Concrete example:**
- Source: references identities for "Keep this. Delete this. Keep end."
- After `remove(source, span_of("Delete this. "))`: Source references only "Keep this. " and "Keep end."
- The content identities for "Delete this." still exist globally (target still references them)

**Code references:** `scenario_vcopy_source_deleted` in `febe/scenarios/content/vcopy.py:383-387`

**Provenance:** Finding 0002
