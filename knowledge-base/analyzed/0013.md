# Finding 0013 Analysis

## Entries

### SS-SPORGL

**What happens:** The **sporgl** (span + orgl) is the fundamental provenance-carrying data structure. It packages three pieces of information: (1) `sporglorigin` — an I-address identifying content in the permascroll; (2) `sporglwidth` — the width of the content span; (3) `sporgladdress` — the ISA of the document where the content resides. A sporgl answers: "this I-address range came from this document." Sporgls are stored as a linked list (`typesporglset`) and can be interchanged with ispans via a union type (`typesporglitem`), allowing code to handle both "anonymous" I-spans (no provenance) and "provenanced" sporgls uniformly.

**Why it matters for spec:** The sporgl is the intermediate representation between V-address space and I-address space that carries document provenance. The formal type is: `Sporgl = { origin: IAddress, width: TumblerWidth, source_doc: ISA }`. A `SporglSet` extends `ISpanSet` with provenance — the union type means any operation that accepts an `ISpanSet` can also accept a `SporglSet`. The spec must model this as a subtype or tagged union: `SporglItem = ISpan | Sporgl`. This structure is consumed by the spanf index (for link indexing), by docopy (for transclusion), and by correspond (for version comparison).

**Code references:**
- `xanadu.h:115-121` — `typesporgl` struct definition
- `xanadu.h:123-127` — `typesporglitem` union with `typeispan`
- `sporgl.c` — all sporgl operations

**Concrete example:**
```
After vspanset2sporglset on a document with text "Hello World" at V-positions 1.1..1.11:

Sporgl:
  sporglorigin = 2.1.0.5.0.100    (I-address: permascroll position of "Hello World")
  sporglwidth  = 0.11              (11 characters)
  sporgladdress = 1.1.0.1.0.1     (source document ISA)
```

**Provenance:** Finding 0013

### ST-VSPAN-TO-SPORGL

**What happens:** The function `vspanset2sporglset()` converts a set of V-address spans within a document into sporgls. For each vspan, it: (1) converts V-addresses to I-addresses via the document's enfilade (`vspanset2ispanset`); (2) attaches the source document ISA to each resulting I-span, producing a sporgl. The output sporglset preserves the content identity (I-address) while adding provenance (which document). The reverse operation `linksporglset2specset()` converts sporgls back to V-address specs for display or user-facing operations.

**Why it matters for spec:** This is a key state transition in many compound operations. The conversion is: `vspan_to_sporgl(doc, vspan) = { origin: V_to_I(doc, vspan.start), width: vspan.width, source_doc: doc.isa }`. The postcondition is that the I-address range in the sporgl exactly corresponds to the content at the given V-positions in the document. This conversion is a pure function over the document's current V→I mapping — it reads the enfilade but does not modify it. The inverse `linksporglset2specset` is also pure: it looks up the sporgl's I-address in the source document's enfilade to recover V-positions.

**Code references:**
- `sporgl.c:35-65` — `vspanset2sporglset()` implementation
- `sporgl.c:97+` — `linksporglset2specset()` reverse conversion

**Concrete example:**
```
Input:
  doc ISA = 1.1.0.1.0.1
  vspan = V-range 1.1..1.15 (first 15 characters)

vspanset2sporglset(doc, vspan):
  Step 1: vspanset2ispanset → I-span at 2.1.0.5.0.100 for 0.15
  Step 2: attach doc ISA → sporgl(origin=2.1.0.5.0.100, width=0.15, doc=1.1.0.1.0.1)

Output: sporglset with one sporgl carrying both I-address and document provenance
```

**Provenance:** Finding 0013

### INT-SPORGL-LINK-INDEX

**What happens:** When a link is created, its endpoints (from, to, three) are converted to sporgls and indexed in the spanf enfilade. The function `insertendsetsinspanf()` receives sporglsets for each endpoint type and inserts them into the spanf index tagged with the link's ISA and endpoint type (`LINKFROMSPAN`, `LINKTOSPAN`). The spanf then maps: I-address → set of (link ISA, endpoint type) pairs. When retrieving links, the reverse path converts sporgls back to specsets via `linksporglset2specset()`.

**Why it matters for spec:** Sporgls are the data format at the interface between link creation and the spanf index. The spec for `insertendsetsinspanf` is: `spanf' = spanf ∪ { (sporgl.origin..sporgl.origin+sporgl.width) → (link_isa, endpoint_type) | sporgl ∈ endpoint_sporglset }`. The provenance field (`sporgladdress`) is stored in the index so that link retrieval can reconstruct which document each endpoint references. This means the spanf index stores document provenance, not just I-addresses.

**Code references:**
- `do2.c:116-128` — `insertendsetsinspanf()` inserts from/to/three sporglsets
- `sporgl.c:97+` — `linksporglset2specset()` for endpoint retrieval
- `spanf1.c` — spanf operations that consume sporglsets

**Provenance:** Finding 0013

### INT-SPORGL-TRANSCLUSION

**What happens:** During vcopy (transclusion), the data flow is: source V-spec → sporgls (via `vspanset2sporglset`) → `insertpm` into destination document. The sporgl carries the content's I-address identity through the copy operation. Because the sporgl preserves the original I-address (not a new one), the destination document ends up referencing the same content identities as the source. This is the mechanism by which transclusion preserves content identity — the sporgl is the carrier.

**Why it matters for spec:** The sporgl is the data structure that makes the ST-VCOPY postcondition (`references(target) = references(target_before) ∪ source_content_ids`) mechanically possible. Without the sporgl carrying provenance through the copy, the system would need another mechanism to ensure identity preservation. The spec for docopy should reference sporgls as the intermediate representation: `docopy(src, dst, vspec) = let sporgls = vspan_to_sporgl(src, vspec) in insert_by_iaddr(dst, sporgls)`.

**Code references:**
- `sporgl.c:35-65` — `vspanset2sporglset()` converts source content to sporgls
- The docopy flow: `VSpec → Sporgl → insertpm`

**Provenance:** Finding 0013

### INT-SPORGL-VERSION-COMPARE

**What happens:** Version comparison (`compare_versions` / `correspond.c`) uses sporgls to find shared content between documents. Both documents' content is converted to sporgls, then intersection is computed by I-address (the `sporglorigin` field). Sporgls with the same I-address origin in both documents represent shared content — content that was transcluded or shares common ancestry. The sporgl's document provenance (`sporgladdress`) field distinguishes which document each span came from, enabling the comparison to report which content is shared and which is unique to each document.

**Why it matters for spec:** This is the mechanism underlying `compare_versions`: `shared(A, B) = { s ∈ sporgls(A) | ∃ t ∈ sporgls(B) :: s.origin ∩ t.origin ≠ ∅ }`. The I-address intersection is only meaningful for permascroll I-addresses (not link ISAs), connecting to the PRE-COMPARE-VERSIONS precondition from Finding 0009. The sporgl makes version comparison possible because it lifts document content from V-space (position-dependent) to I-space (identity-dependent) while retaining document provenance.

**Code references:**
- `correspond.c` — uses sporgls for version comparison
- `sporgl.c` — sporgl operations used by correspond

**Provenance:** Finding 0013
