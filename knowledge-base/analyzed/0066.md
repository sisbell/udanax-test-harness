# Finding 0066 Analysis

## Entries

### SS-ENFILADE-TREE

**What happens:** 2D enfilades (POOM, SPAN) use coordinate-transform-based displacement, fundamentally different from 1D enfilades (GRAN). In 2D enfilades, the root node's `cdsp` field dynamically tracks the minimum tumbler address across all content in the tree. Children's displacements are stored relative to the root, not as absolute positions. In contrast, GRAN enfilades keep root displacement at zero and use width-summation (`widopseq`) rather than min-tracking.

The three enfilade types differ in their root-level semantics:

| Enfilade Type | Root `cdsp` | Child `cdsp` | Wisp Operation |
|---------------|-------------|--------------|----------------|
| GRAN (1D) | Always 0 | Absolute position | `setwidseq` — sum widths |
| POOM (2D) | Minimum address | Relative to root | `setwispnd` — min-track + adjust |
| SPAN (2D) | Minimum address | Relative to root | `setwispnd` — min-track + adjust |

For 2D enfilades, `root.cdsp` and `root.cwid` together form a bounding box: `root.cdsp` is the upper-left corner (minimum address), `root.cdsp + root.cwid` is the lower-right corner (maximum extent).

**Why it matters for spec:** The spec must parameterize enfilade behavior by type. The grasp function has different semantics at the root: `grasp(root) = root.cdsp` for 2D (typically non-zero), vs `grasp(root) = 0` for 1D. Any enfilade invariant must be qualified by enfilade type. The relative-displacement design means `absolute_grasp(node) = sum_of_ancestor_displacements + node.cdsp`, which holds recursively for all enfilade types but starts from different root values.

**Code references:**
- `backend/wisp.c:171-228` — `setwispnd`: finds minimum child displacement, absorbs it into root, adjusts children to relative
- `backend/wisp.c:150-168` — `setwidseq`: GRAN width-summation (no displacement tracking)
- `backend/credel.c:580-581` — `createcruminternal`: all crums initialized with zero displacement
- `backend/retrie.c:334-339` — `prologuend`: `grasp = offset + ptr->cdsp`
- `backend/genf.c:97-116` — `isemptyenfilade`: 2D checks both width AND displacement are zero; GRAN checks only width

**Concrete example:** Empty POOM, insert at position 2.1:

Before: `root.cdsp = 0, root.cwid = 0` (empty)

After first insertion:
1. `firstinsertionnd` sets child `cdsp = 2.1` (absolute)
2. `setwispnd` finds `mindsp = 2.1`, absorbs: `root.cdsp = 0 + 2.1 = 2.1`
3. Child adjusted: `child.cdsp = 2.1 - 2.1 = 0` (now relative)
4. Final: `root.cdsp = 2.1, root.cwid = 1; child.cdsp = 0, child.cwid = 1`
5. `grasp(root) = 0 + 2.1 = 2.1` (non-zero)

**Provenance:** Finding 0066

### INV-ENFILADE-RELATIVE-ADDRESSING

**What happens:** For all 2D enfilade nodes, the absolute grasp of any node equals the sum of ancestor displacements plus its own displacement:

```
absolute_grasp(node) = absolute_grasp(parent) + node.cdsp
absolute_grasp(root) = root.cdsp
```

This is maintained by `setwispnd`, which after every modification: (1) finds the minimum displacement `mindsp` across all children, (2) adds `mindsp` to the parent's `cdsp`, and (3) subtracts `mindsp` from every child's `cdsp`. The operation at `wisp.c:211` — `dspsub(&ptr->cdsp, &mindsp, &ptr->cdsp, ...)` — is the critical step converting children from absolute to relative.

This invariant is type-specific: it holds for POOM and SPAN enfilades. GRAN enfilades use a different scheme where root displacement is always zero and `setwidseq` sums widths instead of tracking displacements.

**Why it matters for spec:** This is a core structural invariant for 2D enfilades. Any formal model must capture that displacement is relative, not absolute, and that the root's displacement equals the minimum address in the tree. The grasp calculation `grasp = offset + dsp` at `retrie.c:337` depends on this invariant being maintained.

**Code references:**
- `backend/wisp.c:196` — `dspadd(&father->cdsp, &mindsp, &newdsp, ...)` — root absorbs minimum
- `backend/wisp.c:211` — `dspsub(&ptr->cdsp, &mindsp, &ptr->cdsp, ...)` — children become relative
- `backend/retrie.c:337` — `dspadd(offset, &ptr->cdsp, grasp, ...)` — grasp from displacement

**Provenance:** Finding 0066

### ST-INSERT

**What happens:** In 2D enfilades, `firstinsertionnd` (for first child) sets the child's `cdsp` to the absolute insertion position, then calls `setwisp` on the parent. For subsequent insertions, `makegappm` shifts existing crums whose V-position follows the insertion point by adding the width to their displacement (`insertnd.c:162`: `tumbleradd(&ptr->cdsp.dsas[V], &width->dsas[V], &ptr->cdsp.dsas[V])`). After any insertion, `setwispupwards` recalculates the root's displacement by finding the new minimum across all children.

When inserting at a position less than the current root displacement, the root's `cdsp` decreases to the new minimum, and all existing children's displacements increase (they shift upward relative to the new, lower origin).

**Why it matters for spec:** Insert into a 2D enfilade has a cascade effect: the insertion may change the root's displacement, which changes the relative displacements of all siblings. The postcondition must account for this: after insert, `root.cdsp = min(old_root.cdsp, new_position)`, and all children's relative displacements are adjusted accordingly.

**Code references:**
- `backend/insertnd.c:199-218` — `firstinsertionnd`: child gets absolute position, then `setwisp(root)`
- `backend/insertnd.c:162` — `makegappm`: shifts crums after insertion point
- `backend/wisp.c:171-228` — `setwispnd`: recalculates root displacement after insertion

**Concrete example:** Content at 5.0 (`root.cdsp = 5.0, child_A.cdsp = 0`). Insert at 2.0:
- New `child_B.cdsp = 2.0` (absolute)
- `setwispnd` finds `mindsp = min(0, 2.0) = 0`... but wait, child_A is relative (0) and child_B is absolute (2.0). After `makegappm` and `setwispupwards`, the root recalculates: `mindsp` across children, root absorbs it, children adjust. Net result: `root.cdsp = 2.0`, `child_A.cdsp = 3.0` (was at absolute 5.0, now relative to root 2.0), `child_B.cdsp = 0` (at the new minimum).

**Provenance:** Finding 0066

### EC-EMPTY-DOC

**What happens:** Empty 2D enfilades are detected by checking that BOTH `cdsp` and `cwid` are zero (`isemptyenfilade` at `genf.c:97-116`). This is necessary because a non-empty 2D enfilade typically has non-zero `cdsp` (the minimum address). In contrast, empty GRAN enfilades only check that `cwid` is zero, because GRAN root displacement is always zero.

When all children of a 2D enfilade are deleted, `setwispnd` clears both `cdsp` and `cwid` to zero (`wisp.c:187-189`), restoring the empty state.

**Why it matters for spec:** The emptiness predicate is type-dependent. For GRAN: `empty(e) iff e.cwid = 0`. For POOM/SPAN: `empty(e) iff e.cwid = 0 AND e.cdsp = 0`. This asymmetry must be captured in the formal model.

**Code references:**
- `backend/genf.c:97-116` — `isemptyenfilade`: type-dependent emptiness check
- `backend/wisp.c:187-189` — `setwispnd`: clears both fields when all children deleted

**Provenance:** Finding 0066
