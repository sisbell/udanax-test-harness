# Finding 0024 Analysis

## Entries

### SS-ADDRESS-SPACE

**What happens:** Links occupy a separate address subspace (0.2.x) within their home document, distinct from the text subspace (1.x). A link address is structured as `{home_doc}.0.2.{link_number}`. For example, document `1.1.0.1.0.1` contains link `1.1.0.1.0.1.0.2.1` — the home document ID followed by `.0.2.1` identifying link subspace entry 1.

Links appear in the document's vspanset alongside text spans. After deleting all text from a document containing a link, the vspanset still reports a span `{"start": "2.1", "width": "0.1"}` — the link. Similarly, `retrieve_contents` returns the link as content: `{"link_id": "1.1.0.1.0.1.0.2.1"}`. This means a document with all text deleted is not "empty" if it contains links.

**Why it matters for spec:** The state model for documents must represent two content subspaces: text at 1.x and links at 0.2.x. Any predicate `is_empty(doc)` must check both subspaces. The vspanset type must accommodate both text spans and link spans. Formally: `doc_content(D) = text_spans(D) ∪ link_spans(D)`, where `text_spans` use addresses in the 1.x range and `link_spans` use addresses in the 0.2.x range.

**Concrete example:**
```
Document 1.1.0.1.0.1 with link and text:
  vspanset: [{start: 1.1, width: 0.5},     # text: 5 chars
             {start: 2.1, width: 0.1}]      # link: 1 link

After deleting all text:
  vspanset: [{start: 2.1, width: 0.1}]      # link still present
  retrieve_contents: [{link_id: "1.1.0.1.0.1.0.2.1"}]
```

**Provenance:** Finding 0024, Technical Discoveries sections 1-3.

### SS-LINK-ENDPOINT

**What happens:** Link types are stored as VSpec references to a type registry in the bootstrap document (doc 1), not as simple enums or flags. The type endset of a link points to a specific address in the bootstrap document's type subspace at `1.0.2.x`. The type system is hierarchical: MARGIN (`1.0.2.6.2`) is nested under FOOTNOTE (`1.0.2.6`), suggesting a subtype relationship.

Known type registry addresses:
| Type     | Local Address | Structure         |
|----------|--------------|-------------------|
| JUMP     | `1.0.2.2`    | version.0.types.2 |
| QUOTE    | `1.0.2.3`    | version.0.types.3 |
| FOOTNOTE | `1.0.2.6`    | version.0.types.6 |
| MARGIN   | `1.0.2.6.2`  | version.0.types.6.subtype.2 |

**Why it matters for spec:** Link types are content references, not metadata — they participate in the same address/identity system as all other content. The type hierarchy encoded by tumbler containment (`1.0.2.6.2` is contained in `1.0.2.6`) enables type queries like "find all footnote-family links" via address-range matching. The state structure for link types is: `link.type : VSpec` where `VSpec.docid = bootstrap_doc ∧ VSpec.spans ⊆ addresses(1.0.2.*)`.

**Code references:** `QUOTE_TYPE` and `MARGIN_TYPE` definitions in `febe/client.py` (VSpec construction with bootstrap document references).

**Provenance:** Finding 0024, Technical Discovery section 5.

### INV-LINK-PERMANENCE

**What happens:** Links are permanent objects — there is no DELETELINK operation in the FEBE protocol. Once created, a link exists forever. Deleting the content at a link's endpoints does not delete the link itself. Deleting all text from a link's home document does not affect the link. The link object persists independently of any content it references.

This is consistent with the broader Xanadu permanence model: I-addresses are permanent (INV-IADDRESS-PERMANENT), and links — which are indexed by I-address — inherit this permanence.

**Why it matters for spec:** Invariant: `∀ link ∈ links(system) :: once_created(link) ⟹ link ∈ links(system_future)` for all future states. The set of links in the system is monotonically growing. No operation in the system can remove a link. Combined with INV-IADDRESS-PERMANENT, this means the graph of links over content identities is append-only.

**Code references:** Test `link_permanence_no_delete_operation` (PASS). No DELETELINK opcode exists in the FEBE protocol.

**Provenance:** Finding 0024, Summary and Semantic Insight 1.

### FC-LINK-PERSISTENCE

**What happens:** The home document of a link (where the link is stored) is independent from the documents whose content the link's endpoints reference. Deleting all text from the home document has zero effect on link functionality — the link's source, target, and type endsets remain fully operational.

This separation enables third-party linking: a link can be stored in document A while connecting content in documents B and C. The home document is the link's container, not its subject.

**Why it matters for spec:** Frame condition for delete operations: `∀ link, D_home :: delete_text(D_home) ⟹ link.source_unchanged ∧ link.target_unchanged ∧ link.type_unchanged` when the deletion targets D_home's text subspace (1.x) rather than its link subspace (0.2.x). This is a consequence of subspace isolation — operations on text spans cannot affect link spans.

**Concrete example:**
```
Before: Link in doc_A, source in doc_B, target in doc_C
  follow_link(link, SOURCE) → content in doc_B
  follow_link(link, TARGET) → content in doc_C

After deleting ALL text from doc_A:
  follow_link(link, SOURCE) → same content in doc_B  (unchanged)
  follow_link(link, TARGET) → same content in doc_C  (unchanged)
  find_links(doc_B content) → still finds the link   (unchanged)
```

**Code references:** Test `link_home_document_content_deleted` (PASS).

**Provenance:** Finding 0024, Semantic Insight 3.

### EC-ORPHANED-LINK

**What happens:** Finding 0024 provides a comprehensive behavior matrix for orphaned links across all deletion combinations. The key addition beyond Finding 0005 is the full matrix and the anomalous type-endset behavior:

| Deleted Content         | `find_links` | source | target | type   |
|------------------------|-------------|--------|--------|--------|
| Nothing                | Works       | Works  | Works  | Works  |
| Source text only        | Empty       | Empty  | Works  | Works  |
| Target text only        | Works       | Works  | Empty  | Works  |
| Both source & target    | Empty       | Empty  | Empty  | Empty* |
| Home doc text only      | Works       | Works  | Works  | Works  |

The critical asymmetry: `find_links(source_specs)` requires content at the source address to succeed, while `follow_link(link_id)` always works if you know the link ID. Link IDs function as permanent capability tokens — knowing one grants access to the link even when content-based discovery fails.

**Why it matters for spec:** Extends EC-ORPHANED-LINK from Finding 0005 with two new properties:

1. `find_links` discoverability depends on which endpoint is queried: deleting source makes source-based discovery fail but target-based still works, and vice versa. Formally: `source_deleted(link) ⟹ find_links(source_specs) ∌ link ∧ find_links(NOSPECS, target_specs) ∋ link` (when target content survives).

2. The type endset anomaly when both endpoints are deleted (marked * above) — `follow_link(link_id, LINK_TYPE)` returns empty even though the type references the bootstrap document, which was not deleted. This is either a bug or an undocumented dependency of type resolution on endpoint resolution.

**Concrete example:**
```
Link: source in doc_B ("source text"), target in doc_C ("target text"), type = QUOTE

After deleting source text from doc_B:
  find_links(doc_B content)    → [] (empty - source content gone)
  follow_link(link, SOURCE)    → [] (empty span)
  follow_link(link, TARGET)    → "target text" (works)
  follow_link(link, TYPE)      → QUOTE type (works)

After ALSO deleting target text from doc_C:
  follow_link(link, SOURCE)    → [] (empty)
  follow_link(link, TARGET)    → [] (empty)
  follow_link(link, TYPE)      → [] (empty — UNEXPECTED)
```

**Code references:** Tests `orphaned_link_source_all_deleted`, `orphaned_link_target_all_deleted`, `orphaned_link_both_endpoints_deleted`, `orphaned_link_discovery_by_link_id` (all PASS).

**Provenance:** Finding 0024, Orphaned Link Behavior Matrix and Semantic Insight 4.

### ST-DELETE

**What happens:** Finding 0024 confirms and extends the delete postcondition: deletion removes content from the V-stream but preserves link objects in the 0.2.x subspace. After deleting all text from a document that contains links, the links remain accessible. The document's vspanset still shows link spans even when all text spans are gone.

This is consistent with Finding 0023's characterization of delete as V-stream-only, and adds the link dimension: delete affects neither I-address associations (Finding 0023) nor link objects stored in the document (Finding 0024).

**Why it matters for spec:** Extends the ST-DELETE postcondition: `delete(D, span) ⟹ link_spans(D)_after = link_spans(D)_before`. Delete operates exclusively on the text subspace (1.x); the link subspace (0.2.x) is a frame condition for delete.

**Provenance:** Finding 0024, Semantic Insight 2 and Technical Discovery 2.
