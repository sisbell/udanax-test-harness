# Finding 0060 Analysis

## Entries

### SS-ENFILADE-TREE

**What happens:** The three enfilade types use different branching factor constants at height-1 (bottom crum capacity), determined by the `toomanysons` function:

| Enfilade type | `is2dcrum` | Height-1 max (`M_b`) | Height > 1 max (`M_u`) |
|---------------|------------|----------------------|------------------------|
| GRAN (granfilade) | FALSE | `MAXBCINLOAF = 1` | `MAXUCINLOAF = 6` |
| POOM | TRUE | `MAX2DBCINLOAF = 4` | `MAXUCINLOAF = 6` |
| SPAN | TRUE | `MAX2DBCINLOAF = 4` | `MAXUCINLOAF = 6` |

The `toomanysons` check dispatches on `height > 1` (uses M_u) vs `height == 1` (uses M_b, with 1D vs 2D distinguished by `is2dcrum`). All enfilade types share the same `splitcrumupwards`, `splitcrumseq`, and `levelpush` code paths — the difference is purely in these constants.

Because `MAXBCINLOAF = 1`, the granfilade triggers `toomanysons` as soon as any height-1 node holds 2 bottom crums. The POOM does not trigger until a height-1 node exceeds 4 children.

**Why it matters for spec:** The state structure for enfilades must parameterize the branching factor by both height level and enfilade type. A single `M` parameter is insufficient; the model needs `M_b(enftype)` and `M_u` as separate constants. The `toomanysons` predicate is: `node.numberofsons > (node.height > 1 ? M_u : M_b(enftype))`.

**Code references:**
- `backend/enf.h:26-28` — constant definitions: `MAXUCINLOAF 6`, `MAXBCINLOAF 1`, `MAX2DBCINLOAF 4`
- `backend/genf.c:239-245` — `toomanysons`: dispatches on height and `is2dcrum`
- `backend/genf.c:19-22` — `is2dcrum`: returns `cenftype != GRAN`

**Concrete example:**
```
Granfilade, height-1 node with 2 bottom crums:
  toomanysons → 2 > MAXBCINLOAF(1) → TRUE → split triggered

POOM, height-1 node with 2 bottom crums:
  toomanysons → 2 > MAX2DBCINLOAF(4) → FALSE → no split

POOM, height-2 node with 4 upper crums:
  toomanysons → 4 > MAXUCINLOAF(6) → FALSE → no split
```

**Provenance:** Finding 0060

### INV-ENFILADE-MINIMALITY

**What happens:** The EN-4 invariant (non-root internal nodes must have `2 ≤ #children ≤ M`) is violated for height-1 non-root nodes in the granfilade. Because `M_b = 1`, the constraint `2 ≤ #children ≤ 1` is unsatisfiable. After `levelpush` + `splitcrumseq`, height-1 non-root nodes have exactly 1 child each — they are created this way and remain this way. No mechanism corrects this: `levelpull` is disabled (returns 0 immediately).

The actual invariant for the granfilade differs by node position:
- **Root (fullcrum):** `1 ≤ #children` (no upper bound enforced at root)
- **Height > 1 non-root:** `⌈M_u/2⌉ ≤ #children ≤ M_u` (standard B-tree, M_u = 6)
- **Height == 1 non-root:** `#children = 1` (always exactly one bottom crum)

The POOM and SPAN enfilades do NOT exhibit this violation because `M_b = 4` permits 2-4 children at height-1, satisfying EN-4.

**Why it matters for spec:** The formal EN-4 constraint must be conditioned on enfilade type. For GRAN enfilades, height-1 non-root nodes are exempt from the lower bound. The spec invariant should be:
```
∀ node ∈ internal_nodes(enf) :
  ¬is_root(node) ⟹
    if enf.type = GRAN ∧ node.height = 1 then
      node.#children = 1
    else
      2 ≤ node.#children ≤ M(node.height, enf.type)
```
Any Alloy bounded-model check or Dafny verification asserting a uniform `2 ≤ #children` for all non-root internal nodes will produce spurious counterexamples for the granfilade.

**Code references:**
- `backend/split.c:16-44` — `splitcrumupwards`: checks `isfullcrum`, calls `levelpush` then `splitcrum`
- `backend/split.c:70-93` — `splitcrumseq`: creates sibling, moves `numberofsons/2` children
- `backend/genf.c:263-294` — `levelpush`: increments fullcrum height, creates single-child intermediate
- `backend/genf.c:318-342` — `levelpull`: disabled, returns 0

**Concrete example:**
```
Before: insert 2nd bottom crum into granfilade
  Fullcrum (height=1, numberofsons=2)
    ├─ Bottom crum A (height=0)
    └─ Bottom crum B (height=0)

  toomanysons(fullcrum) → 2 > 1 → TRUE
  isfullcrum → TRUE → levelpush + splitcrum

After levelpush:
  Fullcrum (height=2, numberofsons=1)
    └─ Node1 (height=1, numberofsons=2)
         ├─ Bottom crum A
         └─ Bottom crum B

After splitcrum(Node1):
  Fullcrum (height=2, numberofsons=2)
    ├─ Node1 (height=1, numberofsons=1)   ← non-root, 1 child (violates strict EN-4)
    │    └─ Bottom crum A
    └─ Node2 (height=1, numberofsons=1)   ← non-root, 1 child (violates strict EN-4)
         └─ Bottom crum B
```

**Provenance:** Finding 0060

### ST-INSERT

**What happens:** When `insertseq` adds a new bottom crum to a granfilade, the new crum is adopted as a right sibling of the existing bottom crum at height-0. Then `splitcrumupwards(father)` checks whether the father (height-1) has too many children. Because `MAXBCINLOAF = 1`, any height-1 node with 2+ children triggers a split. If the father is the fullcrum, `levelpush` first increases the tree height, then `splitcrum` splits the demoted former root. If the father is not the fullcrum, `splitcrum` creates a sibling and the split may propagate upwards.

The granfilade grows taller with each insert of a new bottom crum when the target height-1 node is the fullcrum — the tree effectively adds a new level for every second bottom crum at the root level. Subsequent inserts into non-root height-1 nodes split horizontally (creating sibling height-1 nodes), increasing the parent's child count instead of increasing tree height.

**Why it matters for spec:** The ST-INSERT postcondition for granfilades must account for tree height growth. After inserting into a height-1 fullcrum that already has 1 child: `enf.height_after = enf.height_before + 1`. For inserts into non-root height-1 nodes: height unchanged, parent gains one additional child. The formal model of insert must compose the content-level change (new V-address mapped) with the structural change (tree may grow taller).

**Code references:**
- `backend/insert.c:44-48` — `insertseq`: creates height-0 crum, adopts as right sibling, calls `splitcrumupwards`
- `backend/split.c:16-44` — `splitcrumupwards`: levelpush at fullcrum, splitcrum at non-root
- `backend/split.c:70-93` — `splitcrumseq`: halves children between original and new sibling

**Concrete example:**
```
Insert 3rd bottom crum into granfilade (tree already at height=2):
  Fullcrum (height=2, numberofsons=2)
    ├─ Node1 (height=1, numberofsons=1)
    │    └─ Bottom crum A
    └─ Node2 (height=1, numberofsons=1)
         └─ Bottom crum B

New bottom crum C adopted as sibling of B under Node2:
  Node2 (height=1, numberofsons=2)  ← toomanysons → TRUE

splitcrum(Node2) → not fullcrum, split into siblings:
  Fullcrum (height=2, numberofsons=3)
    ├─ Node1 (height=1, numberofsons=1) → Bottom A
    ├─ Node2 (height=1, numberofsons=1) → Bottom B
    └─ Node3 (height=1, numberofsons=1) → Bottom C

Fullcrum: toomanysons → 3 > 6? No. Loop exits. Height unchanged.
```

**Provenance:** Finding 0060

### EC-GRAN-MB-ONE

**What happens:** The granfilade's `MAXBCINLOAF = 1` creates a degenerate B-tree structure where every height-1 non-root node holds exactly one bottom crum. This means the height-1 layer adds no fan-out — it is effectively a pass-through that maps each height-2 child pointer to exactly one bottom crum. The tree is taller than necessary: a granfilade with N bottom crums needs height `⌈log₆(N)⌉ + 1` (the extra +1 for the pass-through height-1 layer) rather than the `⌈log₆(N)⌉` that a uniform M=6 tree would require.

The code comment `/* so text will fit *//* as you wish */` on the `MAXBCINLOAF` definition suggests this is a deliberate trade-off: bottom crums can hold up to `GRANTEXTLENGTH = 950` bytes of text, and limiting each height-1 node to one bottom crum simplifies loaf management at the cost of tree depth.

The POOM and SPAN enfilades avoid this degenerate case because `MAX2DBCINLOAF = 4` permits useful fan-out at height-1.

**Why it matters for spec:** Models should treat the height-1 layer of a GRAN enfilade as a trivial 1:1 mapping layer, not a branching layer. Complexity and lookup cost analysis must account for this extra level. The choice is architecturally significant: it means the granfilade is always at least 1 level taller than a comparable POOM for the same number of leaf entries.

**Code references:**
- `backend/enf.h:27` — `#define MAXBCINLOAF 1  /* so text will fit *//* as you wish */`
- `backend/enf.h:26` — `#define MAXUCINLOAF 6`
- `backend/enf.h:28` — `#define MAX2DBCINLOAF 4`

**Provenance:** Finding 0060
