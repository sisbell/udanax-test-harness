# Finding 0004 Analysis

## Entries

### SS-LINK-ENDPOINT

**What happens:** Link endpoints in udanax-green are stored by content identity, not by document position. A link's endpoint references the same content identity system used by transclusion (vcopy). This means a link endpoint is structurally equivalent to a content identity reference — it names immutable content, not a mutable document offset.

**Why it matters for spec:** The formal spec needs: `LinkEndpoint = ContentId` (or a reference to content identity), NOT `LinkEndpoint = (doc: DocId, offset: Nat)`. This aligns the link model with the content identity model from SS-CONTENT-IDENTITY. The link state structure is: `Link = (source: set<ContentId>, target: set<ContentId>, type: Tumbler)`. Link resolution is a lookup in the content-identity-to-document mapping, not a fixed document-position dereference.

**Code references:** Tests `link_survives_source_insert`, `link_survives_source_delete_adjacent`, `link_with_vcopy_source`, `link_survives_target_modify`

**Provenance:** Finding 0004

### INV-LINK-CONTENT-TRACKING

**What happens:** Links track content identity across all document modifications. Insertions before a linked span, deletions of adjacent text, and modifications to target documents all leave links valid and findable. This holds universally — all seven survivability tests pass. The invariant is: once a link is created referencing content identities, it remains valid as long as those content identities exist in the system (in any document).

**Why it matters for spec:** This is a global invariant: `forall link : Link, op : Operation :: content_ids(link.source) ⊆ all_content_ids(system) ==> findable(link)`. Link validity depends on content existence, not document structure. Since INV-CONTENT-IMMUTABILITY guarantees content identities are never destroyed while referenced, and links reference content identities, links are inherently persistent. The formal spec should derive link persistence from content immutability rather than stating it as an independent axiom.

**Concrete example:**
- Before: Document A has "Click [here] for details", link on "here" (content identity C₁)
- After insert at beginning of A: A becomes "PREFIX Click [here] for details"
- Link on "here" still valid — it references C₁, which still exists at a shifted position
- After delete of "Click ": A becomes "PREFIX [here] for details"
- Link still valid — C₁ still in A's reference set

**Code references:** Tests `link_survives_source_insert` (PASS), `link_survives_source_delete_adjacent` (PASS), `link_survives_target_modify` (PASS)

**Provenance:** Finding 0004

### ST-REMOVE

**What happens:** When the linked span itself is deleted from a document, the link continues to exist but points to empty content. When a partial deletion removes part of a linked span, the link points to the remainder. This extends the ST-REMOVE postcondition: removal of content from a document removes that document's reference but does not invalidate links — the link's endpoint adjusts to reflect whatever content identities remain reachable.

**Why it matters for spec:** The postcondition for remove, with respect to links, is: `link.source = link.source_before ∩ all_referenced_content(system_after)`. If all content identities in a link's source endpoint are removed from every document, the link exists but its source resolves to empty. If only some are removed, the link resolves to the remaining subset. The link itself is never destroyed by remove — only its effective resolution changes.

**Concrete example:**
- Link on "here" (content identities C₁C₂C₃C₄) in document A
- Delete entire "here": link exists, source resolves to empty (no document references C₁-C₄)
- Delete "he" only: link exists, source resolves to "re" (C₃C₄ still referenced by A)

**Code references:** Tests `link_when_source_span_deleted` (PASS), `link_source_partial_delete` (PASS), `link_when_target_span_deleted` (PASS)

**Provenance:** Finding 0004

### INT-LINK-TRANSCLUSION

**What happens:** When content with a link is transcluded (vcopy'd) to another document, the link can be found from the copy. Calling `find_links` with a search specifying the target document returns the original link. This is because the vcopy shares the content identities, and the link is indexed by content identity — so any document referencing those identities can discover the link.

**Why it matters for spec:** This defines a key interaction between the link and transclusion subsystems: `forall link, doc_source, doc_target :: vcopy(content_ids(link.source), doc_source, doc_target) ==> findable(link, doc_target)`. Link discovery is a function of content identity presence, not document membership at link creation time. The formal spec should define `find_links(specset)` as: return all links whose source or target content identities intersect with the content identities referenced by the specset. This makes link discovery emergent from content identity sharing.

**Concrete example:**
- Document A: "Click [here] for details" — link on "here" (content identity C₁)
- Document C: vcopy "here" from A → C references C₁
- `find_links(search in C)` → returns the original link from A
- Both A and C can discover the link because both reference C₁

**Code references:** Test `link_with_vcopy_source` (PASS)

**Provenance:** Finding 0004

### FC-LINK-PERSISTENCE

**What happens:** Document modifications (insert, delete, vcopy) never destroy links. Links are not stored within documents — they exist in a separate link subsystem (the link enfilade / orgl) indexed by content identity. Therefore, no document-level operation can remove or corrupt a link. The only change a document operation can make to a link's effective behavior is to alter which documents reference the link's endpoint content identities.

**Why it matters for spec:** This is a frame condition on all document operations: `forall op in {insert, remove, vcopy}, link : Link :: links(system_after_op) ⊇ links(system_before_op)`. The set of links is monotonically growing — links are created but never destroyed by document operations. Combined with INV-CONTENT-IMMUTABILITY, this means the link set is a permanent, append-only structure. The formal spec should assert that document operations have no write access to the link store except through explicit link creation.

**Code references:** All seven `link_survives_*` and `link_when_*` tests (all PASS)

**Provenance:** Finding 0004
