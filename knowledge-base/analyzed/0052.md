# Finding 0052 Analysis

## Entries

### ST-CREATE-LINK

**What happens:** CREATELINK uses the same insertion code path as INSERT and COPY: `docreatelink` → `docopy` → `insertpm` → `insertnd` → `makegappm`. The `makegappm` function shifts existing POOM entries at or beyond the insertion point by adding the insertion width to their V-dimension displacement (case 1 / "THRUME" in `insertnd`). This means CREATELINK has shifting semantics identical to INSERT for any POOM entries beyond the insertion point.

However, this shifting is not observable in practice because `findnextlinkvsa` always places the new link orgl at the current document end (`vspanreach`) or at `2.1` if no links exist yet. Since no POOM entries exist beyond the document end, there is nothing to shift. The "no shifting" behavior of CREATELINK is an emergent property of append-at-end placement, not a fundamental property of the operation.

**Why it matters for spec:** The postcondition for `create_link` must technically include the same shifting semantics as `insert`: `forall v in POOM : v >= insertion_point ==> v' = v + width`. However, the precondition established by `findnextlinkvsa` guarantees `insertion_point = max(2.1, vspanreach)`, which means `{v in POOM : v >= insertion_point} = {}`. The spec can model CREATELINK as append-only for sequential operation, but the underlying mechanism permits shifting if the insertion point were placed before existing entries.

**Code references:**
- `backend/do1.c:199-225` — `docreatelink` calls `docopy` at line 216
- `backend/do1.c:45-65` — `docopy` calls `insertpm` at line 60
- `backend/insertnd.c:15-94` — `insertnd` dispatches to `makegappm` for POOM case at line 54
- `backend/insertnd.c:124-172` — `makegappm` shifts entries via `tumbleradd` at line 162
- `backend/do2.c:151-167` — `findnextlinkvsa` computes append-at-end position

**Concrete example:**
```
Pre-state: Document with text at V 1.1..1.24, link1 orgl at V 2.1
  POOM contains entry for link1 at V-displacement 2.1

Operation: create_link (second link)
  findnextlinkvsa computes insertion point = vspanreach (beyond 2.1)
  makegappm scans POOM entries: link1 at 2.1 is BEFORE insertion point (case 0/2)
  No entries are shifted

Post-state: link2 orgl appended at end, link1 V-position unchanged
  POOM: link1 at 2.1 (unchanged), link2 at 2.2

Hypothetical: If insertion point were forced to 2.1 (before link1):
  makegappm would classify link1 as case 1 (THRUME)
  link1's V-displacement would be shifted: 2.1 + width → higher position
```

**Provenance:** Finding 0052

### ST-INSERT

**What happens:** INSERT, COPY, and CREATELINK all share the same POOM insertion mechanism: `insertpm` → `insertnd` → `makegappm`. The `makegappm` function classifies existing POOM crums relative to the insertion point using `insertcutsectionnd`: case 0/2 (before or at boundary) are left unchanged, case 1 (THRUME — beyond insertion point) are shifted by adding the insertion width to their V-dimension displacement. This is the same shifting behavior documented in Finding 0027 for INSERT, now confirmed to be shared across all three operations.

**Why it matters for spec:** The shift postcondition `forall v >= P: v' = v + width` is a property of `insertpm`, not of any individual operation. The spec should define a shared `poom_insert(poom, position, width)` primitive with this postcondition, then define INSERT, COPY, and CREATELINK as calling this primitive with different position-selection strategies. INSERT and COPY use user-specified positions; CREATELINK uses `findnextlinkvsa` which always selects the document end.

**Code references:**
- `backend/insertnd.c:54` — `makegappm` called for POOM case in `insertnd`
- `backend/insertnd.c:162` — `tumbleradd(&ptr->cdsp.dsas[V], &width->dsas[V], &ptr->cdsp.dsas[V])` performs the shift

**Provenance:** Finding 0052

### SS-LINK-SUBSPACE

**What happens:** Link orgl references occupy a separate subspace in the document's V-stream. The first link is placed at V-position `2.1`, computed by `findnextlinkvsa` which initializes `firstlink` by incrementing tumbler coordinates: first to `2.0`, then to `2.1`. Subsequent links are placed at `vspanreach` (the current end of the document extent). This `2.x` subspace is distinct from the text content subspace (`1.x`), and link positions grow monotonically for sequential creation.

**Why it matters for spec:** The V-address space has at least two subspaces: text content at `1.x` and link orgls at `2.x`. The state structure should model: `Document.vstream = TextSubspace(1.x) ∪ LinkSubspace(2.x)`. The link subspace starts at `2.1` and grows by append. The `retrieve_vspanset` operation returns spans covering each subspace separately.

**Code references:**
- `backend/do2.c:151-167` — `findnextlinkvsa` initializes to `2.1` and uses `vspanreach` for subsequent links

**Provenance:** Finding 0052

### EC-CONCURRENT-LINK-CREATION

**What happens:** Because CREATELINK uses `insertpm` with full shifting semantics, concurrent link creation (two operations interleaving) could cause observable shifting. If operation A calls `findnextlinkvsa` to get position P, then operation B inserts a link before P, then A inserts at P — B's link would be shifted by A's insertion. The V-positions of link orgls are NOT stable under concurrent modification, even though they are stable under sequential modification.

**Why it matters for spec:** Link orgl V-positions in the POOM are not permanent identifiers. The spec should note that `link_vposition` is a mutable property subject to shifting by any `insertpm` call, not an invariant. For sequential single-user operation this is invisible (append-at-end), but any formal model of concurrent access must account for it. This is analogous to the concurrent insert concern in Finding 0041.

**Code references:**
- `backend/do2.c:151-167` — `findnextlinkvsa` reads current extent (not atomic with insertion)
- `backend/insertnd.c:162` — shifting applies to link orgl entries the same as text entries

**Provenance:** Finding 0052
