# Finding 0028 Analysis

## Entries

### SS-ADDRESS-SPACE
**What happens**: V-positions are inter-character cursors (gaps between characters), not character indices. Insert at position P means "insert before the character currently at position P." Multiple inserts at the same position produce LIFO ordering: the most recently inserted content appears first.

**Why it matters for spec**: Confirms the cursor-gap model from Finding 0027. No new structural facts, but the edge-case test suite validates this model under repeated same-position insertion.

**Code references**: Test `edgecases/multiple_inserts_same_position`

**Provenance**: Finding 0028 §1

### EC-SELF-TRANSCLUSION
**What happens**: A document can transclude content from itself. Given document containing "Original", vcopy of "Orig" (positions 1–4) to the end produces "OriginalOrig". The transcluded portion shares I-position identity with the original content within the same document.

**Why it matters for spec**: The precondition for vcopy must NOT include `source_doc != target_doc`. Self-transclusion is a valid operation. The postcondition must handle the case where source and destination V-ranges are in the same document: `vcopy(doc, src_span, doc, target_pos)` is valid and the resulting content at target_pos shares I-positions with content at src_span. This enables recursive document structures where the same content identity appears at multiple V-positions within one document.

**Code references**: Test `edgecases/self_transclusion`

**Concrete example**:
```
Pre-state:  doc V-stream = "Original" (positions 1.1..1.8)
Operation:  vcopy(doc, Span(1.1, 0.4), doc, end)  — copy "Orig" to end
Post-state: doc V-stream = "OriginalOrig" (positions 1.1..1.12)
  I-positions of "Orig" at 1.9..1.12 == I-positions of "Orig" at 1.1..1.4
```

**Provenance**: Finding 0028 §2

### INV-IDENTITY-OVERLAP
**What happens**: When transcluding overlapping regions from the same source, the overlapping characters in the destination share I-position identity with the corresponding source characters. Both copies of shared characters reference the same I-position, even though they appear at different V-positions.

**Why it matters for spec**: The identity-preservation invariant holds at character granularity even when transclusion regions overlap. Formally: if `vcopy(src, Span(a, len1), dst, P1)` and `vcopy(src, Span(b, len2), dst, P2)` where `[a, a+len1) ∩ [b, b+len2) ≠ ∅`, then for every position `c` in the overlap, `I(dst, P1 + (c-a)) == I(dst, P2 + (c-b)) == I(src, c)`. The enfilade correctly tracks that multiple V-positions can map to the same I-position.

**Code references**: Test `edgecases/overlapping_transclusions`

**Concrete example**:
```
Source doc: "ABCDEFGH"
Operation 1: vcopy(src, Span(1.1, 0.4), dst, end)  — copy "ABCD"
  dst = "ABCD"
Operation 2: vcopy(src, Span(1.3, 0.4), dst, end)  — copy "CDEF"
  dst = "ABCDCDEF"

Identity mapping:
  dst positions 1.3, 1.4 ("CD" from first copy) share I-positions with
  dst positions 1.5, 1.6 ("CD" from second copy) — both map to
  src positions 1.3, 1.4 ("CD" in source)
```

**Provenance**: Finding 0028 §3

### INV-SINGLE-CHAR-GRANULARITY
**What happens**: All core operations work at single-character granularity with no special cases. Specifically: insert of one character succeeds; delete of one character (at first, middle, or last position) succeeds; vcopy of one character succeeds and maintains I-position identity; pivot of two single characters succeeds (swaps their positions). There is no minimum span width greater than one character for any operation.

**Why it matters for spec**: Operation preconditions need no minimum-length constraint beyond `length >= 1` (or `length >= 0` for queries — see below). The spec should define operations over arbitrary non-empty spans without special-casing single-character inputs. This confirms that the enfilade and all orgl operations handle the degenerate single-character case correctly.

**Code references**: Tests `edgecases/single_character_insert`, `edgecases/single_character_delete`, `edgecases/single_character_vcopy`, `edgecases/single_character_pivot`

**Provenance**: Finding 0028 §4

### PRE-ZERO-WIDTH
**What happens**: Zero-width (empty) spans have different validity depending on whether the operation is a query or a mutation:
- **Queries accept zero-width**: `retrieve_contents(Span(1.1, 0.0))` returns an empty list (success). `retrieve_contents(SpecSet())` returns an empty list (success).
- **Mutations reject zero-width**: `create_link` with zero-width endpoints crashes the backend (Bug 0017).

**Why it matters for spec**: The precondition for query operations (retrieve) permits zero-width spans: `span.width >= 0`. The precondition for mutation operations (at minimum link creation) requires non-zero width: `span.width > 0`. This is a query/mutation asymmetry in the validity domain. The spec should partition operations into these two classes and define appropriate width preconditions for each. Note: the crash behavior (rather than error return) for zero-width link creation indicates a missing precondition check in the implementation, not intended semantics.

**Code references**: Tests `edgecases/empty_span_retrieval`, `edgecases/zero_width_link`; Bug 0017

**Concrete example**:
```
Query (succeeds):
  retrieve_contents(Span(1.1, 0.0)) → [] (empty result, no error)

Mutation (crashes):
  create_link(home, source=Span(1.1, 0.0), target=Span(1.5, 0.0), type=T) → CRASH
```

**Provenance**: Finding 0028 §5

### INV-VSPAN-CONSOLIDATION
**What happens**: The enfilade consolidates logically contiguous V-space regions into a single span regardless of insertion history. After 100 separate single-character inserts (A, B, C, ...), `retrieve_vspanset` returns `span_count: 1` — a single contiguous span covering all content. Fragmented inserts do not produce fragmented span representations.

**Why it matters for spec**: An invariant of the enfilade data structure: `forall doc : Document :: contiguous_vrange(doc) => vspanset(doc).size == 1`. More generally, the span representation returned by `retrieve_vspanset` is always maximally consolidated — adjacent spans with consecutive V-positions are merged. This is a representation invariant, not a behavioral one: the logical content is the same either way, but the enfilade guarantees minimal span decomposition. For formal verification, this means span-count assertions can be used as oracles for contiguity.

**Code references**: Test `edgecases/many_single_inserts`

**Concrete example**:
```
100 sequential inserts: insert("A"), insert("B"), ..., insert("Z"), insert("A"), ...
retrieve_vspanset(doc) → {Span(1.1, 0.100)}  — single span, not 100 fragments
```

**Provenance**: Finding 0028 §6

### EC-SELF-COMPARISON
**What happens**: Comparing a document with itself via `compare_versions` returns the entire document content as shared. The result is a pair of identical spans, each covering the full document.

**Why it matters for spec**: `compare_versions` is reflexive: `compare_versions(doc, doc) == [(full_span(doc), full_span(doc))]`. Every character's I-position is trivially shared with itself. This is a boundary condition that any formal model of `compare_versions` must satisfy — the identity comparison. It follows directly from the definition (shared content = content with matching I-positions) but serves as a useful sanity predicate: `forall doc :: compare_versions(doc, doc) != []` whenever `doc` is non-empty.

**Code references**: Test `edgecases/self_comparison`

**Concrete example**:
```
doc contains "Hello, World!!!" (17 chars)
compare_versions(doc, doc) → [(Span(1.1, 0.17), Span(1.1, 0.17))]
  Both spans are identical — every character shares identity with itself
```

**Provenance**: Finding 0028 §7

### FC-DOC-ISOLATION
**What happens**: Documents created independently (not via version or vcopy) share no content identity, even if they contain identical text. `compare_versions` between two independently-created documents with different text returns an empty list. The I-positions assigned to typed content are unique per insertion event.

**Why it matters for spec**: Reinforces the identity-by-origin invariant: `forall doc1, doc2 : Document :: independent(doc1, doc2) => compare_versions(doc1, doc2) == []`. "Independent" means no version or transclusion relationship exists between them. Even character-for-character identical text produces distinct I-positions when typed independently. This is a frame condition on document creation: `create_document` produces a document with I-positions disjoint from all existing I-positions.

**Code references**: Test `edgecases/disjoint_documents_comparison`

**Concrete example**:
```
doc1 = create_document(); insert(doc1, "First content")
doc2 = create_document(); insert(doc2, "Second content")
compare_versions(doc1, doc2) → []  — no shared identity despite both being text
```

**Provenance**: Finding 0028 §8

### PRE-LINK-CREATE
**What happens**: Links with single-character (width=1) endpoints are valid and succeed. Links with zero-width endpoints crash (Bug 0017). The minimum valid endpoint width for link creation is 1.

**Why it matters for spec**: Refines the link creation precondition: `link.source.width >= 1 AND link.target.width >= 1`. There is no minimum width greater than 1. Combined with Finding 0020 (no cross-document constraint), the full structural precondition for `create_link` is: source content exists AND target content exists AND both endpoint widths >= 1 AND home_doc is valid.

**Code references**: Tests `edgecases/minimum_width_link`, `edgecases/zero_width_link`; Bug 0017

**Concrete example**:
```
Valid (width=1):
  create_link(home, source=Span(1.1, 0.1), target=Span(1.12, 0.1), type=T) → success

Invalid (width=0):
  create_link(home, source=Span(1.1, 0.0), target=Span(1.12, 0.0), type=T) → CRASH
```

**Provenance**: Finding 0028 §10

### SS-LINK-ENDPOINT
**What happens**: Link endpoints are immutable V-spans fixed at creation time. A link records its source and target as specific V-spans in specific documents (e.g., source = Document A at V 1.4 for 0.3, target = Document B at V 1.1 for 0.6). These endpoint references never change after link creation. However, link *discovery* operates on I-addresses, not V-addresses — a link is discoverable from any document whose content shares I-address overlap with the link's endpoint content.

**Why it matters for spec**: The link data structure stores fixed V-span endpoints, but the discovery mechanism uses I-addresses derived from those endpoints. This means: `Link = { source: VSpan, target: VSpan, type: Tumbler }` where VSpan = `(doc: DocId, pos: Tumbler, width: Tumbler)`. The `find_links` operation does NOT compare V-spans — it converts the search specset to I-addresses and checks for I-address intersection with the link's endpoint I-addresses. This is why links "follow" content through transclusion without being modified: the I-addresses of the endpoint content are shared by all documents that transclude that content.

**Code references**: Test `partial_vcopy_of_linked_span` — link created with source "hyperlink text", discovered via partial transclusion of "link" (4 chars from the 14-char source)

**Concrete example**:
```
Link created:
  Source: Document A, V-span 1.4 for 0.3 ("DEF"), I-addresses I.4, I.5, I.6
  Target: Document B, V-span 1.1 for 0.6 ("Target")

After link creation, these V-span endpoints are permanently fixed.
follow_link(link_id, SOURCE) always returns the original VSpan referencing A at 1.4 for 0.3.
```

**Provenance**: Finding 0028b §1, §3

### ST-FIND-LINKS
**What happens**: `find_links(search_specset)` discovers links by I-address intersection, not by document or V-address matching. The search specset is converted to I-addresses, and links are returned if any I-address in the search overlaps with I-addresses in a link endpoint. Partial overlap suffices — a search specset that shares even one I-address with a link endpoint will discover that link. The search is purely set-intersection on I-addresses: `find_links(S) = { L | I-addresses(S) ∩ I-addresses(L.source) ≠ ∅ }`.

**Why it matters for spec**: The postcondition for `find_links` is: return the set of all links whose source endpoint I-addresses have non-empty intersection with the search specset's I-addresses. Document identity plays no role — a document that was not involved in link creation can discover the link if it shares content identity (via transclusion) with an endpoint. This is the formal mechanism by which transclusion enables link discovery.

**Code references**: Test `partial_vcopy_of_linked_span` — `find_links` on a document containing only "link" (4 chars transcluded from "hyperlink text") discovers the link created on "hyperlink text"

**Concrete example**:
```
Document A: "ABCDEFGHIJ" (I-addresses I.1 through I.10)
Link source: "DEF" (I-addresses I.4, I.5, I.6)

Document C transcludes "EF" from A via vcopy:
  C contains: "Copy: EF"
  C's "EF" has I-addresses I.5, I.6 (shared with A)

find_links(specset covering C's "EF"):
  I-addresses of search: {I.5, I.6}
  I-addresses of link source: {I.4, I.5, I.6}
  Intersection: {I.5, I.6} ≠ ∅
  → Link returned (partial overlap is sufficient)
```

**Provenance**: Finding 0028b §2

### ST-FOLLOW-LINK
**What happens**: `follow_link(link_id, endpoint)` returns the complete, original SpecSet for the requested endpoint, regardless of how the link was discovered. Even when a link is found via partial I-address overlap from a transclusion, `follow_link` returns the full endpoint as it was specified at link creation time. The link is an immutable entity that does not adapt to the discovery context.

**Why it matters for spec**: The postcondition for `follow_link` is: `follow_link(L, SOURCE) == L.source_specset` and `follow_link(L, TARGET) == L.target_specset`, where these specsets are the exact values provided at `create_link` time. There is no filtering, subsetting, or adaptation based on the caller's document or the search that discovered the link. This is a direct consequence of link immutability (SS-LINK-ENDPOINT).

**Code references**: Test `partial_vcopy_of_linked_span` — document contains "link" (4 chars), `follow_link` returns "hyperlink text" (14 chars, the full original source)

**Concrete example**:
```
Link L created with source = "hyperlink text" (14 chars) in Document A
Document C transcludes "link" (4 chars) from A

find_links(C) → {L}  (discovered via partial I-address overlap)
follow_link(L, SOURCE) → SpecSet referencing A at original position for 14 chars
retrieve_contents(follow_link result) → "hyperlink text"  (NOT "link")

The link returns its full source, not the subset that enabled discovery.
```

**Provenance**: Finding 0028b §3

### INT-LINK-TRANSCLUSION
**What happens**: Transclusion (vcopy) creates shared content identity between documents. It does NOT copy links, create new links, or modify existing links. The only link-relevant effect of transclusion is sharing I-addresses, which enables link discovery from the destination document. The link itself is unmodified — only its discoverability expands to include any document sharing its endpoint's I-addresses.

**Why it matters for spec**: The frame condition for vcopy with respect to links is: `links(system_after_vcopy) == links(system_before_vcopy)`. No links are created, modified, or destroyed by vcopy. The interaction property is: `vcopy(content, src_doc, dst_doc) => (forall L :: I-addresses(L.source) ∩ I-addresses(content) ≠ ∅ => findable(L, dst_doc))`. This is emergent behavior: vcopy's postcondition (sharing I-addresses) combined with find_links' I-address-based search yields link discoverability without any link-specific logic in vcopy.

**Code references**: Test `partial_vcopy_of_linked_span` — vcopy of "link" from linked "hyperlink text", then `find_links` on copy finds the link

**Concrete example**:
```
Pre-state:
  Document A: "hyperlink text" with link L on this content
  Document C: empty

vcopy("link" from A to C):
  Post-state:
    Document C: "link" (I-addresses shared with A's "link" substring)
    Link L: UNCHANGED (same source endpoint, same target endpoint)
    find_links(C) → {L}  (new — C can now discover L)
    find_links(A) → {L}  (unchanged — A still discovers L)

What vcopy did NOT do:
  - Did not create a new link in C
  - Did not copy L to C
  - Did not modify L's endpoints
```

**Provenance**: Finding 0028b §4

### SS-LINK-SPACE
**What happens**: Links are stored in a separate address space (the span-f enfilade / link space) distinct from document content. A link does not "belong to" any single document. It is an independent entity that references documents via its endpoints but exists outside the document enfilade. This means a link can be created from one document, discovered from another (via transclusion), and its endpoints can reference content in multiple documents.

**Why it matters for spec**: The system state includes a link store separate from the document store: `System = { documents: Map<DocId, Enfilade>, links: Set<Link>, ... }`. Links are not nested within documents. The link store is indexed by I-address for efficient discovery (this is the span-f enfilade). Operations that modify documents have no direct effect on the link store (FC-LINK-PERSISTENCE). Only `create_link` adds to the link store. This architectural separation is why document operations cannot corrupt or destroy links.

**Code references**: Finding 0028b semantic model diagram; Finding 0010 (unified storage with subspace convention)

**Concrete example**:
```
LINK SPACE (span-f):
  Link L1: Source(A, 1.4, 0.3) → Target(B, 1.1, 0.6)
           Indexed by I-addresses: I.4, I.5, I.6

DOCUMENT SPACE:
  Document A: "ABCDEFGHIJ" (I.1-I.10)  — find_links → L1 (direct match on I.4-I.6)
  Document B: "Target..."             — link target lives here
  Document C: "Copy: EF" (I.5, I.6)   — find_links → L1 (I-address overlap)

L1 exists independently of A, B, and C. Deleting A does not destroy L1.
```

**Provenance**: Finding 0028b §5
