# Finding 0062 Analysis

## Entries

### SS-WHEREONCRUM

**What happens:** `whereoncrum()` classifies a tumbler address relative to a POOM crum's interval [grasp, reach). It computes `left = offset + cdsp` (the grasp) and `right = left + cwid` (the reach), then returns a five-way spatial classification:
- `TOMYLEFT` (-2): address < grasp
- `ONMYLEFTBORDER` (-1): address == grasp
- `THRUME` (0): grasp < address < reach (interior)
- `ONMYRIGHTBORDER` (1): address == reach (right boundary)
- `TOMYRIGHT` (2): address > reach

The critical distinction is that `address == reach` returns ONMYRIGHTBORDER, not THRUME. The reach is the exclusive endpoint of the half-open interval, so a position at the reach is classified as "on the boundary" rather than "inside." This five-way classification (identical to `intervalcmp` from SS-INTERVAL-CMP) drives all downstream insertion logic — different classifications trigger fundamentally different code paths in `findsontoinsertundernd` and `makegappm`.

**Why it matters for spec:** `whereoncrum` is the decision function for INSERT's tree traversal and knife-cutting logic. The formal model needs: `whereoncrum(crum, addr) : IntervalPos` where `IntervalPos = {ToLeft, OnLeft, Through, OnRight, ToRight}`. The ONMYRIGHTBORDER case is the linchpin for coalescing — it prevents splits and enables extension. A Dafny model should define this as a pure function and prove that it is consistent with the half-open interval semantics: `whereoncrum(crum, crum.reach) == OnRight`.

**Code references:**
- `retrie.c:345-372` — `whereoncrum()` full implementation with five-way switch
- `common.h:86-90` — constant definitions: TOMYLEFT=-2, ONMYLEFTBORDER=-1, THRUME=0, ONMYRIGHTBORDER=1, TOMYRIGHT=2

**Concrete example:**
```
Crum covers [v, v+1) (grasp=v, width=1, reach=v+1):

whereoncrum(crum, v-1) → TOMYLEFT (-2)
whereoncrum(crum, v)   → ONMYLEFTBORDER (-1)
whereoncrum(crum, v+0.5) → THRUME (0)
whereoncrum(crum, v+1) → ONMYRIGHTBORDER (1)   ← NOT THRUME
whereoncrum(crum, v+2) → TOMYRIGHT (2)
```

**Provenance:** Finding 0062

### PRE-INSERT

**What happens:** `makegappm()` performs an early-exit check before constructing the two-blade knife: if the insertion point equals or exceeds the crum's reach, the knife cut is SKIPPED entirely. The condition `tumblercmp(&origin->dsas[V], &reach.dsas[V]) != LESS` evaluates to TRUE when origin >= reach. When origin == reach (the ONMYRIGHTBORDER case), this means `makegappm` returns 0 without cutting. The knife is never constructed, `makecutsnd` is never called, and the crum is not split.

This is the mechanism by which consecutive interior typing avoids crum proliferation. After an initial insert at position v creates a crum [v, v+1), a subsequent insert at v+1 triggers the early exit because v+1 == reach. No split occurs, and the insertion proceeds directly to the extension check.

**Why it matters for spec:** The precondition for the knife-cut sub-operation within INSERT is: `pre_knife_cut(crum, origin) = origin >= crum.grasp ∧ origin < crum.reach`. Equivalently, `whereoncrum(crum, origin) ∈ {ONMYLEFTBORDER, THRUME}`. When `whereoncrum(crum, origin) == ONMYRIGHTBORDER`, no knife cut is performed — this is an explicit guard, not an omission. For Dafny, this can be modeled as: `method makegappm(crum, origin) requires crum.grasp <= origin < crum.reach`.

**Code references:**
- `insertnd.c:137-143` — Early exit condition in `makegappm()`: `if (iszerotumbler(&fullcrumptr->cwid.dsas[V]) || tumblercmp(&origin->dsas[V], &grasp.dsas[V]) == LESS || tumblercmp(&origin->dsas[V], &reach.dsas[V]) != LESS) return(0);`

**Concrete example:**
```
Crum covers [1.3, 1.4) (grasp=1.3, width=0.1, reach=1.4)

INSERT at 1.3:  origin < reach → KNIFE CUT occurs (splits crum)
INSERT at 1.35: origin < reach → KNIFE CUT occurs (splits crum)
INSERT at 1.4:  origin == reach → NO knife cut (early exit, return 0)
INSERT at 1.5:  origin > reach  → NO knife cut (early exit, return 0)
```

**Provenance:** Finding 0062

### ST-INSERT

**What happens:** When an INSERT at position v+1 encounters a crum whose reach equals v+1 (ONMYRIGHTBORDER), the system performs rightward extension instead of splitting. The function `isanextensionnd()` checks two conditions: (1) the new content has the same `homedoc` as the existing crum, and (2) the new content's origin equals the existing crum's reach. When both hold, the existing crum's width is extended in place — no new crum is allocated.

For interior typing, this produces the following sequence:
1. First insert at v: splits existing crum into [left, v) and [v+1, ...); creates new crum [v, v+1). Cost: +2 crums (split creates two halves, minus the one destroyed, plus one new = net +2).
2. Second insert at v+1: new_crum's reach is v+1, origin is v+1 → ONMYRIGHTBORDER → no split. `isanextensionnd` succeeds → crum extended to [v, v+2). Cost: +0 crums.
3. Third insert at v+2: extended crum's reach is v+2, origin is v+2 → same pattern. Cost: +0.
4. N-th insert: always +0.

The extension is asymmetric: crums grow rightward only. `isanextensionnd` checks if reach == origin (right extension), not if grasp == origin + width (left extension).

**Why it matters for spec:** This refines the ST-INSERT postcondition for the coalescing case. When the insertion point equals an existing crum's reach and homedoc matches: `post_insert_coalesce(crum, content) = crum.width' = crum.width + content.width ∧ crum.grasp' = crum.grasp ∧ num_crums' = num_crums`. The state transition creates no new crums — the content is absorbed into the existing crum. This is distinct from the splitting case (where Δcrums = +2) and the append case (where Δcrums may be 0 or +1 depending on contiguity).

**Code references:**
- `insertnd.c:293-301` — `isanextensionnd()`: checks homedoc match AND reach == origin
- `insertnd.c:243` — Width extension: existing crum grows in place
- `insertnd.c:252-260` — New crum creation (when extension fails)

**Concrete example:**
```
Before: doc = "ABCDE", crums = [crum₁: V 1.1..1.6]
INSERT "X" at 1.3:
  Knife cuts crum₁ → [crum₂: 1.1..1.3, crum₃: 1.4..1.6]
  New crum₄: [1.3..1.4) for "X"
  crums = 3 (Δ = +2)

INSERT "Y" at 1.4:
  crum₄.reach = 1.4, origin = 1.4 → ONMYRIGHTBORDER → no knife cut
  isanextensionnd(crum₄, "Y") → TRUE (same homedoc, reach == origin)
  crum₄ extended: [1.3..1.5) for "XY"
  crums = 3 (Δ = 0)

INSERT "Z" at 1.5:
  crum₄.reach = 1.5, origin = 1.5 → ONMYRIGHTBORDER → no knife cut
  isanextensionnd(crum₄, "Z") → TRUE
  crum₄ extended: [1.3..1.6) for "XYZ"
  crums = 3 (Δ = 0)
```

**Provenance:** Finding 0062

### INV-CRUM-BOUND

**What happens:** Continuous interior typing at a single cursor position costs exactly +2 crums for the first character, then +0 for every subsequent character. This gives a tight upper bound on crum count: `c ≤ 1 + 2C + 3R + 3P`, where C is the number of distinct cursor repositionings (each incurs the +2 split cost once), R is the number of rearrangements (cut-paste), and P is the number of pastes. The coefficient 2 for C reflects the verified cost: each new typing position pays the split penalty exactly once, after which all further characters at that position coalesce at zero cost.

This bound is tight because:
- The initial document has 1 crum (the original content)
- Each cursor repositioning to a new interior position creates a split (+2 crums)
- Sequential typing at the same cursor position coalesces (+0 crums per character)
- The ONMYRIGHTBORDER + isanextensionnd mechanism is what makes the coefficient 2 (not 2N for N characters)

**Why it matters for spec:** This is a universally quantified complexity invariant: `forall doc : Doc, ops : Seq<Op> :: crum_count(apply(doc, ops)) ≤ 1 + 2*cursor_repositions(ops) + 3*rearrangements(ops) + 3*pastes(ops)`. It can be verified in Dafny as a lemma over operation sequences, with the coalescing behavior (ST-INSERT above) as the key inductive step. The invariant depends on three verified facts: (1) ONMYRIGHTBORDER prevents knife cuts at crum boundaries, (2) `isanextensionnd` merges contiguous same-homedoc insertions, (3) extension is rightward-only.

**Code references:**
- `retrie.c:345-372` — `whereoncrum()` boundary classification
- `insertnd.c:137-143` — `makegappm()` early exit at boundary
- `insertnd.c:293-301` — `isanextensionnd()` extension check

**Concrete example:**
```
Start: "ABCDEFGH" → 1 crum
Type "12345" at position 5 (interior):
  "1" at 1.5: +2 crums → 3 crums  (split + new)
  "2" at 1.6: +0 crums → 3 crums  (coalesce)
  "3" at 1.7: +0 crums → 3 crums  (coalesce)
  "4" at 1.8: +0 crums → 3 crums  (coalesce)
  "5" at 1.9: +0 crums → 3 crums  (coalesce)
Result: "ABCD12345EFGH" with 3 crums, matching 1 + 2*1 = 3

Verified by golden test: single contiguous vspan from 1.1 with width 0.13.
```

**Provenance:** Finding 0062

### EC-BOUNDARY-INSERT-CLASSIFICATION

**What happens:** When content is inserted at the exact boundary between two existing crums (e.g., position 1.4 which is the right border of crum "AAA" covering [1.1, 1.4)), the insert is classified as a boundary case, not an interior split. Test 3 demonstrates this: inserting "X" at 1.4 — the boundary between "AAA" and "BBB" — results in "AAAXBBBCCC" with a single contiguous vspan. The "X" is placed between the two crums without fragmenting either one.

The classification depends on which crum `findsontoinsertundernd` selects as the insertion target. For a position at the right boundary of crum_left (ONMYRIGHTBORDER), the function evaluates whether the position falls within the range of the adjacent crum_right (ONMYLEFTBORDER). The result is that boundary insertions are handled by the neighboring crum rather than splitting the crum whose boundary they touch.

**Why it matters for spec:** Boundary insertions are an edge case where the five-way classification system prevents unnecessary splits. The spec should note that `INSERT(pos)` where `pos == crum.reach` for some crum is NOT equivalent to `INSERT(pos)` where `crum.grasp < pos < crum.reach`. The former triggers the ONMYRIGHTBORDER path (no split, possible extension); the latter triggers the THRUME path (split). This distinction is observable: the former produces fewer crums.

**Code references:**
- `insertnd.c:269-291` — `findsontoinsertundernd()` selects which crum handles the insert
- `retrie.c:345-372` — `whereoncrum()` classifies position relative to each candidate crum

**Concrete example:**
```
Before: "AAA" [1.1, 1.4) + "BBB" [1.4, 1.7) + "CCC" [1.7, 1.10)
INSERT "X" at 1.4:
  1.4 is ONMYRIGHTBORDER of "AAA" (reach = 1.4)
  1.4 is ONMYLEFTBORDER of "BBB" (grasp = 1.4)
  findsontoinsertundernd selects "BBB" as target
  Result: "AAAXBBBCCC" — single contiguous vspan, no fragmentation
```

**Provenance:** Finding 0062
