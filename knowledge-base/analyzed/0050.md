# Finding 0050 Analysis

## Entries

### SS-BERT

**What happens:** The BERT access control mechanism is architecturally advisory, not enforced. The back end contains the `checkforopen`/`findorgl` machinery described in Finding 0014, but for state-modifying operations (INSERT, DELETEVSPAN, REARRANGE, COPY), the BERT check occurs *after* the success response has already been sent to the front end. The BERT table exists as state, but it functions as a coordination hint rather than an access gate.

The back end handler pattern for mutations is:
1. `getXXX()` — parse the request
2. `putXXX()` — send success response to front end
3. `doXXX()` — attempt the actual operation (which calls `findorgl(..., WRITEBERT)`)

When `findorgl` returns FALSE (BERT check fails), the operation is silently skipped — the front end has already received success. This means the BERT table's state does not actually gate mutations; it only determines whether the `doXXX` path executes internally.

**Why it matters for spec:** The specification must model two distinct things: (1) the BERT state structure (as in Finding 0014), and (2) the fact that BERT enforcement is a front-end protocol obligation, not a back-end invariant. The spec should distinguish between the *intended* access control semantics (which BERT represents) and the *actual* enforcement boundary (which is the front end). A formal model might express this as: the back end's postconditions for mutations hold *only if* the front end has satisfied BERT preconditions — they are conditional postconditions, not unconditional guarantees.

**Code references:**
- `fns.c:84-98` — `insert()` handler: `putinsert()` before `doinsert()`
- `fns.c:333-347` — `deletevspan()` handler: same response-before-check pattern
- `granf1.c:17-41` — `findorgl()` checks BERT via `checkforopen()`, returns FALSE on failure
- `bert.c:52-87` — `checkforopen()` actual BERT checking logic

**Concrete example:**
- Before: Front end sends INSERT without acquiring WRITEBERT token
- Expected (if enforced): Back end rejects the operation, sends failure response
- Actual: Back end sends success response immediately via `putinsert()`, then `doinsert()` calls `findorgl()` which returns FALSE, operation is silently skipped. Front end believes the insert succeeded. Document is unchanged.

**Provenance:** Finding 0050

### PRE-INSERT

**What happens:** The WRITE BERT precondition for INSERT (and all other state-modifying operations) is not enforced by the back end. `doinsert()` calls `findorgl(taskptr, granf, &docisa, &docorgl, WRITEBERT)`, which checks `checkforopen()`. If the check fails (`<= 0`), `findorgl` returns FALSE, and the operation silently does nothing. But the front end has already received a success response from `putinsert()`, which was called before `doinsert()`.

This means the precondition "caller holds WRITEBERT for the target document" is a *protocol obligation* that the front end must satisfy voluntarily. The back end does not reject operations that violate this precondition — it accepts them (sends success) and then silently discards them.

**Why it matters for spec:** The Dafny `requires` clause for INSERT (and DELETEVSPAN, REARRANGE, COPY) must state that the caller holds WRITEBERT. But the spec must also note that this precondition is *not validated* — violating it produces silent data loss (the operation appears to succeed but has no effect). This is a stronger claim than "convention over enforcement" from Finding 0011: the system actively misleads the caller about operation success.

**Code references:**
- `fns.c:84-98` — `insert()`: response sent at line ~90, operation attempted at line ~92
- `do1.c:162-171` — `dodeletevspan()`: `findorgl(..., WRITEBERT)` call
- `do1.c:34-43` — `dorearrange()`: same pattern
- `do1.c:45-65` — `docopy()`: same pattern

**Concrete example:**
- INSERT without WRITEBERT: front end receives success response, but `doinsert()` returns FALSE and document content is unchanged
- DELETEVSPAN without WRITEBERT: front end receives success response, but `dodeletevspan()` returns FALSE and no v-span is deleted

**Provenance:** Finding 0050

### INV-WRITE-EXCLUSIVITY

**What happens:** The write exclusivity invariant (at most one connection holds WRITEBERT for a document) is a *logical* invariant of the BERT table state, but it is not an *enforced* invariant of document mutation. Because the back end does not gate mutations on BERT checks (response is sent before the check), a front end that ignores the BERT protocol can write to any document regardless of who holds the WRITE token. Multiple front ends could concurrently mutate the same document if they bypass BERT token acquisition.

**Why it matters for spec:** The formal invariant `|{c: Connection | bert(c, d) = WRITE}| <= 1` (from Finding 0014) holds for the BERT table itself but does not imply single-writer access to document content. The spec must distinguish between the BERT-table invariant (which the back end does maintain) and the document-mutation invariant (which requires front-end compliance). In a threat model with untrusted front ends, write exclusivity is not guaranteed.

**Code references:**
- `bert.c:43-50` — access matrix enforces exclusivity *within the BERT table*
- `fns.c:84-98` — mutation handler bypasses BERT check in the response path

**Provenance:** Finding 0050

### EC-RESPONSE-BEFORE-CHECK

**What happens:** For state-modifying FEBE operations, the back end sends the success response (`putXXX`) before executing the operation (`doXXX`). When the operation fails internally (BERT check, or any other failure in the `doXXX` path), the back end prints an error to stderr and silently continues. The front end has no way to detect the failure — it has already received a matching success response code.

Contrast with `createlink()` in `fns.c:100-115`, which follows the correct pattern: `getcreatelink() && docreatelink()` are checked *before* `putcreatelink()` is called, and `putrequestfailed()` is sent on error.

Commented-out code in `fns.c` shows the correct pattern for `deletevspan()` as well, suggesting the implementers were aware of the issue.

**Why it matters for spec:** This is a protocol-level edge case with direct implications for the FEBE contract. The spec must document that for mutations, the response code does not confirm operation success — it only confirms request receipt. Any formal model of the FEBE protocol must treat mutation responses as acknowledgments, not confirmations. The `createlink` operation is an exception that does confirm success.

**Code references:**
- `fns.c:84-98` — `insert()`: response before operation
- `fns.c:333-347` — `deletevspan()`: response before operation
- `fns.c:100-115` — `createlink()`: correct pattern (response after operation)
- `fns.c` (commented-out code) — correct `deletevspan` pattern was present but disabled

**Concrete example:**
- INSERT: `putinsert(taskptr)` at step 2, `doinsert(taskptr, ...)` at step 3. If step 3 fails, front end already has success from step 2.
- CREATELINK: `docreatelink(...)` checked first, `putcreatelink(taskptr, &linkisa)` sent only on success, `putrequestfailed(taskptr)` sent on failure.

**Provenance:** Finding 0050

### INT-BERT-FEBE

**What happens:** The FEBE boundary is not a trust boundary — it is a coordination protocol. The back end trusts the front end to: (1) acquire BERT tokens before mutations, (2) respect write exclusivity, and (3) release tokens when done. The back end provides the BERT machinery for front ends to coordinate among themselves, but does not enforce compliance. A non-compliant front end can perform any mutation on any document.

This means the FEBE contract (front end obligations FE3: token acquisition) is a *cooperative protocol*, not an *enforced contract*. The back end's role is to maintain shared BERT state for coordination; the front end's role is to consult and obey it.

**Why it matters for spec:** The formal specification must explicitly model the trust assumption: all behavioral guarantees (write exclusivity, access control, concurrent safety) are conditional on front-end compliance with the BERT protocol. This is a system-level assumption, not a component-level invariant. Formalizable as: `system_correct ↔ (backend_correct ∧ all_frontends_compliant)`. Without this assumption, the only guarantee is that the BERT table itself is consistent.

**Code references:**
- `fns.c:84-98` — mutation handler trusts front end
- `granf1.c:17-41` — `findorgl` BERT check is internal only
- `bert.c:52-87` — BERT state is maintained but not used as a gate

**Provenance:** Finding 0050
